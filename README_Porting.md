# Porting Games From Other Systems To Atari

**Introduction**

The Atari 8-bit computers have astounding capabilities considering the chips were first manufactured for development systems in 1978 and the home computers went on sale to the public in 1979.  The computers are the evolutionary successor to the Atari 2600 video game system, and the ancestor of the Amiga.  Some concepts from the 2600 apply to the Atari 8-bits, and understanding the Ataris provides insight into the Amiga's custom hardware features. 

The 2600 requires a programming methodology that would drive most people nuts.  The machine has 128 bytes of RAM.  (BYTES, not KILOBYTES.) There is no memory for graphics.  Everything displayed on the screen has to be written into the graphics chip's registers by the program as the screen is drawn.  The game logic is slave to tight timing cycles.  Between the programming difficulty, and the more primitive graphics capabilities, Atari 2600 games tend to be simple.  In spite of this there are mind-blowing games on the 2600.  Respect is due the person who can write any kind of functional game for the 2600.

The Atari computers began design as the advanced replacement for the 2600 video game system that would have more capabilities and be easier to program.  Almost as soon as design started the focus shifted from a video game to making a personal computer with superior graphics ability.  Some of the resulting machines' graphics features would not be bested until the Amiga appeared.  

Programming the Atari computers is considerably easier than the 2600.  In fact, by comparison, the Atari computers allow downright lazy coding.  The graphics chips generate the playfield text and graphics and Player/Missile overlay graphics without direct CPU intervention.  The program simply arranges the data in memory and tells the graphics hardware where to find everything.  An Atari computer game is free to spend more time on complex game logic. 

The Atari systems were popular in their time, selling several million of units, and around the 1982 to 1983 years they were very popular targets for software developers.  But, everything was not ported to all computers.  Each computer model had games written for them that may have been ported to only a limited number of other systems that possibly did not include the Ataris, or may not have been ported to any other computer at all.

Porting other systems games to the Atari is an entertaining and educational experience.  The programmer learns how other computers worked, devises ways the Atari can represent the same thing using different graphics architecture and gives one an appreciation for how much can be done with tiny amounts of memory.

---

**Overview Of The Atari Hardware**

The first part of porting is knowing what you're porting to, and so understand how to fit another computer's features into what the Atari can do.  Some things another computer can do may not be easily portable to the Atari, and at other times you may choose to enhance something on the Atari beyond what the original platform can do.  Do not expect, or even try to mak an Atari game look exactly like the game on another system.  Atari graphics features have their own strengths and weaknesses, so try to fit game behavior into the Atari's style.  Atari graphics are originally intended for NTSC color television, so some features must look different on  video standards (PAL, SECAM, etc.)  that another computer may use.  An overview of Atari features:

- 1.79 MHz 6502 processor.  This is one of the fastest 6502 computers released.  Most other systems work at 1MHz.

- Custom character set.  The Atari's text modes can render the imagery for text characters from anywhere in memory.  The images for characters can be changed simply by pointing to different memory.

- 6 text modes.
  - 2 modes of 40 column text based on the "high resolution" pixels.  This allows monochrome text, plus a border color.  One mode is 8 scan lines tall which is the standard text display on the Atari.  The other is infrequently used and is 10 scan lines tall allowing for lower case descenders if an appropriate custom character set is supplied. 
  - 2 modes of 20 column text based on the "medium resolution" pixels. This allows 5 colors.  Each character is a single color.
  - 2 modes of 40 column text based on the "medium resolution" pixels. This allows up to 5 colors with 4 colors within a single character.

- 8 graphics modes.
  - color modes range from very low resolution at 40 pixels across the screen, to "medium resolution" at 160 pixels across the screen.  
  - "high resolution" mode is 320 pixels across the screen allowing monochrome graphics (2 shades of the same color)

- Mixing graphics modes on the screen.  The display is generated by the ANTIC graphics chip executing a "Display List" of instructions which specifies what kind of text or graphics to display for each horizontal line on the screen.  No CPU intervention is required for mixing graphics and text modes on the screen.

 - Display List Interrupt. The Display List instructions can trigger a machine language routine when the display reaches that line of the display.  Typical use is to change the value of color registers allowing more colors on screen, and changing the Player/Missile graphics to new positions.

- Vertical Blank Interrupt. The end of the Display List at the bottom of the screen triggers a system machine language routine that can optionally transfer to a custom routine supplied by the program.
 
- Text/Graphics memory indirection.   Any part of the Atari computer's memory map may be displayed as text/graphics for each line in the Display List.  Memory used for text/graphics does not need to be contiguous from line to line. 

- Overscan.  The Atari display can extend vertically or horizontally beyond the edges of the typical NTSC TV.   (Mileage may vary on modern LCD screens or emulators.)  Vertical overscan is done with the Display List instructions.  Horizontal overscan is a register setting in the graphics chip.  Horizontal overscan results in the graphics chip displaying more text characters or graphics pixels on the horizontal line than described earlier for normal graphics behavior.

- 128 color palette.  256 colors in some color interpretation modes.  Depending on graphics mode and color interpretation mode 2, 4, 5, 9, or 16 colors can be on screen at once without using any machine language routines to reuse colors. 

- Full Color indirection.  In most of the graphics modes the normal color interpretation allows all the colors on the screen to be any one of the 128 colors in the palette via a hardware register assigned to that color.  Changing the value of the color register changes all the pixels in the screen using that color register.

- Four color interpretation modes. The 14 text and graphics modes can be rendered using one of four kinds of color interpretation.  In theory, this makes 46 graphics modes possible.  However, the last three color interpretation modes (GTIA modes) work best in conjunction with certain graphics modes, so not all 46 combinations are practical.
  - Normal color interpretation utilizing color indirection.
  - 3 GTIA modes: 16 shades of one base color.  Up to 9 colors using color indirection.  16 colors all using the same brightness.

-  An easy but infrequently used feature is color mixing between Player/Missile pixels and playfield pixels engaged by certain priority controls.  This can create up to 23 colors in normal color interpretation mode and up to 38 colors in the GTIA color interpretation modes.
  
- Fine scrolling.
  - Up to 16 pixels horizontally (4 normal text characters) and up to 16 scan lines vertically.
  - Hardware assisted coarse scrolling.  The Display List can contain a pointer to the memory to use for graphics.  "Moving" a line of text or graphics requires only updating the pointer to memory instead of redrawing the entire line of data in memory. 

- Player/Missile graphics
  - Four, 8-pixel wide "Players" with separate color registers from  the text/graphics colors.
  - Four, 2-pixel wide "Missiles" using the Player's colors.
  - Full collision detection of Player/Missiles to each other and to each specific color of playfield pixel.
  - Variable priority allowing Player/Missiles to be in front of or behind playfield text/graphics.
 
 - Four channel sound with variable noise waveforms.
 
 - Two (or four on the Atari 400/800) game controller ports provide inputs separate from the keyboard.  (Digital joysticks, potentiometers, and light pen input.)
 
 - Option, Select, Start buttons read separately from the keyboard and game controllers.

Whew!  That's a lot, and it still leaves out considerable detail.  People have written entire books about this.


**Atari Programming Environments**

The next consideration for the Atari as the porting target is understanding how the chosen language affects the scope of the available feature on the Atari.  6502 Assembly language provides total control of the machine language program and offers complete use of all the Atari's features.  If it can be done on the Atari, it can be done in Assembly.

Atari BASIC -- It is easy to understand and allows for quickly testing code changes, since it is an interpreted language.  I use BASIC for new projects to prototype a program, so I can get logic in order and some semblance of the graphics working before starting in Assembly language.  If the game for another computer is written in BASIC, then converting to Atari BASIC is the best practical first step.  However, operating in Atari BASIC limits the hardware features possible.  Some Atari graphics features require use of machine language.  

If you are determined to work with BASIC, then I recommend using something other than Atari BASIC.  My favorite is OSS BASIC XL (or XE) which is compatible with Atari BASIC, but considerably faster, and has built-in support for Player/Missile graphics that Atari BASIC does not have.  However, no matter what you do any kind of interpreted BASIC is far, far slower than Assembly language.  That's reason enough to avoid Atari BASIC.

There are versions of BASIC, and other languages that can be compiled into machine language.  Often the results are as good as working in Assembly, though sometimes there can still be compromises or language-specific gymnastics when working directly with Atari hardware features.  I do not have a lot of experience with these languages.  BASIC and Assembly cover all the bases for me.


**Things You Can Do In Atari BASIC**

The following is a list of Atari features that a BASIC program can use.  Assembly is not needed to set up the features, though with BASIC the feature's use may be limited.

- Redefined custom character sets

- Create a Display List mixing text and graphics modes on the same display.

- Overscan.  Surprisingly easy, but not often used.  Build a Display List using more scan lines for vertical overscan.  Change the graphics chip's horizontal width register.   The change in display width does make it more difficult to print or plot graphics as the wide display does not match the expectations of the Operating System's graphics routines.

- Hardware assisted coarse scrolling.  Well-planned use of the Display List and pointers to screen memory can make coarse scrolling the display, or a limited set of lines on the display appear to move together as one solid object without tearing.

- Player/Missile graphics - Loading and positioning an image for Player/Missile graphics is easy in BASIC.  Animating an image is a harder problem.  OSS BASIC XL has built-in commands for vertically moving Player missile graphics.  The other common method is to use Atari BASIC/BASIC XL's unique string capabilities to assign a string to Player/Missile memory and manipulate the string.

- Color mixing between playfield and Player/Missiles pixel colors.

- Sound.  Atari BASIC includes commands to play sounds.  Complicated music is more difficult due to the execution speed of BASIC. 

- And trivial things: reading the keyboard, game controllers, and the Option, Select, Start keys.

---

**Considering Other Platforms**

Porting the first-person shooter Counter-Strike:Global Offensive to the Atari is an admirable goal which would probably never reach acceptable results within the a person's lifetime.  The best pool of potential games to port comes from other retro platforms sold around the same time as the Atari, since they would have reasonably similar capabilities as the Atari.

There were numerous kinds of computers sold commercially during the time of the Atari, and I will not be discussing every single one.  Many have become obscured in history to the point it is difficult to find programs or source code listings.  If you do find an interesting game and the source for it on a less popular computer, then thumbs up for your team and have a ball with it.

A reasonable list of the commonly available home computers marketed in the US during the 1977 to 1983 timeframe: Pet, TRS-80, Apple II, TRS Color Computer, VIC-20, TI-44/9, Commodore 64, IBM PC/clones.  I'm not as familiar with many non-US brands.  Based on the documentation availability and YouTube reviews of systems and games here is my short list of non-US systems that seem to be popular:  BBC Micro, ZX Spectrum, Dragon, Sinclair ZX81.

These platforms capabilities vary.  SOME are extremely limited.  SOME are better than others.  SOME may be limited in most respects, but have a feature the Atari can't inherently duplicate (e.g.  64 column text, Color maps.)  SOME can be improved with optional add-ons that will not be considered here.  The POSSIBLE lowest common denominators:

- Limited graphics modes.  Perhaps even no graphics beyond the text display.

- If multiple graphics modes are possible the hardware cannot easily mix graphics modes, or text with graphics on screen.  Where this does occur it is usually done by simply drawing text on a graphics display.

- Limited color palette:  2, 4, 8, or 16 colors.  Either no, or limited color indirection supported.  

- Color may be implemented by a separate color map that specifies the color used in a character-sized tile.  The Atari doesn't have a color map feature, so this is one of the harder objectives to work around.

- Fixed location in memory for the text/graphics screen.

- Fine scrolling is usually not supported beyond physically redrawing the entire screen, and coarse scrolling requires redrawing the screen.

- No sound or limited sound.


**Common Conflicts And Atari-Specific Values**

Some conflicts are nearly universal between differing platforms.  Many revolve around character representation.  While most computers are based on an ASCII layout for A-Z, 0-9, and basic symbols, each platform adds unique usage for other values. Possibilities:

- No lower case support. 
- ASCII control character values are not treated as such.
- Custom graphics characters in place of others ASCII characters.
- Some lesser-used symbols are not supported. (e.g. braces, backtick, tilde.)
  
These are the common issues specific to the Atari's differences. 
 
- Plain text on the Atari is in ATASCII codes which is ASCII-like, but different from the ASCII used on other computers.   
  - Basic A-Z, 0-9 characters are the same as ASCII.
  - Character 155(dec)/$9B(hex) as the end of string, and new line/carriage return.  
  - Character 0, often used as end of string on other systems, is a valid graphics character on the Atari. 
  
- Character set image order is different from ATASCII order.  (Other systems with refined character sets tend towards ASCII order.)
  - Notably, entry 0 in the character set is for the blank space.  (This is actually a benefit.  When a program reads a zero value byte from screen memory it can use the CPU zero flag immediately without doing a comparison to recognize an blank/empty place on screen.)

- Keyboard scan codes on the Atari are also different from both ATASCII and the the internal character set order.

**The Other Platforms**

**The 6502s**

Games written in Assembly for other 6502-based computers would be easiest to port to the Atari in Assemble, since the language syntax will be similar.  Managing idiosyncrasies of the different Assemblers may require retyping, or re-indenting.
 
PET

The 40xx series supports a monochrome text display of 40x25 characters.  Later models support 80 column text. It has no actual graphics capability and no color.  It does have a large text character set which includes lower case characters and many graphics shapes.  With careful use the text can create displays that appear to be drawn graphics.  As everything is text-based any game object or moving player is based on character positions. It has no sound, no joysticks, and as it has very limited hardware its BASIC language has little unique considerations.  There would be very little difference in capabilities between a BASIC program and an Assembly program in the Pet other than the execution speed. 

Any game for the Pet 40xx series systems should fit well within the Atari's display capabilities.  The 25 lines of text can easily be handled with a modified Display List.  Some graphics characters on the Pet would require a redefined character set on the Atari replacing some characters with Pet-like images. 

APPLE II

The Apple supports 40x24 character text mode.  Earlier models had only upper case alpha characters.  Later models supported lowercase.  It has an infrequently-used, low resolution, 80x48, 16-color mode.  Most games use the remarkably engineered 280x192 high resolution mode that works on a NTSC television to display six colors at 140 x 192 by exploiting the NTSC artifacts.  The system supports two separate screens for high resolution graphics allowing a computer with enough memory to double-buffer and display one screen while redrawing the other.  There is a hardware register setting to replace the bottom of the graphics screens with several lines of text.  The Apple has a shape table feature that executes a list of pseudo-coded line drawing commands that permit rotating and scaling the drawn lines.  Most Assembly games will write images directly to screen memory which is linear horizontally, but is not contiguous between adjacent lines.  Built-in sound is limited to clicks and short beeps on the keyboard speaker.  If joysticks are used they are analog controls made of 2 potentiometers (paddles controllers). 

The Atari has a high resolution mode that generates NTSC artifact colors, but can only do 4 colors, not the 6 like the Apple.  Since artifacts effectively halve the pixel resolution then the Atari's Mode E, "medium resolution", 160 pixel graphics mode could also substitute.  It really depends on whether or not the Apple game uses all six colors and how the colors are used.  Player/Missiles could provide more color in limited places. 

VIC-20

The VIC-20 has a 16 color palette, supports 22x23 color text, and redefined character sets.  16 colors are available for the background and 8 colors for the text.  Text characters may be 8x8 pixels in one foreground color, or 4x8 pixels allowing 3 colors in the characters, plus the background.  There are no graphics modes.  Displays that appear to be graphics are exploiting redefined character sets.  It uses a color map to specify colors per character positions.  It has a 3 voice sound chip, and supports an Atari digital joystick.

Since the only graphics capability is redefined character sets, there are literally hundreds of games, and quite a number that were sold commercially, that are almost the same game pushing text characters around the screen using a different redefined character set.  Some more advanced games use redefined characters to simulate bit-mapped graphics and shift images through multiple characters to perform pixel-based graphics animation.

ANTIC Mode 6 text has 20 characters per line and can show characters in 4 colors where the entire character is a single color. This is the closest in size to the VIC-20's 22 character text mode.  Using the Atari's wide screen for overscan allows adding characters to the line, so the Atari can manage 22 characters in Mode 6 which fits (just barely) on an NTSC TV.  However, this does mean the Atari's version of 22 characters is noticeably wider than the VIC-20's.  (Covering more TV screen area could be considered a bonus.)

ANTIC Mode 6 also uses 64 characters in its character set, so the VIC-20 program may run through more characters than the Atari can display.  Where characters are specific objects the Atari could deal with it via a Display List interrupt switching character sets every few lines, or using a more dynamic (and slower) method where the character images needed at the moment are copied to the characters shown on screen.  Where a VIC-20 game uses multiple characters to simulate a large graphics bitmap the Atari could do the same thing, as only 22 characters are needed for the same line, so a different character set every 2 or three lines could do the same work.

Another obstacle is the VIC's 16 background, and 8 text colors using a color map.  In most situations they are not all used.  Background coloring is a little more difficult as the Atari has one color for the background.  Display List interrupts can change the 4 text colors and background color for each line.  Where more color is needed, Player/Missile graphics can add limited amounts of color.  But, inevitably there will be situations where a color or two will have to be ignored or worked around.  



COMMODORE 64

The Commodore 64 is the newest of the systems and so more capable than most.  It has a 16 color palette, supports 40x25 color text, and redefined character sets. Similar to the VIC-20 the text characters may be 8x8 pixels in one foreground color, or 4x8 pixels allowing 3 colors in the characters, plus the background.  Unlike the VIC-20 the C64 also supports graphics modes with similar rendering, and memory arrangement as the text character modes.  (1 bit for monochrome color pixels, and 2 bits for 4 color pixels.)  It uses a color map to specify colors per character positions and supports a limited amount of color indirection for some colors on the playfield.  It supports 8 movable "sprites" in 24x21 pixels and  1 color, and 12x21 pixels in 3 colors.  Sprites support limited collision detection with the playfield graphics.  It has a 3 voice sound synthesizer chip, and supports two Atari digital joysticks.


**Other CPUs**

Games written in Assembly for other computers that do not use the 6502 will be harder to port as you'll have to learn the nuances of a different Assembly language.  It could be easier to start from BASIC programs, or to execute porting simply based on visual appearance without reading too much of the original code.

TRS-80

The TRS-80 models use a Z80 CPU.  This makes porting Assembly language source more difficult.  Porting from BASIC games would be a better place to start if you don't want to learn Z80.  The models support 64x16 monochrome text and "graphics" using character cells divided into 2x3 segments as pixels (128x48 pixels).  The BASIC language has commands to plot pixels, and also allows a string packing technique to compress a series of pixel instructions, and then "print" them quickly to a location on screen.  Some later models support 80 column monochrome and higher resolution graphics.

The 64 column text would need some workarounds on the Atari, if needed, since it is bigger than the Atari screen width.  The 128x48 graphics pixels are an odd dimension considerably less than most Atari graphics modes.  This could be duplicated with a line of Mode B and Mode C referencing the same line of screen memory and setting narrow screen width for 128 pixel width.  Alternatively, use the normal width screen for 160 pixels horizontally, and only draw in the middle 128 pixels.

TRS COLOR COMPUTER

This system is based on the 6809 CPU which is not so similar to the 6502, so BASIC programs are an easier starting point.  It supports color text at 32x16.  It also supports graphics modes from 64x32 in 8 colors up to 256x192 in 4 colors.  The prior monochrome TRS-80 Model  concept of text characters subdivided into pixels also applies to this system, but supports more than one color on screen.  (The last version, Model 3 has more enhanced graphics.)  It includes a sound chip, and allows two analog joysticks similar to the Apple.  

TI-99/4

This is another computer using  ...  Test, graphics, sprites, sound.  Joysticks.

BBC MICRO


**Types of Games To Port**

**BASIC PROGRAMS**

BASIC programs will utilize fewer of the features of the computer making it easier to port to the Atari.  Also consider that when BASIC is the source and Assembly is the target, then Atari BASIC games are eligible for "porting".  A functional, but mediocre Atari BASIC game could be embellished with Assembly language into a work of art and an exciting gaming experience. 

**ASSEMBLY PROGRAMS**

Assembly programs may use more features of the original platform.  Each source system is differently abled from the Atari, so it is unlikely the Atari port can look exactly the same as the original.  Oranges do not have to equal Apples, so an approximation or replacement in the Atari style is always the goal. 

Then again, just because the game is in machine language doesn't necessarily mean the author is pushing the platform to limits that would be difficult for the Atari.  Sometimes nice, simple games are in Assembly, just because BASIC can't handle timing or many updates.


**SOURCES FOR GAMES**

- Books/Magazines from the 1970s and 80s.  
Multi-Platform and dedicated.  (archive.org)  classic computer magazine archive
trs80 color computer archive

- YouTube demonstrations.

- Github.

---

[Back to Home](https://github.com/kenjennings/Atari-Pet-Frogger/blob/master/README.md "Home") 


