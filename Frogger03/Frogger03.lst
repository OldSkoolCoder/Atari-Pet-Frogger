mads 2.0.8
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03.asm
     1 				; ==========================================================================
     2 				; Pet Frogger
     3 				; (c) November 1983 by John C. Dale, aka Dalesoft
     4 				; for the Commodore Pet 4032
     5 				; ==========================================================================
     6 				; Ported (parodied) to Atari 8-bit computers
     7 				; by Ken Jennings (if this were 1983, aka FTR Enterprises)
     8 				; ==========================================================================
     9 				; Version 00, November 2018
    10 				; Version 01, December 2018
    11 				; Version 02, February 2019 
    12 				; Version 03, August 2019
    13 				; ==========================================================================
    14
    15 				; ==========================================================================
    16 				; Version 00. November 2018
    17 				;
    18 				; As much of the Pet code is used as possible.
    19 				; In most places only the barest minimum of changes are made to deal with
    20 				; the differences on the Atari.  
    21 				;
    22 				; Notable changes:
    23 				; * References to fixed addresses are changed to meaningful labels.  This
    24 				;   includes page 0 variables, and score values.
    25 				; * Kernel call $FFD2 is replaced with "fputc" subroutine for Atari.
    26 				; * The Atari screen is a full screen editor, so cursor movement off the
    27 				;   right edge of the screen is different from the Pet requiring an extra
    28 				;   "DOWN" character to move the cursor to next lines.
    29 				; * Direct write to screen memory uses different internal code values, not
    30 				;   ASCII/ATASCII values.
    31 				; * Direct keyboard scanning is different requiring Atari to clear the
    32 				;   OS value in order to get the next character.  Also, key codes are
    33 				;   different on the Atari (and not the same as ASCII or Internal codes.)
    34 				; * Given the differences in clock speed and frame rates between the
    35 				;   UK Pet 4032 and the NTSC Atari the ported timing values have to be 
    36 				;   altered and the ultimate speed/rates are just guesswork.
    37 				;
    38 				; --------------------------------------------------------------------------
    39 				; Version 01.  December 2018
    40 				;
    41 				; Atari-specific optimizations, though limited.  Most of the program
    42 				; still could assemble on a Pet (with changes for values and registers).
    43 				; The only doubt I have is monitoring for the start of a frame where the
    44 				; Atari could monitor vcount or the jiffy counter.  Not sure how the Pet
    45 				; could do this.
    46 				;
    47 				; * No IOCB printing to screen.  All screen writing is directly to
    48 				;   screen memory.  This greatly speeds up the Title screen and game
    49 				;   playfield presentation.  It also shrinks that code a little.
    50 				; * New screens added when successfully crossing the river, dying, and
    51 				;   for game over.  The Huge text on these screens is constructed from
    52 				;   Atari-specific graphics/control characters.
    53 				; * Code is reorganized into an event/timer loop operation to modularize
    54 				;   game functions and facilitate future Atari-fication and other features.
    55 				;
    56 				; --------------------------------------------------------------------------
    57 				; Version 02.  February 2019
    58 				;
    59 				; The design principle continues to maintain the original presentation
    60 				; of a full screen of basic text.  (In Atari terms, this is ANTIC mode 2,
    61 				; or OS mode 0).  Everything else in the game is subject to Atari-fication.
    62 				;
    63 				; * Color.  Every line of the text mode has a DLI to set background color
    64 				;   and the foreground text luminance.  The color is also used as an
    65 				;   animation tool on the screens for dead frog, game over, and saving
    66 				;   a frog.
    67 				; * Joystick controller input.  Game controller input is a standard for
    68 				;   Atari games.  Say goodbye to the keyboard.
    69 				; * Sound.  Add at least simple sound effects for water/boats moving,
    70 				;   frog jumping, frog dying, rescuing a frog, joystick input.
    71 				; * Custom character set to make the frog look like a frog, and boats
    72 				;   look like plus other graphics enhancements.
    73 				; * Formalize game timing by implementing deferred vertical blank
    74 				;   interrupt to maintain the game activity and timings.
    75 				; * Screen memory is no longer declared at the same location as on the
    76 				;   Pet computer, and due to display lists is no longer contiguous RAM.
    77 				; * Display List LMS updates present the information on screen.
    78 				;   Displayed items can be presented by updating a few display list
    79 				;   LMS pointers rather than bulk movement of data through screen memory.
    80 				;   This is also used to move the boats around the screen by coarse
    81 				;   scrolling through the LMS.  This permits the screen memory to be
    82 				;   non-contiguous, and data can then be aligned in memory pages allowing
    83 				;   code to update either high byte or low byte of addresses.  Since the
    84 				;   frog is a character on screen it must move through screen memory
    85 				;   and so the game still requires six groups of beaches and boats
    86 				;   separately declared in memory.
    87 				;
    88 				; --------------------------------------------------------------------------
    89 				; Version 03.  August 2019
    90 				;
    91 				; The design principle is to continue to keep the play action as close as 
    92 				; possible to the original version as well as enhance the graphics 
    93 				; presentation as much as possible while still retaining layout as close 
    94 				; as possible to the original.  Changing features make the game appear 
    95 				; smoother, slicker looking.
    96 				;
    97 				; One play action difference -- in the original version the frog would 
    98 				; die when it contacted the left or right margin of the screen. In this 
    99 				; version the frog will not die (immediately).  When the frog reaches a 
   100 				; border it simply stops moving as the boats continue to leave the screen.
   101 				; Eventually, if the frog does not jump to a beach or the next safe place 
   102 				; on a boat, then the boat will slide out from under the frog and the frog
   103 				; will lose contact with the safe seat area.
   104 				;
   105 				; In spite of all the changes below which include making the boat lines
   106 				; taller with extra blank lines the screen manages to just barely fit
   107 				; the same number of beach and boat lines as the original.  This is due to
   108 				; the original version ignoring three full lines at the bottom of the 
   109 				; screen, and revising the credits to a single line of scrolling text.
   110 				; 
   111 				; * Horizontal fine scrolling the continuously scrolling credits line.
   112 				; * Halved the time for notes in Ode 2 Joy as it plays so long it 
   113 				;   starts to sound like a funeral dirge.
   114 				; * Horizontal fine scrolling the boats.
   115 				; * Manage Boat scrolling during the VBI.
   116 				; * Implement the frog as Player/Missile graphics.
   117 				; * Replace the chunky text "graphics" for Title, Saved, Game Over, and 
   118 				;   the Dead Frog with bitmaps for ANTIC map mode 9.  This is effectively 
   119 				;   the same pixel size, uses half the memory to cover the exact same
   120 				;   same screen real estate, and allows more color flexibility than 
   121 				;   Text mode 2.
   122 				; * Eliminate "blank" text lines where there is nothing displayed and use
   123 				;   actual blank line instructions in the Display List.   Additionally, 
   124 				;   the blank lines for the splash displays (Saved, Dead Frog, Game Over) 
   125 				;   can use smaller blank lines and so have more DLIs doing more color 
   126 				;   changes on the displays.
   127 				; * Revamp the DLI organization. Since each display has variations of 
   128 				;   screen content (especially the difference between Title, Game, and 
   129 				;   one of the "prize" screens) now each display has its own set of 
   130 				;   chained DLIs.  The VBI maintaining screens and DLI counter will also
   131 				;   enforce setting the base DLI routine for each display.
   132 				; 
   133 				; --------------------------------------------------------------------------
   134
   135
   136 				; ==========================================================================
   137 				; Random blabbering across the versions of Pet Frogger concerning
   138 				; differences between Atari and Pet, and the code considerations:
   139 				;
   140 				; Version 00 commentary. . . . . . . . . . . . . . . . . . . . . . . .
   141 				;
   142 				; It appears text printing on the Pet treats the screen like a typewriter.
   143 				; "Right" cursor movement the Pet uses to move through the full line
   144 				; width will cause the cursor to wrap around to the next line.  "Down" also
   145 				; moves to the next line.  I don't know for certain, but for printing
   146 				; purposes the program code makes it seem like character printing on the
   147 				; Pet does not support direct positioning of the cursor other than "Home".
   148
   149 				; Printing for the Atari version is implemented similarly by sending single
   150 				; characters to the screen editor, E: device, channel 0.  The Atari's
   151 				; full screen editor does things differently.   Moving off the right edge
   152 				; of the screen returns the cursor to the left edge of the screen on the
   153 				; same line.  (Remember, full screen editor).  Therefore the Atari needs
   154 				; an extra "Down" cursor inserted where code expects the cursor on the
   155 				; Pet to be on the following line.  It also appears that replacing the
   156 				; "Right" cursor movements with a blank space should accomplish the same
   157 				; thing on the Atari, but for the sake of minimal changes Version 00 of the
   158 				; port retains the Pet's idea of cursor movement.
   159
   160 				; Also, depending on how the text is printed the Atari editor can relate
   161 				; several adjacent physical lines as one logical line. Great for editing
   162 				; text lines longer than 40 characters, not so good when printing wraps the
   163 				; cursor from one line to the next.  Printing a character through the end of
   164 				; the screen line (aka the right margin) extends the current line as a
   165 				; logical line into the next screen line which pushes the content in the
   166 				; subsequent lines below further down the screen.
   167
   168 				; Since some code does direct manipulation of the screen memory, I wonder
   169 				; why all the screen code didn't just do the same.  Copy from source to
   170 				; destination is easier (or at least more consistent) than printing.
   171 				; Changing all the text handling to use direct write is number one on
   172 				; the short list of Version 01 optimizations.
   173
   174 				; The "BRK" instruction, byte value $00, is used as the end of string
   175 				; sentinel in the data.  This conflicts with the Atari character value
   176 				; $00 which is the graphics heart that the display uses in place of the
   177 				; "o" in "Dalesoft".  The end of string sentinel is changed to the Atari
   178 				; End Of Line character, $9B, which does not conflict with anything else
   179 				; in the code for printing or data.
   180
   181 				; None of the game displays use the entire 25 lines available on the PET.
   182 				; The only time the game writes to the entire screen is when it fills the
   183 				; screen with the block graphics upon the frog's demise.  This conveniently
   184 				; leaves the 25th line free for the "ported by" credit.  But the Atari only
   185 				; displays 24 lines of text!?!  Gasp!  Not true.  The Atari can do up to
   186 				; 30 lines of text (240 scan lines).  Only the OS printing routines are
   187 				; limited to 24 lines of text.  The game's 25 line screen is accomplished
   188 				; on the Atari with a custom display list that also designates screen
   189 				; memory starting at $8000 which is the same location used by the Pet.
   190 				;
   191 				; --------------------------------------------------------------------------
   192 				;
   193 				; Version 01 commentary. . . . . . . . . . . . . . . . . . . . . . . .
   194 				;
   195 				; "Printing" via standard OS I/O has been completely replaced by direct
   196 				; writes to screen memory.  This greatly speeds up the game screen
   197 				; and title screen presentation.
   198 				;
   199 				; Having entirely rewritten the game logic, the new modular nature
   200 				; made it easy to add new screens and to manage animated transitions
   201 				; between screens.  There are new splash screens with huge text built 
   202 				; of graphic control characters for when a frog dies, a frog is saved,
   203 				; and when the game is over.
   204 				;
   205 				; The high score is maintained in real-time with the player's score.
   206 				;
   207 				; The only thing that is really Atari-specific is monitoring the vertical
   208 				; blank.  Not sure how/if this could be done on the Pet.  The rest of the
   209 				; code is still pretty generic 6502 with screen memory at the Pet's
   210 				; standard location, $8000.  It should be easily portable back to the
   211 				; Pet by changing the character and key codes.
   212 				;
   213 				; Monitoring the vertical blank allows for more varied control of timing.
   214 				; The boat speeds are easily managed with a loop that relates the number
   215 				; of frogs saved to a frame count for delays.  Note that the code does
   216 				; not re-implement the CPU loop by waiting on frame updates.  Instead, it
   217 				; maintains counters during each frame and when counters reach 0 then the
   218 				; event (aka moving boats or accepting new input) is permitted.  This
   219 				; is effectively (cooperative) multitasking vaguely like an event loop.
   220 				;
   221 				; --------------------------------------------------------------------------
   222 				;
   223 				; Version 02 commentary. . . . . . . . . . . . . . . . . . . . . . . .
   224 				;
   225 				; Adding color was essentially trivial.  A table-driven Display List
   226 				; Interrupt routine sets a new background color and text luminance value
   227 				; for each of the 25 text lines. A Vertical Blank interrupt enforces the
   228 				; DLI state to start at 0 for every frame.  A rough prototype showing
   229 				; colorized displays was added to Version 01 code in just a few hours.
   230 				;
   231 				; Now that there is a VBI running various other timing controls can be
   232 				; formally put into the VBI rather than using looping code that detects
   233 				; the start of a TV frame.
   234 				;
   235 				; Further use of the color indirection will eliminate the need to maintain
   236 				; and write normal text and inverse text in screen memory to make blinking
   237 				; text.  The game can simply update the colors for that line of text to
   238 				; make it appear to blink.
   239 				;
   240 				; Given the Atari's significant graphics indirection capabilities there is
   241 				; no need to draw a screen to present it.  The data to supply the graphics
   242 				; is already in memory.  Properly arranging the data will allow the Atari
   243 				; to display the data directly as screen data.  This eliminates the need
   244 				; to have separate data and screen memory, and also eliminates the need
   245 				; for the supporting code to copy the data to the screen.
   246 				;
   247 				; Aaaand, the Atari has more than one way to do this.  First, we could
   248 				; update the LMS addresses in the Display List to point to each line of
   249 				; data for screen memory.  Changing the screen (or just the screen
   250 				; contents) is reduced to writing a two-byte pointer for each line in the
   251 				; Display List instead of writing 40 bytes for each line to screen memory.
   252 				; And where there are blank lines or otherwise duplicate data the LMS can
   253 				; point to the same screen data for each line.
   254 				;
   255 				; The other way to do this is to have a separate Display List for each
   256 				; screen.  This reduces changing the screen to writing one address for
   257 				; the entire screen.
   258 				;
   259 				; We're mixing these two methods.  Each screen will have its own Display
   260 				; List with color tables.  Change the display list pointer and the entire
   261 				; screen changes.  The game screen will also use updates to the LMS
   262 				; for each moving boat line to coarse scroll the boat data without moving
   263 				; the boats in screen memory.
   264 				;
   265 				; Since the frog must move in screen memory, there still must be separate
   266 				; data for each line of boats and beaches.  In a future version when the
   267 				; frog is a Player/Missile object independent from screen data then it
   268 				; will be possible to reduce the boats to one line for left and one for
   269 				; right and re-use the data for each set of lines.
   270 				;
   271 				; --------------------------------------------------------------------------
   272 				; Version 03 commentary. . . . . . . . . . . . . . . . . . . . . . . .
   273 				;
   274 				; Many Atarifications added in this go-round...
   275 				;
   276 				; The title screen has an animated frog done with player/missile graphics.
   277 				; This is the same player image (and same animation methods) as used for 
   278 				; the main game.
   279 				;
   280 				; Also, the title graphics are now actual graphics instead of characters.
   281 				; The graphics mode uses the same sized pixels as the 1/4 character-sized 
   282 				; squares in the graphics character version, but now requires only half 
   283 				; the memory used for the character version while providing real, 
   284 				; complete color control.
   285 				; 
   286 				; Some small changes were made to the directions/documentation text on the
   287 				; title screen.  Each line has different luminance for the text providing 
   288 				; a gradient-like effect.  
   289 				;
   290 				; The credits line now fine scrolls and is visible perpetually, giving the
   291 				; appears the program is always multi-tasking (which is not a completely 
   292 				; truthful implication.)
   293 				;
   294 				; A big change to the main and game screens are the score lines and 
   295 				; lives/saved frog information is present on both screens.  The 
   296 				; text labels are now independently colored, and so can be made to 
   297 				; do a strobe effect which is used during the attract mode on the title 
   298 				; screen and during the game when a value changes.  The text has the 
   299 				; appearance that the text labels are ANTIC Mode 4 text, but this is not
   300 				; so.  The text lines are still ANTIC Mode 2 text lines, because I wanted 
   301 				; the extra precision to continue using the frog head graphics to count
   302 				; saved frogs.   
   303 				;
   304 				; So, then how is the text colored?  They are Player/Missile graphics that
   305 				; provide (up to) 10 characters for each text line.  DLIs had to be 
   306 				; revised again to slice these up on screen.  DLIs provide colors and 
   307 				; reposition the Player/Missile graphics between score lines, and then 
   308 				; afterwards update the Player/Missile information again to provide the 
   309 				; animated shapes on the Title, Game, and Game Over screens.  In effect, 
   310 				; there are potentially 12 Players/12 Missiles hiding in plain sight on 
   311 				; screen (though not all are used all the time.)
   312 				;
   313 				; The VBI basically runs almost the entire game -- the boats' fine and 
   314 				; coarse scrolling, animating the boat images, animating score label 
   315 				; colors, moving the frog player (or other animated objects), playing the 
   316 				; sound sequences, and running the credits line fine scrolling.  Just 
   317 				; about everything moving occurs during the VBI.
   318 				;
   319 				; The main code handles the player's joystick input.  It determines the 
   320 				; next location for the frog (and other animated objects), but does not
   321 				; actually move anything,  The Main code initiates changing screen modes, 
   322 				; and running the event loops and changing event stages.  This includes 
   323 				; the color animations on the three splash screens.  From a 6502 code 
   324 				; perspective, almost nothing is going on per frame in the main code.  
   325 				; Most of the time the main code is just waiting for the frame counter to 
   326 				; change.
   327 				;
   328 				; The main code for the game loop is now restructured as a legitimate jump 
   329 				; table based on the current event target ID.  This cut out miles of code 
   330 				; of silly event ID checking and may give others the impression the 
   331 				; programmer is somehow clever. 
   332 				; 
   333 				; --------------------------------------------------------------------------
   334
   335 				; ==========================================================================
   336 				; Ideas for Atari-specific version improvements, Version 01 and beyond!:
   337 				; * Remove all printing.  Replace with direct screen writes.  This will
   338 				;   be much faster. (IMPLEMENTED, V01)
   339 				; * Timing delay loops are imprecise.  Use the OS jiffy clock (frame
   340 				;   counter) to maintain timing, and while we're here make timing tables
   341 				;   for NTSC and PAL. (IMPLEMENTED, V01)  (PAL timing tables not 
   342 				;   actually in code, but discussed in the source.)  (V02 formalized this 
   343 				;   timing to using the Vertical Blank Interrupt service routine to 
   344 				;   manage activity frame by frame.)
   345 				; * Joystick controls.  I hate the keyboard.  The joystick is free and
   346 				;   easy on the Atari. (IMPLEMENTED, V02) 
   347 				; * Sound..  Some simple splats, plops, beeps, water sloshings.
   348 				;    (IMPLEMENTED, V02) 
   349 				; * Custom character set that looks more like beach, boats, water, and 
   350 				;   frog. (IMPLEMENTED, V02) 
   351 				; * Hardware coarse scrolling with LMS pointer updates rather than moving 
   352 				;   the boats in memory.  (IMPLEMENTED, V02) 
   353 				; * Improve boat, water, and beach visuals using multi-color, custom 
   354 				;   characters.  (IMPLEMENTED V03)
   355 				; * Horizontal Fine scrolling text to allow smoother movements for the 
   356 				;   boats. (IMPLEMENTED, V03) 
   357 				; * Player Missile Frog. This would make frog placement v the boat
   358 				;   positions easier when horizontal scrolling is in effect, not to 
   359 				;   mention extra color for the frog. (IMPLEMENTED, V03) 
   360 				; --------------------------------------------------------------------------
   361 				; Future Concepts:
   362 				; * Bigger boats (and fewer lines)?
   363 				; * Variable boat traffic?
   364 				; * Allow moving down.
   365 				; * Multi-player high scores, and saving to disk.
   366 				; * Simultaneous Two-Player mode?
   367 				; * Moving adversaries?
   368 				; --------------------------------------------------------------------------
   369 				; * Stir, rinse, repeat -- more extreme of all of the above: more color,
   370 				;   more DLI, more custom character sets, isometric perspective.
   371 				;   Game additions -- pursuing enemies, alternate boat shapes, lily pads,
   372 				;   bonus objects to collect, variable/changing boat speeds.  Heavy metal
   373 				;   chip tune soundtrack unrelated to frogs that has no good reason for
   374 				;   drowning out the game sound effects.  Boss battles.  Online multi-
   375 				;   player death matches.  Game Achievements.  In-game micro transaction
   376 				;   payments for upgrades and abilities.  Yeah, that's the ticket.
   377 				; --------------------------------------------------------------------------
   378
   379 				; ==========================================================================
   380 				; Atari System Includes (MADS assembler)
   381 					icl "ANTIC.asm" ; Display List registers
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/ANTIC.asm
     1 				;===============================================================================
     2 				; ANTIC register list
     3 				; For Mads assembler
     4 				; Ken Jennings
     5 				;===============================================================================
     6 				; Hardware Registers
     7 				;
     8 = D400			DMACTL = $D400 ; DMA control for display and Player/Missile graphics
     9 = D401			CHACTL = $D401 ; Character display control
    10 = D402			DLISTL = $D402 ; Display List Pointer (low)
    11 = D403			DLISTH = $D403 ; Display List Pointer (high)
    12 = D404			HSCROL = $D404 ; Horizontal Fine Scroll 0 to 16 color clocks.
    13 = D405			VSCROL = $D405 ; Vertical Fine Scroll 0 to 16 scanlines.
    14 = D407			PMBASE = $D407 ; Player/Missile Base Address (high) 
    15 = D409			CHBASE = $D409 ; Character Set Base Address (high)
    16 = D40A			WSYNC =  $D40A ; Wait for Horizontal Sync
    17 = D40B			VCOUNT = $D40B ; (Read) Vertical Scan Line Counter
    18 = D40C			PENH =   $D40C ; (Read) Light Pen Horizontal Position
    19 = D40D			PENV =   $D40D ; (Read) Light Pen Vertical Position
    20 = D40E			NMIEN =  $D40E ; Non-Maskable Interupt (NMI) Enable
    21 = D40F			NMIRES = $D40F ; Non-Maskable Interrupt (NMI) Reset
    22 = D40F			NMIST =  $D40F ; (Read) Non-Maskable Interrupt Status
    23 				;
    24 				;-------------------------------------------------------------------------------
    25 				; Shadow Registers for Hardware Registers
    26 				;
    27 = 022F			SDMCTL = $022F ; DMACTL
    28 = 0230			SDLSTL = $0230 ; DLISTL
    29 = 0231			SDLSTH = $0231 ; DLISTH
    30 				;
    31 = 02F4			CHBAS = $02F4 ; CHBASE
    32 = 02F3			CHART = $02F3 ; CHACTL
    33 				;
    34 = 0234			LPENH = $0234 ; (Read) PENH
    35 = 0235			LPENV = $0235 ; (Read) PENV
    36 				;
    37 				;-------------------------------------------------------------------------------
    38 				; Important Bit Positions
    39 				;
    40 				; DMACTL and SDMCTL - DMA control for display and Player/Missile graphics
    41 				;
    42 = 00DF			MASK_DL_DMA =          %11011111 ; Enable/Disable DMA to read the Display List
    43 = 00EF			MASK_PM_RESOLUTION =   %11101111 ; Set P/M graphics DMA to 1 or 2 scan line per update  
    44 = 00F3			MASK_PM_DMA =          %11110011 ; Enable/Disable DMA for Players/Missiles
    45 = 00FC			MASK_PLAYFIELD_WIDTH = %11111100 ; Enable playfield display/set playfield width
    46 				;
    47 				; DMACTL and SDMCTL - Enable/Disable DMA to read the Display List
    48 				;
    49 = 0020			ENABLE_DL_DMA =  %00100000
    50 = 0000			DISABLE_DL_DMA = %00000000  ; defining this is overkill
    51 				;
    52 				; DMACTL and SDMCTL - Set P/M graphics DMA to 1 or 2 scan line per update  
    53 				;
    54 = 0010			PM_1LINE_RESOLUTION = %00010000
    55 = 0000			PM_2LINE_RESOLUTION = %00000000
    56 				;
    57 				; DMACTL and SDMCTL - Enable DMA for Players/Missiles
    58 				;
    59 = 0008			ENABLE_PLAYER_DMA =  %00001000
    60 = 0004			ENABLE_MISSILE_DMA = %00000100
    61 = 000C			ENABLE_PM_DMA =      %00001100
    62 				;
    63 				; DMACTL and SDMCTL - Enable playfield display/set playfield width
    64 				;
    65 = 0000			PLAYFIELD_DISABLE =      %00000000 ; No width is the same as no display
    66 = 0001			PLAYFIELD_WIDTH_NARROW = %00000001 ; 32 characters/128 color clocks
    67 = 0002			PLAYFIELD_WIDTH_NORMAL = %00000010 ; 40 characters/160 color clocks
    68 = 0003			PLAYFIELD_WIDTH_WIDE =   %00000011 ; 48 characters/192 color clocks (176 visible)
    69 				;
    70 				; CHACTL - Character display control
    71 				;
    72 = 00FB			MASK_CHACTL_REFLECT = %11111011 ; Enable/Disable vertical reflect
    73 = 00FD			MASK_CHACTL_INVERSE = %11111101 ; Enable/Disable characters with high bit set displayed as inverse 
    74 = 00FE			MASK_CHACTL_BLANK =   %11111110 ; Enable/Disable characters with high bit set displayed as blank space
    75 				;
    76 				; CHACTL - Enable character display options
    77 				; 
    78 = 0004			CHACTL_REFLECT = %00000100 ; Enable vertical reflect
    79 = 0002			CHACTL_INVERSE = %00000010 ; Enable inverse display for characters with high bit set
    80 = 0001			CHACTL_BLANK =   %00000001 ; Enable blank display for characters with high bit set
    81 				;
    82 				; NMIEN (NMIRES and NMIST) - Non-Maskable Interupt (NMI) Reset and Status
    83 				;
    84 = 007F			MASK_NMI_DLI =   %01111111 ; Enable/Disable Display List Interrupts
    85 = 00BF			MASK_NMI_VBI =   %10111111 ; Enable/Disable Vertical Blank Interrupt
    86 = 00DF			MASK_NMI_RESET = %11011111 ; Enable/Disable Reset Key Interrupt
    87 				;
    88 				; NMIEN (NMIRES and NMIST) - Enable Non-Maskable Interupts
    89 				;
    90 = 0080			NMI_DLI =   %10000000 ; Enable Display List Interrupts
    91 = 0040			NMI_VBI =   %01000000 ; Enable Vertical Blank Interrupt
    92 = 0020			NMI_RESET = %00100000 ; Enable Reset Key Interrupt
    93 				;
    94 				;=================================================
    95 				; Display List Instructions/Options Mask
    96 				;
    97 = 007F			MASK_DL_DLI =     %01111111 ; Display List Interrupt on last scan line of graphics line
    98 = 00BF			MASK_DL_LMS =     %10111111 ; Reload Memory Scan address for this graphics line
    99 = 00DF			MASK_DL_VSCROLL = %11011111 ; Vertical scrolling for this graphics line
   100 = 00EF			MASK_DL_HSCROLL = %11101111 ; Horizontal scrolling for this graphics line
   101 = 00F0			MASK_DL_MODE =    %11110000 ; Text/Graphics Modes
   102 				;
   103 				; Display List Instruction Options
   104 				;
   105 = 0080			DL_DLI =     %10000000 ; Enable Display List Interrupt on last scan line of graphics line
   106 = 0040			DL_LMS =     %01000000 ; Enable Reload Memory Scan address for this graphics line
   107 = 0020			DL_VSCROLL = %00100000 ; Enable Vertical scrolling for this graphics line
   108 = 0010			DL_HSCROLL = %00010000 ; Enable Horizontal scrolling for this graphics line
   109 				;
   110 = 000F			DL_MODE =    %00001111 ; Collection of Text/Graphics Modes
   111 				;
   112 				; Display List Instructions, Jump 
   113 				;
   114 = 0001			DL_JUMP =    $01 ; Display List jump to new address
   115 = 0041			DL_JUMP_VB = $41 ; Display List jump to address and start Vertical Blank
   116 				;
   117 				; Display List Instructions, blank scan lines
   118 				; Note that bit $80 is not part of this, so the
   119 				; DL_DLI Instruction Option is available for 
   120 				; the blank line instructions.
   121 				;
   122 = 0000			DL_BLANK_1 = $00 ; 1 Blank Scan line
   123 = 0010			DL_BLANK_2 = $10 ; 2 Blank Scan lines
   124 = 0020			DL_BLANK_3 = $20 ; 3 Blank Scan lines
   125 = 0030			DL_BLANK_4 = $30 ; 4 Blank Scan lines
   126 = 0040			DL_BLANK_5 = $40 ; 5 Blank Scan lines
   127 = 0050			DL_BLANK_6 = $50 ; 6 Blank Scan lines
   128 = 0060			DL_BLANK_7 = $60 ; 7 Blank Scan lines
   129 = 0070			DL_BLANK_8 = $70 ; 8 Blank Scan lines
   130 				;
   131 				; Display List Instructions, Text Modes, specs for Normal width
   132 				;
   133 = 0002			DL_TEXT_2 = $02 ; 1.5 Color, 40 Columns X 8 Scan lines, 40 bytes/line
   134 = 0003			DL_TEXT_3 = $03 ; 1.5 Color, 40 Columns X 10 Scan lines, 40 bytes/line
   135 = 0004			DL_TEXT_4 = $04 ; 4/5 Color, 40 Columns X 8 Scan lines, 40 bytes/line
   136 = 0005			DL_TEXT_5 = $05 ; 4/5 Color, 40 Columns X 16 Scan lines, 40 bytes/line
   137 = 0006			DL_TEXT_6 = $06 ; 5 Color, 20 Columns X 8 Scan lines, 20 bytes/line
   138 = 0007			DL_TEXT_7 = $07 ; 5 Color, 20 Columns X 16 Scan lines, 20 bytes/line
   139 				;
   140 				; Display List Instructions, Map Modes
   141 				;
   142 = 0008			DL_MAP_8 = $08 ; 4 Color, 40 Pixels x 8 Scan Lines, 10 bytes/line
   143 = 0009			DL_MAP_9 = $09 ; 2 Color, 80 Pixels x 4 Scan Lines, 10 bytes/line
   144 = 000A			DL_MAP_A = $0A ; 4 Color, 80 Pixels x 4 Scan Lines, 20 bytes/line
   145 = 000B			DL_MAP_B = $0B ; 2 Color, 160 Pixels x 2 Scan Lines, 20 bytes/line
   146 = 000C			DL_MAP_C = $0C ; 2 Color, 160 Pixels x 1 Scan Lines, 20 bytes/line
   147 = 000D			DL_MAP_D = $0D ; 4 Color, 160 Pixels x 2 Scan Lines, 40 bytes/line
   148 = 000E			DL_MAP_E = $0E ; 4 Color, 160 Pixels x 1 Scan Lines, 40 bytes/line
   149 = 000F			DL_MAP_F = $0F ; 1.5 Color, 320 Pixels x 1 Scan Lines (and GTIA modes), 40 bytes/line
   150 				;
   151 				; Macros 
   152 				;
   153 				;-------------------------------------------------------------------------------
   154 				; 																	DL_LMS 
   155 				;-------------------------------------------------------------------------------
   156 				; mDL_LMS <DLmode>, <Address>
   157 				;
   158 				; Declares data for the provided display list instruction, adds the LMS 
   159 				; option, and then the supplied address in memory.
   160 				;
   161 				; Note that for validity checks it is only looking at the low nybble for
   162 				; the graphics mode, and then it simply ORs in the LMS option.
   163 				; This means the "mode" argument could include other options and
   164 				; even (redundantly) the LMS.
   165 				;-------------------------------------------------------------------------------
   166
   167 				.macro mDL_LMS  mode,screenMemory
   168 					.if :0<>2
   169 						.error "mDL_LMS: 2 arguments required, mode (value of low nybble $2 to $F), screen memory (address)."
   170 					.endif
   171 				
   172 					MDL_TEMP=:mode&$0F
   173 					.if MDL_TEMP<DL_TEXT_2
   174 						.error "mDL_LMS: mode argument must be a value from $2 to $F."
   175 					.endif
   176 				
   177 					; Byte for Mode plus LMS option.  And then the screen memory address.
   178 					.byte :mode|DL_LMS
   179 					.word :screenMemory   
   180 				.endm
   181
   182
   183 				;-------------------------------------------------------------------------------
   184 				; 																	DL_JMP
   185 				;-------------------------------------------------------------------------------
   186 				; mDL_JMP <Address>
   187 				;
   188 				; Declares a JMP DL instruction with the new Display List address in memory.
   189 				;
   190 				;-------------------------------------------------------------------------------
   191
   192 				.macro mDL_JMP  screenMemory
   193 					.if :0<>1
   194 						.error "mDL_JMP: 1 argument required, screen memory (address)."
   195 					.endif
   196 				
   197 					; Byte for JMP.  And then the screen memory address.
   198 					.byte DL_JUMP
   199 					.word :screenMemory   
   200 				.endm
   201
   202
   203 				;-------------------------------------------------------------------------------
   204 				; 																	DL_JVB
   205 				;-------------------------------------------------------------------------------
   206 				; mDL_JVB <Address>
   207 				;
   208 				; Declares a JVB DL instruction (Jump Vertical Blank) with the new 
   209 				; Display List address in memory.
   210 				;
   211 				;-------------------------------------------------------------------------------
   212
   213 				.macro mDL_JVB  dlMemory
   214 					.if :0<>1
   215 						.error "mDL_JVB: 1 argument required, display list memory (address)."
   216 					.endif
   217 				
   218 					; Byte for JVB.  And then the display list memory address.
   219 					.byte DL_JUMP_VB
   220 					.word :dlMemory   
   221 				.endm
   382 					icl "GTIA.asm"  ; Color Registers.
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/GTIA.asm
     1 				;=================================================
     2 				; GTIA register list
     3 				; For Mads assembler
     4 				; Ken Jennings
     5 				;=================================================
     6 				; Hardware Registers
     7 				;
     8 = D000			HPOSP0 = $D000 ; Player 0 Horizontal Position
     9 = D001			HPOSP1 = $D001 ; Player 1 Horizontal Position
    10 = D002			HPOSP2 = $D002 ; Player 2 Horizontal Position
    11 = D003			HPOSP3 = $D003 ; Player 3 Horizontal Position
    12 				;
    13 = D004			HPOSM0 = $D004 ; Missile 0 Horizontal Position
    14 = D005			HPOSM1 = $D005 ; Missile 1 Horizontal Position
    15 = D006			HPOSM2 = $D006 ; Missile 2 Horizontal Position
    16 = D007			HPOSM3 = $D007 ; Missile 3 Horizontal Position
    17 				;
    18 = D008			SIZEP0 = $D008 ; Player 0 Size
    19 = D009			SIZEP1 = $D009 ; Player 1 Size
    20 = D00A			SIZEP2 = $D00A ; Player 2 Size
    21 = D00B			SIZEP3 = $D00B ; Player 3 Size
    22 = D00C			SIZEM =  $D00C ; Missiles Sizes (2 bits per missile)
    23 				;
    24 = D00D			GRAFP0 = $D00D ; Player 0 Graphics Pattern
    25 = D00E			GRAFP1 = $D00E ; Player 1 Graphics Pattern
    26 = D00F			GRAFP2 = $D00F ; Player 2 Graphics Pattern
    27 = D010			GRAFP3 = $D010 ; Player 3 Graphics Pattern
    28 = D011			GRAFM =  $D011 ; Missile Graphics Pattern (2 bits per missile)
    29 				;
    30 = D000			M0PF = $D000 ; (Read) Missile 0 to Playfield collisions
    31 = D001			M1PF = $D001 ; (Read) Missile 1 to Playfield collisions
    32 = D002			M2PF = $D002 ; (Read) Missile 2 to Playfield collisions
    33 = D003			M3PF = $D003 ; (Read) Missile 3 to Playfield collisions
    34 				;
    35 = D004			P0PF = $D004 ; (Read) Player 0 to Playfield collisions
    36 = D005			P1PF = $D005 ; (Read) Player 1 to Playfield collisions
    37 = D006			P2PF = $D006 ; (Read) Player 2 to Playfield collisions
    38 = D007			P3PF = $D007 ; (Read) Player 3 to Playfield collisions
    39 				;
    40 = D008			M0PL = $D008 ; (Read) Missile 0 to Player collisions
    41 = D009			M1PL = $D009 ; (Read) Missile 1 to Player collisions
    42 = D00A			M2PL = $D00A ; (Read) Missile 2 to Player collisions
    43 = D00B			M3PL = $D00B ; (Read) Missile 3 to Player collisions
    44 				;
    45 = D00C			P0PL = $D00C ; (Read) Player 0 to Player collisions
    46 = D00D			P1PL = $D00D ; (Read) Player 1 to Player collisions
    47 = D00E			P2PL = $D00E ; (Read) Player 2 to Player collisions
    48 = D00F			P3PL = $D00F ; (Read) Player 3 to Player collisions
    49 				;
    50 = D012			COLPM0 = $D012 ; Player/Missile 0 color, GTIA 9-color playfield color 0 for Background
    51 = D013			COLPM1 = $D013 ; Player/Missile 1 color, GTIA 9-color playfield color 1
    52 = D014			COLPM2 = $D014 ; Player/Missile 2 color, GTIA 9-color playfield color 2
    53 = D015			COLPM3 = $D015 ; Player/Missile 3 color, GTIA 9-color playfield color 3
    54 				;
    55 = D016			COLPF0 = $D016 ; Playfield 0 color
    56 = D017			COLPF1 = $D017 ; Playfield 1 color
    57 = D018			COLPF2 = $D018 ; Playfield 2 color
    58 = D019			COLPF3 = $D019 ; Playfield 3 color (and fifth Player color)
    59 = D01A			COLBK =  $D01A ; Playfield Background color
    60 				;
    61 = D010			TRIG0 =  $D010 ; (Read) Joystick 0 trigger  (0 is pressed. 1 is not pressed)
    62 = D011			TRIG1 =  $D011 ; (Read) Joystick 1 trigger
    63 = D012			TRIG2 =  $D012 ; (Read) Joystick 2 trigger
    64 = D013			TRIG3 =  $D013 ; (Read) Joystick 3 trigger
    65 				;
    66 = D014			PAL =    $D014 ; (Read) PAL Flag
    67 = D01B			PRIOR =  $D01B ; Control Priority, Fifth Player and GTIA modes
    68 = D01C			VDELAY = $D01C ; Player Missile Vertical Delay
    69 = D01D			GRACTL = $D01D ; Graphics Control, P/M DMA and joystick trigger latches
    70 = D01E			HITCLR = $D01E ; Clear Player/Missile Collisions
    71 				;
    72 = D01F			CONSOL = $D01F ; (Read) Start, Select, Option console keys.
    73 = D01F			CONSPK = $D01F ; Console speaker.
    74 				;=================================================
    75 				; OS Shadow Registers for Hardware Registers
    76 				;
    77 = 0284			STRIG0 = $0284 ; (Read) TRIG0 - Joystick 0 trigger (0 is pressed. 1 is not pressed)
    78 = 0285			STRIG1 = $0285 ; (Read) TRIG1 - Joystick 1 trigger
    79 = 0286			STRIG2 = $0286 ; (Read) TRIG2 - Joystick 2 trigger
    80 = 0287			STRIG3 = $0287 ; (Read) TRIG3 - Joystick 3 trigger
    81 				;
    82 = 02C0			PCOLOR0 = $02C0 ; COLPM0 - Player/Missile 0 color, GTIA 9-color playfield color 0 for Background
    83 = 02C1			PCOLOR1 = $02C1 ; COLPM1 - Player/Missile 1 color, GTIA 9-color playfield color 1
    84 = 02C2			PCOLOR2 = $02C2 ; COLPM2 - Player/Missile 2 color, GTIA 9-color playfield color 2
    85 = 02C3			PCOLOR3 = $02C3 ; COLPM3 - Player/Missile 3 color, GTIA 9-color playfield color 3
    86 				;
    87 = 02C4			COLOR0 =  $02C4 ; COLPF0 - Playfield 0 color
    88 = 02C5			COLOR1 =  $02C5 ; COLPF1 - Playfield 1 color
    89 = 02C6			COLOR2 =  $02C6 ; COLPF2 - Playfield 2 color (Background for ANTIC modes 2, 3, and F)
    90 = 02C7			COLOR3 =  $02C7 ; COLPF3 - Playfield 3 color (and fifth Player color)
    91 = 02C8			COLOR4 =  $02C8 ; COLBK  - Playfield Background color (Border for modes 2, 3, and F)
    92 				;
    93 = 026F			GPRIOR = $026F ; PRIOR - Control Priority, Fifth Player and GTIA modes
    94 				;=================================================
    95 				; Important Bit Positions
    96 				;
    97 				; SIZEP0 - SIZEP3
    98 				;
    99 = 0003			PLAYER_SIZE_BITS = %00000011
   100 = 0000			PM_SIZE_NORMAL =   %00000000 ; One color clock per Player/Missile pixel
   101 = 0001			PM_SIZE_DOUBLE =   %00000001 ; Two color clocks per Player/Missile pixel
   102 = 0003			PM_SIZE_QUAD =     %00000011 ; Fopur color clocks per Player/Missile pixel
   103 				;
   104 				; SIZEM and GRAFM (and missile memory)
   105 				;
   106 = 00FC			MASK_MISSILE0_BITS = %11111100
   107 = 00F3			MASK_MISSILE1_BITS = %11110011
   108 = 00CF			MASK_MISSILE2_BITS = %11001111
   109 = 003F			MASK_MISSILE3_BITS = %00111111
   110 				;
   111 = 0003			MISSILE0_BITS =      %00000011
   112 = 000C			MISSILE1_BITS =      %00001100
   113 = 0030			MISSILE2_BITS =      %00110000
   114 = 00C0			MISSILE3_BITS =      %11000000
   115 				; 
   116 				; Collisions MxPF, MxPL, PxPF, PxPL
   117 				; COLPMx or COLPFx where X is bits 0 through 3
   118 				;
   119 = 00FE			MASK_COLPMF0_BIT = %11111110 ; Player or Missile v Player or Playfield color 0
   120 = 00FD			MASK_COLPMF1_BIT = %11111101 ; Player or Missile v Player or Playfield color 1
   121 = 00FB			MASK_COLPMF2_BIT = %11111011 ; Player or Missile v Player or Playfield color 2
   122 = 00F7			MASK_COLPMF3_BIT = %11110111 ; Player or Missile v Player or Playfield color 3
   123 				;
   124 = 0001			COLPMF0_BIT =      %00000001 ; Player or Missile v Player or Playfield color 0
   125 = 0002			COLPMF1_BIT =      %00000010 ; Player or Missile v Player or Playfield color 1
   126 = 0004			COLPMF2_BIT =      %00000100 ; Player or Missile v Player or Playfield color 2
   127 = 0008			COLPMF3_BIT =      %00001000 ; Player or Missile v Player or Playfield color 3
   128 				;
   129 				; Colors Registers
   130 				;
   131 = 00F0			COLOR_BITS = %11110000
   132 = 000F			LUMA_BITS =  %00001111
   133 				;
   134 				; PRIOR and GPRIOR - Control Priority, Fifth Player and GTIA modes
   135 				;
   136 = 00F0			MASK_PRIORITY =      %11110000 ; Player/Missile, Playfield priority
   137 = 00EF			MASK_FIFTH_PLAYER =  %11101111 ; Enable/Disable Fifth Player
   138 = 00DF			MASK_MULTICOLOR_PM = %11011111 ; Enable/Disable Player color mixing
   139 = 003F			MASK_GTIA_MODE =     %00111111 ; Enable/Disable GTIA playfield modes
   140 				;
   141 = 000F			PRIORITY_BITS =      %00001111 ; Player/Missile, Playfield priority
   142 = 0010			FIFTH_PLAYER =       %00010000 ; Enable Fifth Player
   143 = 0020			MULTICOLOR_PM =      %00100000 ; Enable Player color mixing
   144 				;
   145 = 0000			GTIA_MODE_DEFAULT =  %00000000 ; Normal CTIA color interpretation
   146 = 0040			GTIA_MODE_16_SHADE = %01000000 ; 16 shades of background color (COLBK)
   147 = 0080			GTIA_MODE_9_COLOR =  %10000000 ; 9 colors from registers, COLPM0 is background
   148 = 00C0			GTIA_MODE_16_COLOR = %11000000 ; 16 hues of brigntess of background color (COLBK)
   149 				;
   150 				; Player/Missile to Playfield priority values:
   151 				;
   152 				;+============+=========+=========+=========+=========+=========+
   153 				;| Priority   | 0 0 0 1 | 0 0 1 0 | 0 1 0 0 | 1 0 0 0 | 0 0 0 0 |
   154 				;| Bits [3:0] |  = $1   |  = $2   |  = $4   |  = $8   |  = $0*  |
   155 				;+============+=========+=========+=========+=========+=========+
   156 				;|        Top | PM0     | PM0     | P5/PF0  | P5/PF0  | PM0     |
   157 				;|            | PM1     | PM1     |    PF1  |    PF1  | PM1     |
   158 				;|            | PM2     | P5/PF0  |    PF2  | PM0     | P5/PF0  |
   159 				;|            | PM3     |    PF1  |    PF3  | PM1     |    PF1  |
   160 				;|            | P5/PF0  |    PF2  | PM0     | PM2     | PM2     |
   161 				;|            |    PF1  |    PF3  | PM1     | PM3     | PM3     |
   162 				;|            |    PF2  |  PM2    | PM2     |    PF2  |    PF2  |
   163 				;|            |    PF3  |  PM3    | PM3     |    PF3  |    PF3  |
   164 				;|     Bottom |  COLBK  |  COLBK  |  COLBK  |  COLBK  |  COLBK  |
   165 				;+============+=========+=========+=========+=========+=========+
   166 				;
   167 				; * $0 is Special: 
   168 				; Priority 0 results in color merging:
   169 				; PM0/PM1 + PF0/PF1 OR together to generate different colors.
   170 				; PM2/PM3 + PF2/PF3 OR together to generate different colors.
   171
   172 				;
   173 				; VDELAY - Delay PM DMA to render 2 scan line Player data one scan line lower 
   174 				;
   175 = 00FE			MASK_VD_MISSILE0 = %11111110
   176 = 00FD			MASK_VD_MISSILE1 = %11111101
   177 = 00FB			MASK_VD_MISSILE2 = %11111011
   178 = 00F7			MASK_VD_MISSILE3 = %11110111
   179 = 00EF			MASK_VD_PLAYER0 =  %11101111
   180 = 00DF			MASK_VD_PLAYER1 =  %11011111
   181 = 00BF			MASK_VD_PLAYER2 =  %10111111
   182 = 007F			MASK_VD_PLAYER3 =  %01111111
   183 				;
   184 = 0001			VD_MISSILE0 =      %00000001
   185 = 0002			VD_MISSILE1 =      %00000010
   186 = 0004			VD_MISSILE2 =      %00000100
   187 = 0008			VD_MISSILE3 =      %00001000
   188 = 0010			VD_PLAYER0 =       %00010000
   189 = 0020			VD_PLAYER1 =       %00100000
   190 = 0040			VD_PLAYER2 =       %01000000
   191 = 0080			VD_PLAYER3 =       %10000000
   192 				;
   193 				; GRACTL - Enable/Disable Player/Missile DMA to GRAFxx registers. And latch triggers.
   194 				;
   195 = 00FE			MASK_ENABLE_MISSILES = %11111110 ; Enable/Disable Missile DMA to GRAFM register
   196 = 00FD			MASK_ENABLE_PLAYERS =  %11111101 ; Enable/Disable Player DMA to GRAFPx registers
   197 = 00FB			MASK_TRIGGER_LATCH =   %11111011 ; Enable/Disable jostick trigger latching
   198 				;
   199 = 0001			ENABLE_MISSILES =      %00000001 ; Enable Missile DMA to GRAFM register
   200 = 0002			ENABLE_PLAYERS =       %00000010 ; Enable Player DMA to GRAFPx registers
   201 = 0004			TRIGGER_LATCH =        %00000100 ; Enable joystick trigger latching
   202 				;
   203 				; CONSOL and CONSPK
   204 				; 0 bit is key pressed, so AND "masking" is not really useful.
   205 				; Better to just AND with the single bit for each of the 3 keys.
   206 				;
   207 = 00F8			MASK_CONSOLE_KEYS =    %11111000
   208 = 00FE			MASK_CONSOLE_START =   %11111110 ; Start button
   209 = 00FD			MASK_CONSOLE_SELECT =  %11111101 ; Select button
   210 = 00FB			MASK_CONSOLE_OPTION =  %11111011 ; Option button
   211 = 00F7			MASK_CONSOLE_SPEAKER = %11110111 ; (Write) Keyboard speaker
   212 				;
   213 = 0007			CONSOLE_KEYS =         %00000111 ; Capture only the function keys.
   214 = 0001			CONSOLE_START =        %00000001 ; Start button
   215 = 0002			CONSOLE_SELECT =       %00000010 ; Select button
   216 = 0004			CONSOLE_OPTION =       %00000100 ; Option button
   217 = 0008			CONSOLE_SPEAKER =      %00001000 ; (Write) Keyboard speaker
   218
   219 				;=================================================
   220 				; Other Value Lists 
   221 				;
   222 				; Sizes in horizontal color clocks and vertical scan lines
   223 				;
   224 = 0080			PLAYFIELD_COLORCLOCKS_NARROW = $80 ; Color Clocks Narrow Width = 128
   225 = 00A0			PLAYFIELD_COLORCLOCKS_NORMAL = $A0 ; Color Clocks Normal Width = 160
   226 = 00B0			PLAYFIELD_COLORCLOCKS_WIDE =   $B0 ; Color Clocks Wide Width = 176
   227 				;
   228 = 0040			PLAYFIELD_LEFT_EDGE_NARROW = $40 ; First/left-most color clock horizontal position
   229 = 0030			PLAYFIELD_LEFT_EDGE_NORMAL = $30
   230 = 0028			PLAYFIELD_LEFT_EDGE_WIDE =   $28
   231 				;
   232 = 00BF			PLAYFIELD_RIGHT_EDGE_NARROW = $BF ; Last/right-most color clock horizontal position
   233 = 00CF			PLAYFIELD_RIGHT_EDGE_NORMAL = $CF
   234 = 00D7			PLAYFIELD_RIGHT_EDGE_WIDE =   $D7
   235 				;
   236 				; PMBASE offsets to Player or Missile addresses
   237 				;
   238 = 0180			PMADR_2LINE_MISSILES = $180 
   239 = 0200			PMADR_2LINE_PLAYER0 =  $200
   240 = 0280			PMADR_2LINE_PLAYER1 =  $280
   241 = 0300			PMADR_2LINE_PLAYER2 =  $300
   242 = 0380			PMADR_2LINE_PLAYER3 =  $380
   243 				;
   244 = 0300			PMADR_1LINE_MISSILES = $300
   245 = 0400			PMADR_1LINE_PLAYER0 =  $400
   246 = 0500			PMADR_1LINE_PLAYER1 =  $500
   247 = 0600			PMADR_1LINE_PLAYER2 =  $600
   248 = 0700			PMADR_1LINE_PLAYER3 =  $700
   249 				;
   250 				; Vertical Alignments - screen scanlines are offsets into PMADR memory locations
   251 				;
   252 = 0004			PM_2LINE_OVERSCAN_TOP =    $04
   253 = 0010			PM_2LINE_NORMAL_TOP =      $10 ; For default OS 192 scan line display
   254 = 006F			PM_2LINE_NORMAL_BOTTOM =   $6F ; For default OS 192 scan line display
   255 = 007B			PM_2LINE_OVERSCAN_BOTTOM = $7B
   256 				;
   257 = 0008			PM_1LINE_OVERSCAN_TOP =    $08
   258 = 0020			PM_1LINE_NORMAL_TOP =      $20 ; For default OS 192 scan line display
   259 = 00DF			PM_1LINE_NORMAL_BOTTOM =   $DF ; For default OS 192 scan line display
   260 = 00F7			PM_1LINE_OVERSCAN_BOTTOM = $F7
   261 				;
   262 				; Helpful Colors. (Sort of. Your TV mileage may vary.)
   263 				;
   264 = 0000			COLOR_GREY =         $00 ; From black to white - That averages to grey, right?
   265 				; Some also like to think of the first color value as black.
   266 = 0000			COLOR_BLACK =        $00
   267 				; White is the same color as black, just brighter.
   268 = 000F			COLOR_WHITE =        $0F
   269
   270 = 0010			COLOR_ORANGE1 =      $10
   271 = 0020			COLOR_ORANGE2 =      $20
   272 = 0030			COLOR_RED_ORANGE =   $30
   273 = 0040			COLOR_PINK =         $40
   274 = 0050			COLOR_PURPLE =       $50
   275 = 0060			COLOR_PURPLE_BLUE =  $60
   276 = 0070			COLOR_BLUE1 =        $70
   277 = 0080			COLOR_BLUE2 =        $80
   278 = 0090			COLOR_LITE_BLUE =    $90
   279 = 00A0			COLOR_AQUA =         $A0
   280 = 00B0			COLOR_BLUE_GREEN =   $B0
   281 = 00C0			COLOR_GREEN =        $C0
   282 = 00D0			COLOR_YELLOW_GREEN = $D0
   283 = 00E0			COLOR_ORANGE_GREEN = $E0
   284 = 00F0			COLOR_LITE_ORANGE =  $F0
   285
   383 					icl "POKEY.asm" ;
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/POKEY.asm
     1 				;=================================================
     2 				; POKEY register list
     3 				; For Mads assembler
     4 				; Ken Jennings
     5 				;=================================================
     6 				; Hardware Registers
     7 				;
     8 = D200			AUDF1 = $D200 ; Audio channel 1 Frequency
     9 = D202			AUDF2 = $D202 ; Audio channel 2 Frequency
    10 = D204			AUDF3 = $D204 ; Audio channel 3 Frequency
    11 = D206			AUDF4 = $D206 ; Audio channel 4 Frequency
    12 				;
    13 = D201			AUDC1 = $D201 ; Audio channel 1 Control
    14 = D203			AUDC2 = $D203 ; Audio channel 2 Control
    15 = D205			AUDC3 = $D205 ; Audio channel 3 Control
    16 = D207			AUDC4 = $D207 ; Audio channel 4 Control
    17 				;
    18 = D208			AUDCTL = $D208 ; Audio Control
    19 				;
    20 = D200			POT0 = $D200 ; (Read) Potentiometer (paddle) 0 
    21 = D201			POT1 = $D201 ; (Read) Potentiometer (paddle) 1 
    22 = D202			POT2 = $D202 ; (Read) Potentiometer (paddle) 2 
    23 = D203			POT3 = $D203 ; (Read) Potentiometer (paddle) 3 
    24 = D204			POT4 = $D204 ; (Read) Potentiometer (paddle) 4 
    25 = D205			POT5 = $D205 ; (Read) Potentiometer (paddle) 5 
    26 = D206			POT6 = $D206 ; (Read) Potentiometer (paddle) 6 
    27 = D207			POT7 = $D207 ; (Read) Potentiometer (paddle) 7 
    28 				;
    29 = D208			ALLPOT = $D208 ; (Read) Read 8 line POT port state
    30 = D20B			POTGO =  $D20B ; Start the POT scan sequence
    31 				;
    32 = D209			STIMER = $D209 ; Start timers
    33 = D209			KBCODE = $D209 ; (Read) Keyboard code
    34 = D20A			RANDOM = $D20A ; (Read) Random number
    35 				;
    36 = D20A			SKREST = $D20A ; Reset Serial Status (SKSTAT)
    37 = D20D			SEROUT = $D20D ; Serial port data output
    38 = D20D			SERIN =  $D20D ; (Read) Serial port data input
    39 = D20F			SKCTL =  $D20F ; Serial Port Control
    40 = D20F			SKSTAT = $D20F ; (Read) Serial port status
    41 				;
    42 = D20E			IRQEN = $D20E ; Interrupt Request Enable
    43 = D20E			IRQST = $D20E ; (Read) IRQ Status
    44 				;=================================================
    45 				; Shadow Registers for Hardware Registers
    46 				;
    47 = 0270			PADDL0 = $0270 ; POT0
    48 = 0270			PADDL1 = $0270 ; POT1
    49 = 0270			PADDL2 = $0270 ; POT2
    50 = 0270			PADDL3 = $0270 ; POT3
    51 = 0270			PADDL4 = $0270 ; POT4
    52 = 0270			PADDL5 = $0270 ; POT5
    53 = 0270			PADDL6 = $0270 ; POT6
    54 = 0270			PADDL7 = $0270 ; POT7
    55 				;
    56 = 02FC			CH = $02FC ; KBCODE
    57 				;
    58 = 0010			POKMSK = $10 ; IRQEN
    59 				;
    60 = 0232			SSKCTL = $0232 ; SKCTL
    61 				;=================================================
    62 				; Important Bit Positions
    63 				;
    64 				; AUDC 
    65 = 001F			MASK_AUD_NOISE  = %00011111
    66 = 00EF			MASK_AUD_FORCE  = %11101111
    67 = 00F0			MASK_AUD_VOLUME = %11110000
    68 				;
    69 = 00E0			AUD_NOISE =       %11100000
    70 = 0010			AUD_FORCE =       %00010000
    71 = 000F			AUD_VOLUME =      %00001111
    72 				;
    73 = 0000			NOISE_5_BIT_17_BIT_POLY = %00000000
    74 = 0020			NOISE_5_BIT_POLY =        %00100000
    75 = 0040			NOISE_5_BIT_4_BIT_POLY =  %01000000
    76 = 0060			NOISE_5_BIT_POLY_2 =      %01100000 ; Duplicate of "5 bit poly"
    77 = 0080			NOISE_17_BIT_POLY =       %10000000
    78 = 00A0			NOISE_NO_POLY_PURE =      %10100000
    79 = 00C0			NOISE_4_BIT_POLY =        %11000000
    80 = 00E0			NOISE_NO_POLY_PURE_2 =    %11100000 ; Duplicate of "No poly pure"
    81 				;
    82 				;AUDCTL
    83 = 007F			MASK_AUDCTL_POLY    =     %01111111 ; 17 or 9 bit poly
    84 = 00BF			MASK_AUDCTL_CH1_SYS =     %10111111 ; Channel 1, 64KHz or system CPU clock (1.79Mhz NTSC)
    85 = 00DF			MASK_AUDCTL_CH3_SYS =     %11011111 ; Channel 3, 64KHz or system CPU clock (1.79Mhz NTSC)
    86 = 00EF			MASK_AUDCTL_16_BIT_2_1 =  %11101111 ; Tie channels 2 and 1 for 16-bit resolution
    87 = 00F7			MASK_AUDCTL_16_BIT_4_3 =  %11110111 ; Tie channels 4 and 3 for 16-bit resolution
    88 = 00FB			MASK_AUDCTL_HIPASS_1_3 =  %11111011 ; High pass filter channel 1 by channel 3
    89 = 00FD			MASK_AUDCTL_HIPASS_2_4 =  %11111101 ; High pass filter channel 2 by channel 4
    90 = 00FE			MASK_AUDCTL_64_OR_15KHZ = %11111110 ; Use Clock 64Khz or 15Khz
    91 				;
    92 = 0000			AUDCTL_POLY_17 =        %00000000
    93 = 0080			AUDCTL_POLY_9  =        %10000000
    94 = 0000			AUDCTL_CH1_64  =        %00000000
    95 = 0040			AUDCTL_CH1_SYS =        %01000000
    96 = 0000			AUDCTL_CH3_64  =        %00000000
    97 = 0020			AUDCTL_CH3_SYS =        %00100000
    98 = 0000			AUDCTL_16_BIT_2_1_OFF = %00000000
    99 = 0010			AUDCTL_16_BIT_2_1_ON =  %00010000
   100 = 0000			AUDCTL_16_BIT_4_3_OFF = %00000000
   101 = 0008			AUDCTL_16_BIT_4_3_ON =  %00001000
   102 = 0000			AUDCTL_HIPASS_1_3_OFF = %00000000
   103 = 0004			AUDCTL_HIPASS_1_3_ON =  %00000100
   104 = 0000			AUDCTL_HIPASS_2_4_OFF = %00000000
   105 = 0002			AUDCTL_HIPASS_2_4_ON =  %00000010
   106 = 0000			AUDCTL_CLOCK_64KHZ =    %00000000
   107 = 0001			AUDCTL_CLOCK_15KHZ =    %00000001
   108 				;
   109 				;ALLPOT
   110 = 007F			MASK_ALLPOT_PADDLE7 = %01111111
   111 = 00BF			MASK_ALLPOT_PADDLE6 = %10111111
   112 = 00DF			MASK_ALLPOT_PADDLE5 = %11011111
   113 = 00EF			MASK_ALLPOT_PADDLE4 = %11101111
   114 = 00F7			MASK_ALLPOT_PADDLE3 = %11110111
   115 = 00FB			MASK_ALLPOT_PADDLE2 = %11111011
   116 = 00FD			MASK_ALLPOT_PADDLE1 = %11111101
   117 = 00FE			MASK_ALLPOT_PADDLE0 = %11111110
   118 				;
   119 = 0080			ALLPOT_PADDLE7 = %10000000
   120 = 0040			ALLPOT_PADDLE6 = %01000000
   121 = 0020			ALLPOT_PADDLE5 = %00100000
   122 = 0010			ALLPOT_PADDLE4 = %00010000
   123 = 0008			ALLPOT_PADDLE3 = %00001000
   124 = 0004			ALLPOT_PADDLE2 = %00000100
   125 = 0002			ALLPOT_PADDLE1 = %00000010
   126 = 0001			ALLPOT_PADDLE0 = %00000001
   127 				;
   128 				;SKCTL
   129 = 007F			MASK_SERIAL_BREAK =   %01111111
   130 = 008F			MASK_SERIAL_MODE =    %10001111
   131 = 00F7			MASK_SERIAL_2TONE =   %11110111
   132 = 00FB			MASK_FAST_POT_SCAN =  %11111011
   133 = 00FD			MASK_ENABLE_KB_SCAN = %11111101
   134 = 00FE			MASK_KB_DEBOUNCE =    %11111110
   135 				;
   136 = 0080			SERIAL_BREAK = %10000000
   137 = 0000			SERIAL_MODE0 = %00000000 ; Input Clock External.            Output Clock External.          Bidirectional Clock Input.
   138 = 0010			SERIAL_MODE1 = %00010000 ; Input Clock Channel 3+4 (async). Output Clock External.          Bidirectional Clock Input.
   139 = 0020			SERIAL_MODE2 = %00100000 ; Input Clock Channel 4.           Output Clock Channel 4.         Bidirectional Clock Output Channel 4.
   140 = 0030			SERIAL_MODE3 = %00110000 ; Input Clock Channel 3+4 (async). Output Clock Channel 4 (async). Bidirectional Clock Input.
   141 = 0040			SERIAL_MODE4 = %01000000 ; Input Clock External.            Output Clock Channel 4.         Bidirectional Clock Input.
   142 = 0050			SERIAL_MODE5 = %01010000 ; Input Clock Channel 3+4 (async). Output Clock Channel 4 (async). Bidirectional Clock Input.
   143 = 0060			SERIAL_MODE6 = %01100000 ; Input Clock Channel 4.           Output Clock Channel 2.         Bidirectional Clock Output Channel 4.
   144 = 0070			SERIAL_MODE7 = %01110000 ; Input Clock Channel 3+4 (async). Output Clock Channel 2.         Bidirectional Clock Input.
   145 				;
   146 = 0008			SERIAL_2TONE = %00001000 ; 1 and 0 bits are audio set by timers 1 and 2
   147 				;
   148 = 0000			FAST_POT_SCAN_OFF = %00000000
   149 = 0004			FAST_POT_SCAN_ON =  %00000100
   150 = 0000			DISABLE_KB_SCAN =   %00000000
   151 = 0002			ENABLE_KB_SCAN =    %00000010
   152 = 0000			KB_DEBOUNCE_OFF =   %00000000
   153 = 0001			KB_DEBOUNCE_ON =    %00000001
   154 				;
   155 				;SKSTAT
   156 = 007F			MASK_SERIAL_FRAME_ERROR =   %01111111
   157 = 00BF			MASK_SERIAL_INPUT_OVERRUN = %10111111
   158 = 00DF			MASK_KEYBOARD_OVERRUN =     %11011111
   159 = 00EF			MASK_SERIAL_DATA_READY =    %11101111
   160 = 00F7			MASK_SHIFT_KEY_PRESSED =    %11110111
   161 = 00FB			MASK_LAST_KEY_HELD =        %11111011
   162 = 00FD			MASK_SERIAL_INPUT_BUSY =    %11111101
   163 				;
   164 = 0000			SERIAL_FRAME_NO_ERROR =   %00000000
   165 = 0080			SERIAL_FRAME_ERROR =      %10000000
   166 = 0000			SERIAL_NO_INPUT_OVERRUN = %00000000
   167 = 0040			SERIAL_INPUT_OVERRUN =    %01000000
   168 = 0000			KEYBOARD_NO_OVERRUN =     %00000000
   169 = 0020			KEYBOARD_OVERRUN =        %00100000
   170 = 0000			SERIAL_DATA_NOT_READY =   %00000000
   171 = 0010			SERIAL_DATA_READY =       %00010000
   172 = 0000			SHIFT_KEY_NOT_PRESSED =   %00000000
   173 = 0008			SHIFT_KEY_PRESSED =       %00001000
   174 = 0000			LAST_KEY_NOT_HELD =       %00000000
   175 = 0004			LAST_KEY_HELD =           %00000100
   176 = 0000			SERIAL_INPUT_NOT_BUSY =   %00000000
   177 = 0002			SERIAL_INPUT_BUSY =       %00000010
   178 				;
   179 				;IRQEN and IRQST
   180 = 00FE			MASK_IRQ_TIMER1 =           %11111110
   181 = 00FD			MASK_IRQ_TIMER2 =           %11111101
   182 = 00FB			MASK_IRQ_TIMER4 =           %11111011
   183 = 00F7			MASK_IRQ_SERIAL_OUT_DONE =  %11110111
   184 = 00EF			MASK_IRQ_SERIAL_OUT_READY = %11101111
   185 = 00DF			MASK_IRQ_SERIAL_IN_READY =  %11011111
   186 = 00BF			MASK_IRQ_NORMAL_KEY_PRESS = %10111111
   187 = 007F			MASK_IRQ_BREAK_PRESSED =    %01111111
   188 				;
   189 = 0000			IRQ_TIMER1_OFF =           %00000000
   190 = 0001			IRQ_TIMER1_ON =            %00000001
   191 = 0000			IRQ_TIMER2_OFF =           %00000000
   192 = 0002			IRQ_TIMER2_ON =            %00000010
   193 = 0000			IRQ_TIMER4_OFF =           %00000000
   194 = 0004			IRQ_TIMER4_ON =            %00000100
   195 = 0000			IRQ_SERIAL_OUT_NOT_DONE =  %00000000
   196 = 0008			IRQ_SERIAL_OUT_DONE =      %00001000
   197 = 0000			IRQ_SERIAL_OUT_NOT_READY = %00000000
   198 = 0010			IRQ_SERIAL_OUT_READY =     %00010000
   199 = 0000			IRQ_SERIAL_IN_NOT_READY =  %00000000
   200 = 0020			IRQ_SERIAL_IN_READY =      %00100000
   201 = 0000			IRQ_NO_KEY_PRESS =         %00000000
   202 = 0040			IRQ_NORMAL_KEY_PRESS =     %01000000
   203 = 0000			IRQ_BREAK_NOT_PRESSED =    %00000000
   204 = 0080			IRQ_BREAK_PRESSED =        %10000000
   205
   384 					icl "PIA.asm"   ; Controllers
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/PIA.asm
     1 				;=================================================
     2 				; PIA register list
     3 				; for atasm
     4 				; Ken Jennings
     5 				;=================================================
     6 				; Hardware Registers
     7 				;
     8 = D300			PORTA = $D300 ; Joystick ports 1 and 2, STICK0 and STICK1
     9 = D301			PORTB = $D301 ; Joystick ports 3 and 4, STICK2 and STICK3
    10 = D302			PACTL = $D302 ; Port A Control
    11 = D303			PBCTL = $D303 ; Port B Control
    12 				;=================================================
    13 				; Shadow Registers for Hardware Registers
    14 				;
    15 = 0278			STICK0 = $0278
    16 = 0279			STICK1 = $0279
    17 = 027A			STICK2 = $027A
    18 = 027B			STICK3 = $027B
    19 				;
    20 = 027C			PTRIG0 = $027C
    21 = 027D			PTRIG1 = $027D
    22 = 027E			PTRIG2 = $027E
    23 = 027F			PTRIG3 = $027F
    24 = 0280			PTRIG4 = $0280
    25 = 0281			PTRIG5 = $0281
    26 = 0282			PTRIG6 = $0282
    27 = 0283			PTRIG7 = $0283
    28 				;=================================================
    29 				; Important Bit Positions
    30 				;
    31 				; MASK_JACK is about referencing the actual hardware registers.
    32 				; You can do this if you want to, however the OS already separates 
    33 				; the joysticks into individual OS register value (STICKx), so
    34 				; there's not a lot of reason to read the joystick 
    35 				; hardware directly.
    36 = 000F			MASK_JACK_1 = %00001111 ; Actually the anti-mask.  Keeps bits from first controller in pair.
    37 = 00F0			MASK_JACK_2 = %11110000 ; The inverse of mask.  Keeps bits from second controller in pair.
    38 = 000F			MASK_JACK_3 = %00001111 ; Actually the anti-mask.  Keeps bits from first controller in pair.
    39 = 00F0			MASK_JACK_4 = %11110000 ; The inverse of mask.  Keeps bits from second controller in pair.
    40 				;
    41 				; Note that 0 bit is pressed.  1 bit is not pressed.
    42 				; Reading "JACK" registers gives two joystick values.  
    43 				; The Joystick's bits in the high nybble should be right shifted 
    44 				; into the low nybble for testing.
    45 				; Or just use the STICKx shadow register as that is its purpose.  
    46 				; Bits for STICKx shadow regs below:
    47 = 00F7			MASK_STICK_RIGHT = %11110111
    48 = 00FB			MASK_STICK_LEFT =  %11111011
    49 = 00FD			MASK_SITCK_UP =    %11111101
    50 = 00FE			MASK_STICK_DOWN =  %11111110
    51 				;
    52 = 0008			STICK_RIGHT = %00001000 ; AND with STICKx. If 0, then pressed. If 1, then not pressed.
    53 = 0004			STICK_LEFT =  %00000100
    54 = 0002			SITCK_UP =    %00000010
    55 = 0001			STICK_DOWN =  %00000001
    56 				;
    57 				; PACTL and PBCTL
    58 = 007F			MASK_PORT_SERIAL_IRQ =   %01111111 ; (Read)
    59 = 00F7			MASK_MOTOR_CONTROL =     %11110111 ; PACTL Peripheral motor control (cassette)
    60 = 00F7			MASK_COMMAND_IDENT =     %11110111 ; PBCTL Peripheral command identification
    61 = 00FB			MASK_PORT_ADDRESSING =   %11111011 ; PACTL 0 = Port direction control. 1 = Read port.
    62 = 00FE			MASK_SERIAL_IRQ_ENABLE = %11111110
    63 				;
    64 = 0080			PORT_SERIAL_IRQ =   %10000000 ; (Read)
    65 = 0008			MOTOR_CONTROL =     %00001000 ; PACTL
    66 = 0008			COMMAND_IDENT =     %00001000 ; PBCTL
    67 = 0004			PORT_ADDRESSING =   %00000100
    68 = 0001			SERIAL_IRQ_ENABLE = %00000001
    69 				;
    70 				; PBCTL for the XL
    71 = 00FE			MASK_SELECT_OS_ROM =      %11111110 ; Turn OS ROM on and off
    72 = 00FD			MASK_SELECT_BASIC_ROM =   %11111101 ; Turn BASIC ROM on and off
    73 = 00FB			MASK_LED_1_KEYBOARD =     %11111011 ; 1200XL LED 1, enable/disable keyboard
    74 = 00F7			MASK_LED_2_INTL_CHARSET = %11110111 ; 1200XL LED 2, enable international character set
    75 = 007F			MASK_SELF_TEST_ROM =      %01111111 ; Expose Self Test at $5000
    76 				;
    77 = 0001			SELECT_OS_ROM =      %00000001
    78 = 0002			SELECT_BASIC_ROM =   %00000010
    79 = 0004			LED_1_KEYBOARD =     %00000100
    80 = 0008			LED_2_INTL_CHARSET = %00001000
    81 = 0080			SELF_TEST_ROM =      %10000000
    82
   385 					icl "OS.asm"    ;
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/OS.asm
     1 				;=================================================
     2 				; OS memory and vectors
     3 				; For Mads assembler
     4 				; Ken Jennings
     5 				;=================================================
     6
     7 				;=================================================
     8 				; Use the ANTIC/GTIA/POKEY/PIA files for shadow
     9 				; register declarations.
    10 				;=================================================
    11
    12 				;=================================================
    13 				; Most of the first half of Page Zero is claimed
    14 				; by the OS.  The second half is for the cartridge
    15 				; ROM, with part used for the Floating point 
    16 				; package.
    17 				;
    18 				; If a cartridge is not inserted then the Page Zero
    19 				; space for the cartridge is available for any 
    20 				; machine language program.   
    21 				;
    22 				; Likewise, if the floating-point package will not 
    23 				; be used then the FP registers and working area 
    24 				; can be treated as free for use by a machine 
    25 				; language program.
    26 				;=================================================
    27
    28 				;=================================================
    29 				; OS and Cartridge Page 0
    30 				;=================================================
    31 = 0000			LINZBS = $00 ; word
    32
    33 = 0002			CASINI = $02 ; word, Cassette initialization vector (and trap RESET. See $09).
    34 = 0004			RAMLO =  $04 ; word, power up memory test.  Disk boot address.
    35
    36 = 0006			CTAFLG = $06 ; nonzero value means Left/A cartridge present
    37 = 0007			CTBFLG = $07 ; nonzero value means Right/B  cartridge present
    38
    39 = 0008			WARMST = $08 ; Warmstart flag. 0 = powerup in progress. $FF normal reset occurred.
    40 = 0009			BOOT =   $09 ; Boot status. 0 = no boot.  
    41 					; 1 = disk boot OK.  do reset via DOSVEC
    42 					; 2 = cassette boot OK. do reset via CASINI
    43 					; 3 = both successful. (trap reset via CASINI).
    44
    45 = 000A			DOSVEC = $0A ; word. Entry vector for DOS (actually to start DUP.SYS).
    46 = 000C			DOSINI = $0C ; word. Init address for DOS or Cassette RUN address. (also trap RESET with this).
    47
    48 = 000E			APPMHI = $0E ; word. Application high memory in use.
    49
    50 				; POKMSK = $10 in POKEY.asm
    51
    52 = 0011			BRKKEY = $11 ; 0 = Break pressed.  
    53
    54 				; Real Time Clock incremented during the vertical blank.
    55 				; This is three addresses $12, $13, and $14.
    56 				; The value of $14 is incremented  every vertical blank.
    57 				; When the value of $14 reaches $FF on the next increment it rolls 
    58 				; over to $00 and then the value of $13 increments.
    59 				; $14 rollover/$13 increment occurs approximately every 4.27 seconds.
    60 				; Likewise, when the value if $13 reaches $FF and it rolls 
    61 				; over to $00,then the value of $12 increments.
    62 				; $13 rollover/$12 increment occurs approximately every 18.2 minutes.
    63 				; Jiffy count / 59.92334 for seconds.
    64 = 0012			RTCLOK =   $12 ; and $13, and $14.  
    65 = 0014			RTCLOK60 = $14 ; incremented every jiffy/frame.
    66
    67 = 0015			BUFADR = $15 ; word.  temporary address of disk buffer
    68 = 0017			ICCOMT = $17 ; CIO command.
    69 = 0018			DSKFMS = $18 ; word. File Management System vector.
    70 = 001A			DSKUTL = $1A ; word. Disk Utilities pointer.
    71
    72 = 001C			PTIMOT = $1C ; printer timeout.  approx 64 second per 60 values.
    73 = 001D			PBPNT =  $1D ; Printer buffer pointer.  index into buffer.
    74 = 001E			PBUFSZ = $1E ; Printer buffer size.
    75 = 001F			PTEMP =  $1F ; Temporary printer value used by print handler.
    76
    77 				; Zero Page copy of CIO's IOCB
    78 = 0020			ICHIDZ = $20 ; Handler Index
    79 = 0021			ICDNOZ = $21 ; Device or drive number
    80 = 0022			ICCOMZ = $22 ; Command
    81 = 0023			ICSTAZ = $23 ; IOCB status result
    82 = 0024			ICBALZ = $24 ; Buffer address (lo byte)
    83 = 0025			ICBAHZ = $25 ; Buffer address (hi byte)
    84 = 0026			ICPTLZ = $26 ; Put Byte rouotine address (lo byte)
    85 = 0027			ICPTHZ = $27 ; Put Byte rouotine address (hi byte)
    86 = 0028			ICBLLZ = $28 ; Buffer length (lo byte)
    87 = 0029			ICBLHZ = $29 ; Buffer length (hi byte)
    88 = 002A			ICAX1Z = $2A ; Aux byte 1 (open parameters)
    89 = 002B			ICAX2Z = $2B ; Aux byte 2
    90 = 002C			ICAX3Z = $2C ; Aux byte 3 (BASIC Note/Point)
    91 = 002D			ICAX4Z = $2D ; Aux byte 4 (BASIC Note/Point)
    92 = 002E			ICAX5Z = $2E ; Aux byte 5
    93 = 002F			ICAX6Z = $2F ; Aux byte 6
    94
    95 = 0030			STATUS = $30 ; SIO status
    96 = 0031			CHKSUM = $31 ; SIO data frame checksum.
    97
    98 = 0032			BUFRLO = $32 ; SIO and DCB address of data to send or receive (lo byte)
    99 = 0033			BUFRHI = $33 ; SIO and DCB address of data to send or receive (hi byte)
   100 = 0034			BFENLO = $34 ; SIO and DCB address after BUFRLO/BUFRHI  (lo byte)
   101 = 0035			BFENHI = $35 ; SIO and DCB address after BUFRLO/BUFRHI  (hi byte)
   102
   103 = 0036			CRETRY = $36 ; Command frame retries.  Usually $0D.
   104 = 0037			DRETRY = $37 ; Device retries.  Usually $01.
   105
   106 = 0038			BUFRFL = $38 ; Flag buffer full. $FF is full.
   107 = 0039			RECVDN = $39 ; Flag receive done. $FF is done.
   108 = 003A			XMTDON = $3A ; Flag transmit done. $FF is done.
   109 = 003B			CHKSNT = $3B ; Flag checksum sent. $FF is sent. $00 is not sent.
   110 = 003C			NOCKSM = $3C ; Flag $00 = checksum follows data.  not zero = no checksum.
   111
   112 = 003D			BPTR =   $3D ; Index to data in cassette buffer. 
   113 = 003E			FTYPE =  $3E ; Gap between cassette blocks. $01 to $7F = normal. $80 to $00 = short gaps.
   114 = 003F			FEOF =   $3F ; EOF for cassette. $00 = No EOF.  !$00 = EOF detected.
   115 = 0040			FREQ =   $40 ; Number of beeps for cassette start.  1 = Play.  2 = Record.
   116 = 0041			SOUNDR = $41 ; Play I/O sounds to speaker. 0 = silence.  !0 = I/O sound.
   117
   118 				; Critical I/O flag.  
   119 				; Set to stop some automated timers and updates.
   120 				;  $00 = Normal behavior. 
   121 				; !$00 = Critical I/O mode.
   122 				; When CRITIC is set (non-zero) the following activities change:
   123 				; Stage 2/Deferred Vertical Blank Interrupt STOPS.
   124 				; (Stage 1/Immediate Vertical Blank Interrupt continues.)
   125 				; Software Timers 2, 3, 4, and 5 stop.
   126 				; Keyboard repeat disabled.
   127 = 0042			CRITIC = $42 ;  
   128
   129 = 0043			FMZSPG = $43 ; 7 bytes up to $49. Disk FMS page 0 temporary registers (below)
   130 = 0043			ZBUFP =  $43 ; word.  Pointer to filename.
   131 = 0045			ZDRVA =  $45 ; word. Drive pointer/sector temporary value.
   132 = 0047			ZSBA =   $47 ; word. temporary sector pointer.
   133 = 0049			ERRNO =  $49 ; Disk I/O error.  FMS initializes to $9F.
   134
   135 = 004A			CKEY =   $4A ; Cassette Cold Start to boot cassette.  Set by holding START key.
   136 = 004B			CASSBT = $4B ; Flag Cassette Boot. 0 = cassette boot unsuccessful.
   137
   138 = 004C			DSTAT =  $4C ; status from S: handler. 
   139
   140 				; Atari's "Attract" mode.
   141 				; After no keyboard input for several minutes the Atari OS cycles the 
   142 				; colors to prevent CRT image burn-in.  Reset this to 0 periodically
   143 				; to prevent the OS engaging the attract mode.
   144 = 004D			ATRACT = $4D
   145
   146 				; Dark attract mask. Set to $FE/254 when attract mode is not active.
   147 				; Set to $F6/246 when attract mode is active.  This masks the 
   148 				; color lunminance bits to make screen colors stay below 50% 
   149 				; brighness. 
   150 = 004E			DRKMSK = $4E
   151
   152 				; Color shift mask When attract mode is on the color registers are
   153 				; exclusive-OR's with the values in $4e and $4f  during the OS's 
   154 				; stage two vertical blank interrupt.  (see RTCLOK)
   155 				; When set to zero and value of DRKMSK is $f6/246, the luminance 
   156 				; is reduced 50%. COLRSH contains the value of RTCLOK+1 which is 
   157 				; incremented approximately each 4.27 seconds causing the colors
   158 				; to cycle at that period of time.       
   159 = 004F			COLRSH = $4F
   160
   161 = 0050			TEMP =   $50 ; S: temporary value. (write character to screen)
   162 = 0051			HOLD1 =  $51 ; S: temporary value. (lines for Display List)
   163
   164 = 0052			LMARGN = $52 ; E: left margin of GR.0 text mode and text windows
   165 = 0053			RMARGN = $53 ; E: right margin of GR.0 text mode and text windows
   166 = 0054			ROWCRS = $54 ; S: current cursor row (Y) 
   167 = 0055			COLCRS = $55 ; word.  S: current cursor column (X)
   168
   169 = 0057			DINDEX = $57 ; S: current screen text/graphics mode
   170 = 0058			SAVMSC = $58 ; word. Address of first byte of screen memory.
   171
   172 = 005A			OLDROW = $5A ; Previous cursor row from $54. Used for Drawto and Fill
   173 = 005B			OLDCOL = $5B ; word. Previous cursor column from $55/$56. Used for Drawto and Fill
   174 = 005D			OLDCHR = $5D ; Prior value of character at cursor
   175 = 005E			OLDADR = $5E ; word. memory location of cursor.
   176
   177 = 0060			NEWROW = $60 ; Destination row for Drawto and Fill.
   178 = 0062			NEWCOL = $62 ; word. Destination column for Drawto and Fill.
   179 = 0064			LOGCOL = $64 ; Logical line cursor column.
   180 = 0065			ADRESS = $65 ; word. S: Temp address for Display List, copy of SAVMSC, etc.
   181
   182 = 0066			MLTTMP = $66 ; word. Temp value for S: and in OPEN
   183 = 0068			SAVADR = $68 ; word. S: temporary value. 
   184
   185 = 006A			RAMTOP = $6A ; First page after end of usable memory.
   186
   187 = 006B			BUFCNT = $6B ; E: temp logical line size.
   188 = 006C			BUFSTR = $6C ; word. E: temp value
   189
   190 = 006E			BITMSK = $6E ; S: bit mapping value
   191 = 006F			SHFAMT = $6F ; S: pixel shift amount per graphics mode
   192 = 0070			ROWAC =  $70 ; word. S: temporary row value
   193 = 0072			COLAC =  $72 ; word. S: temporary column value
   194
   195 = 0074			ENDPT =  $74 ; word.  S: end point for Drawto.  Copy of DELTAR or DELTAC
   196
   197 = 0076			DELTAR = $76 ; S: ABS( NEWROW - ROWCRS )
   198 = 0077			DELTAC = $77 ; word.  S: ABS( NEWCOL - COLCRS )
   199 = 0079			ROWINC = $79 ; S: Row +/- (+1 or -1) 0 is down.  $FF is up.
   200 = 007A			COLINC = $7A ; S: Column +/- (+1 or -1) 0 is right, $FF is left.
   201
   202 = 007B			SWPFLG = $7B ; S: text window swap control. 0 = graphics. $FF = text window.
   203 = 007C			HOLDCH = $7C ; S: byte value for shifting.
   204 = 007D			INSDAT = $7D ; S: temporary character value
   205 = 007E			COUNTR = $7E ; word. S: Loop control for line drawing. Value of DELTAR or DELTAC.
   206
   207 				;=================================================
   208 				; Cartridge-specific Page 0 - $7F to $D1
   209 				;=================================================
   210
   211 				;=================================================
   212 				; Atari BASIC/OSS BASIC XL values Page 0
   213 				;=================================================
   214 = 0080			LOMEM  = $80 ; word. BASIC start of memory.
   215
   216 = 0082			VNTP   = $82 ; word. BASIC Variable Name Table Pointer.
   217 = 0084			VNTD   = $84 ; word. BASIC Variable Name Table End address (Dummy) 
   218 = 0086			VVTP   = $86 ; word. BASIC Variable Value Table Pointer.
   219
   220 = 0088			STMTAB = $88 ; word. BASIC Start of Statements/user's BASIC program.
   221 = 008A			STMCUR = $8A ; word. BASIC pointer to current statement.
   222
   223 = 008C			STARP  = $8C ; word. BASIC String and Array table pointer.
   224 = 008E			RUNSTK = $8E ; word. BASIC Pointer to GOSUB/FOR-NEXT stack.
   225
   226 = 0090			MEMTP =  $90 ; word. BASIC pointer to end of user BASIC program.
   227
   228 = 0092			STOPLN = $92 ; word. BASIC line number where execution stopped due to Break key or error.
   229 = 00C2			PROMPT = $C2 ; Input prompt character.
   230
   231 = 00C3			ERSAVE = $C3 ; BASIC error code for Stop or Trap.
   232 = 00C8			COLOR =  $C8 ; color for Plot or Drawto. (copied to $2F)
   233
   234 = 00C9			PTABW =  $C9 ; BASIC tab width - number of columns between tab stops.
   235
   236 				;=================================================
   237 				; OS Floating Point Library
   238 				;=================================================
   239 = 00D4			FR0 =    $D4 ; float.  Floating point register and USR return value to BASIC.
   240 = 00DA			FRE =    $DA ; float.  Floating point register (extra).
   241 = 00E0			FR1 =    $E0 ; float.  Floating point register 1.
   242 = 00E6			FR2 =    $E6 ; float.  Floating point register 2.
   243 = 00EC			FRX =    $EC ; Floating Point spare value
   244 = 00ED			EEXP =   $ED ; Floating Point Exponent
   245 = 00EE			NSIGN =  $EE ; Floating Point Sign.
   246 = 00EF			ESIGN =  $EF ; Floating Point Sign of exponent.
   247 = 00F0			FCHRFL = $F0 ; Flag for first character
   248 = 00F1			DIGRT =  $F1 ; Digits to the right of the decimal.
   249 = 00F2			CIX =    $F2 ; current character input index. Offset into INBUFF
   250 = 00F3			INBUFF = $F3 ; word. input for text to BCD conversion.  output at LBUFF
   251 = 00F5			ZTEMP1 = $F5 ; word. Floating point temporary register.
   252 = 00F7			ZTEMP4 = $F7 ; word. Floating point temporary register.
   253 = 00F9			ZTEMP3 = $F9 ; word. Floating point temporary register.
   254 = 00FB			RADFLG = $FB ; or DEGFLG.  0 = radians.  6 = degrees.
   255 = 00FC			FLPTR =  $FC ; word. Pointer to first Floating Point number for operation..
   256 = 00FE			FPTR2 =  $FE ; word. Pointer to Floating Point number for operation.
   257
   258
   259 				;=================================================
   260 				; OS Page 2 
   261 				;=================================================
   262 = 0200			VDSLST = $0200 ; word. Display List interrupt address.
   263
   264 = 0202			VPRCED = $0202 ; word. Peripheral proceed line vector.
   265 = 0204			VINTER = $0204 ; word. Peripheral interrupt vector.
   266 = 0206			VBREAK = $0206 ; word. BRK instruction vector.
   267
   268 = 0208			VKEYBD = $0208 ; word. POKEY keyboard interrupt vector.
   269 = 020A			VSERIN = $020A ; word. POKEY serial I/O receive data ready interrupt vector
   270 = 020C			VSEROR = $020C ; word. POKEY serial I/O transmit data ready interrupt vector
   271 = 020E			VSEROC = $020E ; word. POKEY serial bus transmit complete interrupt vector.
   272
   273 				; HIGH FREQUENCY POKEY TIMERS: 
   274 				; Per Mapping The Atari  
   275 				; (Timer 1/Channel 1 as example)
   276 				; 
   277 				; Store frequency base in AUDCTL/$D208/53768: 
   278 				;    $00 = 64 kilohertz, 
   279 				;    $01 = 15 kilohertz, 
   280 				;    $60 = 1.79 megahertz).
   281 				; Next, set the channel control register (AUDC1/$D201/53761). 
   282 				; Store address of interrupt routine into VTIMR1 ($210/$211). 
   283 				; Store 0 to STIMER/$D209/53769. 
   284 				; Enable the interrupt:
   285 				;    Store in POKMSK/$10 the value of POKMSK OR the interrupt number:
   286 				;       1 = timer 1 interrupt, 
   287 				;       2 = timer 2 interrupt, 
   288 				;       4 = timer 4 interrupt -- no timer 3!). 
   289 				;    Store the same value in IRQEN/$D20E/53774.
   290 				;
   291 				; An interrupt occurs when the timer counts down to zero. 
   292 				; The timer is reloaded with the original value stored there, 
   293 				; and the process begins all over again.
   294 				;
   295 				; The OS pushes the A register onto the stack before jumping 
   296 				; through the vector address. 
   297 				; X and Y are not saved. Push them on the stack if they will be used. 
   298 				; Before RTI/return from the interrupt:
   299 				;    PLA the X and Y from the stack if used
   300 				;    PLA the Accumulator, and 
   301 				;    Clear the interrupt with CLI.
   302 = 0210			VTIMR1 = $0210 ; word. POKEY timer 1 interrupt vector.
   303 = 0212			VTIMR2 = $0212 ; word. POKEY timer 2 interrupt vector.
   304 = 0214			VTIMR4 = $0214 ; word. POKEY timer 4 interrupt vector.
   305
   306 = 0216			VIMIRQ = $0216 ; word. IRQ immediate vector.
   307
   308
   309 				;=================================================
   310 				; COUNTDOWN TIMERS
   311 				;===============================================================
   312 				;  TIMER    | CDTMV1  | CDTMV2  | CDTMV3   | CDTMV4  | CDTMV5  |
   313 				;---------------------------------------------------------------
   314 				; Decrement | stage 1 | stage 2 | stage 2  | stage 2 | stage 2 |
   315 				; in VBI?   |         |         |          |         |         |
   316 				;---------------------------------------------------------------
   317 				; Interrupt | CDTMA1  | CDTMA2  |          |         |         |
   318 				; Vector?   |         |         |          |         |         |
   319 				;---------------------------------------------------------------
   320 				; Countdown |         |         | CDTMF3   | CDTMF4  | CDTMF5  |
   321 				; Flag?     |         |         |          |         |         |
   322 				;---------------------------------------------------------------
   323 				; OS use?   | I/O     |  no     | cassette |  no     |  no     |
   324 				;           | timing  |         | I/O      |         |         |
   325 				;===============================================================
   326 = 0218			CDTMV1 = $0218 ; word. Countdown Timer Value 1.
   327 = 021A			CDTMV2 = $021A ; word. Countdown Timer Value 2.
   328 = 021C			CDTMV3 = $021C ; word. Countdown Timer Value 3.
   329 = 021E			CDTMV4 = $021E ; word. Countdown Timer Value 4.
   330 = 0220			CDTMV5 = $0220 ; word. Countdown Timer Value 5.
   331
   332 = 0222			VVBLKI = $0222 ; word. VBLANK immediate interrupt vector. 
   333 = 0224			VVBLKD = $0224 ; word. VBLANK deferred interrupt vector.
   334
   335 = 0226			CDTMA1 = $0226 ; word. System Timer 1 vector address.
   336 = 0228			CDTMA2 = $0228 ; word. System Timer 2 vector address.
   337 = 022A			CDTMF3 = $022A ; Set when CDTMV3 counts down to 0.
   338 = 022B			SRTIMR = $022B ; keyboard software repeat timer.
   339 = 022C			CDTMF4 = $022C ; Set when CDTMV4 counts down to 0.
   340 = 022D			INTEMP = $022D ; Temp value used by SETVBL.
   341 = 022E			CDTMF5 = $022E ; Set when CDTMV5 counts down to 0.
   342
   343 				; SDMCTL = $022F in ANTIC.asm
   344 				; SDLSTL = $0230 in ANTIC.asm
   345 				; SSKCTL = $0232 in POKEY.asm
   346 				; LPENH  = $0234 in ANTIC.asm
   347 				; LPENV  = $0235 in ANTIC.asm
   348
   349 = 0236			BRKKY =  $0236 ; Break key interrupt vector
   350
   351 				; SIO Command Frame:
   352 = 023A			CDEVIC = $023A ; SIO Bus ID number
   353 = 023B			CCOMND = $023B ; SIO Bus command code
   354 = 023C			CAUX1 =  $023C ; Command auxiliary byte 1
   355 = 023D			CAUX2 =  $023D ; Command auxiliary byte 2
   356
   357 = 023E			TMPSIO = $023E ; SIO temporary byte
   358 = 023F			ERRFLG = $023F ; SIO error flag (except timeout)
   359 = 0240			DFLAGS = $0240 ; Disk flags from first byte of boot sector.
   360 = 0241			DBSECT = $0241 ; Number of Boot sectors read.
   361 = 0242			BOOTAD = $0242 ; word. Address of the boot loader.
   362
   363 = 0244			COLDST = $0244 ; Coldstart Flag. 0 = reset is warmstart.  1 = reset is coldstart.
   364
   365 = 0246			DSKTIM = $0246 ; Disk I/O timeout countdown.
   366
   367 = 0247			LINBUF = $0247 ; 40 characters. temporary buffer for screen data.
   368
   369 				; GPRIOR = $026F in GTIA.asm
   370 				; PADDL0 = $0270 in POKEY.asm
   371 				; PADDL1 = $0271 in POKEY.asm
   372 				; PADDL2 = $0272 in POKEY.asm
   373 				; PADDL3 = $0273 in POKEY.asm
   374 				; PADDL4 = $0274 in POKEY.asm
   375 				; PADDL5 = $0275 in POKEY.asm
   376 				; PADDL6 = $0276 in POKEY.asm
   377 				; PADDL7 = $0277 in POKEY.asm
   378 				; STICK0 = $0278 in POKEY.asm
   379 				; STICK1 = $0279 in POKEY.asm
   380 				; STICK2 = $027A in POKEY.asm
   381 				; STICK3 = $027B in POKEY.asm
   382 				; PTRIG0 = $027C in POKEY.asm
   383 				; PTRIG1 = $027D in POKEY.asm
   384 				; PTRIG2 = $027E in POKEY.asm
   385 				; PTRIG3 = $027F in POKEY.asm
   386 				; PTRIG4 = $0280 in POKEY.asm
   387 				; PTRIG5 = $0281 in POKEY.asm
   388 				; PTRIG6 = $0282 in POKEY.asm
   389 				; PTRIG7 = $0283 in POKEY.asm
   390 				; STRIG0 = $0284 in POKEY.asm
   391 				; STRIG1 = $0285 in POKEY.asm
   392 				; STRIG2 = $0286 in POKEY.asm
   393 				; STRIG3 = $0287 in POKEY.asm
   394
   395 = 0288			CSTAT =  $0288 ; Cassette status register.
   396 = 0289			WMODE =  $0289 ; Cassette Write mode.  0 = read. $80 = write
   397 = 028A			BLIM =   $028A ; Cassette Buffer Limit. character count in buffer: 0 to $80.
   398
   399 = 0290			TXTROW = $0290 ; E: text window cursor row.
   400 = 0291			TXTCOL = $0291 ; word. E: text window cursor column.
   401 = 0293			TINDEX = $0293 ; Split-screen text window graphics mode.  
   402 = 0294			TXTMSC = $0294 ; word. Address of first byte of text window when split screen is active.
   403 = 0296			TXTOLD = $0296 ; 6 bytes -- split screen versions of OLDROW, OLDCOL (word), OLDCHR, OLDADR (word) 
   404 = 029C			TMPX1 =  $029C ; 4 bytes -- Temp values for disply handler.
   405 = 02A0			DMASK =  $02A0 ; Pixel Mask per current graphics mode. 1s set for bits that correspond to pixels.
   406 					; 11111111 -- OS Modes 0, 1, 2, 12, 13 - 1 pixel is 1 byte
   407 					; 11110000 -- OS Modes 9, 10, 11 for GTIA - 2 pixels each byte
   408 					; 00001111
   409 					; 11000000 -- OS Modes 3, 5, 7, 15 - 4 pixels each byte
   410 					; 00110000 
   411 					; 00001100
   412 					; 00000011
   413 					; 10000000 -- OS modes 4, 6, 8, 14 - 8 pixels each byte
   414 					; 01000000
   415 					; ... up to 
   416 					; 00000001
   417
   418 = 02A1			TMPLBT = $02A1 ; Temporary value for bit mask.
   419 = 02A2			ESCFLG = $02A2 ; Set to $80 when ESC key pressed. Reset to 0 for other characters.
   420 = 02A3			TABMAP = $02A3 ; 15 bytes (120 bits) One bit for each character in a logical line.  1 = tab set. 0 = no tab.
   421 = 02B2			LOGMAP = $02B2 ; 4 bytes. Bits of the first 3 bytes indicate the correspoding line on screen begins a logical line. 1 = start of logical line.
   422 = 02B6			INVFLG = $02B6 ; When set to $80, input from E: occurs in inverse video.
   423 = 02B7			FILFLG = $02B7 ; If operation is Draw this is 0. If operation is Fill, this is !0.
   424 = 02B8			TMPROW = $02B8 ; Temporary row from ROWCRS
   425 = 02B9			TMPCOL = $02B9 ; word. Temporary column from COLCRS
   426 = 02BB			SCRFLG = $02BB ; Count number of physical lines in a logical line removed from screen.
   427 = 02BE			SHFLOK = $02BE ; $0 for lowercase. $40 for uppercase (shift). $80 for control (ctrl) 
   428 = 02BF			BOTSCR = $02BF ; Number of rows available for printing. 24 for OS Mode 0.  4 for text windows.
   429
   430 				; PCOLOR0 = $02C0 in GTIA.asm
   431 				; PCOLOR1 = $02C1 in GTIA.asm
   432 				; PCOLOR2 = $02C2 in GTIA.asm
   433 				; PCOLOR3 = $02C3 in GTIA.asm
   434 				; COLOR0 =  $02C4 in GTIA.asm
   435 				; COLOR1 =  $02C5 in GTIA.asm
   436 				; COLOR2 =  $02C6 in GTIA.asm
   437 				; COLOR3 =  $02C7 in GTIA.asm
   438 				; COLOR4 =  $02C8 in GTIA.asm
   439
   440 				; RUNAD =   $02E0 in DOS.asm
   441 				; INITAD =  $02E2 in DOS.asm
   442
   443 = 02E4			RAMSIZ = $02E4 ; Highest usable Page number (high byte)
   444 = 02E5			MEMTOP = $02E5 ; word. Pointer to last byte usable by application. OS display data follows.
   445 = 02E7			MEMLO =  $02E7 ; word. Pointer to start of free mememory. ($0700 default, $1CFc with DOS 2, $23DC with 850 driver)
   446
   447 = 02EA			DVSTAT = $02EA ; 4 bytes. Status registers for serial device status. Different for Disk vs 850.
   448
   449 = 02EE			CBAUDL = $02EE ; low byte cassette bps rate.
   450 = 02EF			CBAUDH = $02EF ; high byte cassette bps rate.
   451
   452 = 02F0			CRSINH = $02F0 ; Cursor Inhibit.  0 = cursor on.  1 = cursor off.
   453 = 02F1			KEYDEL = $02F1 ; Key delay counter. Starts at 3, decremented each frame until 0.
   454 = 02F2			CH1 =    $02F2 ; Keyboard character code previously in CH/$02FC.
   455
   456 				; CHACT = $02F3 in ANTIC.asm
   457 				; CHBAS = $02F4 in ANTIC.asm
   458
   459 = 02FA			ATACHR = $02FA ; Last value read or written at graphics cursor.  Atascii in text modes. color number in others.  
   460 				; CH =     $02FC ; in POKEY.asm KBCODE - Internal keyboard code of last key pressed.  $FF is no key pressesd.
   461 = 02FD			FILDAT = $02FD ; Color for the fill region.
   462 = 02FE			DSPFLG = $02FE ; E: config for cursor control characters. 0 = normal operation. !0 = Display cursor controls instead of acting on them.
   463 = 02FF			SSFLAG = $02FF ; Scrolling stop/start control. 0 = normal scrolling.  $FF = stop scrolling.
   464
   465 				;=================================================
   466 				; OS Page 3
   467 				;=================================================
   468 = 0300			DDEVIC = $0300 ; Serial bus device ID. Set by Handler.
   469 = 0301			DUNIT =  $0301 ; Device unit number. Set by user program.
   470 = 0302			DCOMND = $0302 ; Device command set by handler or the user program.
   471 = 0303			DSTATS = $0303 ; Status code for user program. Handler's data frame direction for SIO. 
   472 = 0304			DBUFLO = $0304 ; word. Data buffer address.
   473 = 0305			DBUFHI = $0305 
   474 = 0306			DTIMLO = $0306 ; Handler timeout in (approx) seconds.
   475 = 0308			DBYTLO = $0308 ; word. Number of bytes transferred to/from buffer.
   476 = 0309			DBYTHI = $0309 
   477 = 030A			DAUX1 =  $030A ; Information specific to device.  (sector number) 
   478 = 030B			DAUX2 =  $030B ; Information specific to device.  (sector number) 
   479
   480 = 030C			TIMER1 = $030C ; Timer for BPS rate 
   481 = 030E			ADDCOR = $030E ; Math correction for calculating bps rate 
   482 = 030F			CASFLG = $030F ; SIO Cassette mode or not. 0 = standard SIO. !0 = cassette.
   483 = 0310			TIMER2 = $0310 ; word. End timer for bps rate.
   484 = 0312			TEMP1 =  $0312 ; word. Temporary value for SIO bps calculations.
   485 = 0314			TEMP2 =  $0314 ; Temporary value
   486 = 0315			TEMP3 =  $0315 ; Temporary value
   487 = 0316			SAVIO =  $0316 ; SIO flag for bit arrival.
   488 = 0317			TIMFLG = $0317 ; Timeout for bps rate correction.
   489 = 0318			STACKP = $0318 ; SIO stack pointer.
   490 = 0319			TSTAT =  $0319 ; Temporary status.
   491
   492 				; Handler Address Table
   493 				; 12 entries, 3 bytes each:
   494 				; Atascii character for device.
   495 				; Handler address LSB/MSB.
   496 = 031A			HATABS = $031A ; 36 bytes of handler entries, 3 bytes each.
   497
   498 				; CIO Block.  ** denotes commonly used fields **
   499 = 0340			IOCB =  $0340   ; Base IO Control Block
   500 = 0340			ICHID = IOCB+$00 ; Handler ID
   501 = 0341			ICDNO = IOCB+$01 ; Device number
   502 = 0342			ICCMD = IOCB+$02 ; ** CIO Command **
   503 = 0343			ICSTA = IOCB+$03 ; CIO Status
   504 = 0344			ICBAL = IOCB+$04 ; ** Buffer address (low) **
   505 = 0345			ICBAH = IOCB+$05 ; ** Buffer address (high) **
   506 = 0346			ICPTL = IOCB+$06 ; Put char routine (low)
   507 = 0347			ICPTH = IOCB+$07 ; Put char routine (high)
   508 = 0348			ICBLL = IOCB+$08 ; ** Buffer length (low) **
   509 = 0349			ICBLH = IOCB+$09 ; ** Buffer length (high) **
   510 = 034A			ICAX1 = IOCB+$0A ; ** Aux Byte 1 **
   511 = 034B			ICAX2 = IOCB+$0B ; ** Aux Byte 2 **
   512 = 034C			ICAX3 = IOCB+$0C ; Aux Byte 3  
   513 = 034D			ICAX4 = IOCB+$0D ; Aux Byte 4  
   514 = 034E			ICAX5 = IOCB+$0E ; Aux Byte 5  
   515 = 034F			ICAX6 = IOCB+$0F ; Aux Byte 6  
   516
   517 = 0340			IOCB0 = IOCB  ; IOCB for channel 0
   518 = 0350			IOCB1 = $0350 ; IOCB for channel 1
   519 = 0360			IOCB2 = $0360 ; IOCB for channel 2
   520 = 0370			IOCB3 = $0370 ; IOCB for channel 3
   521 = 0380			IOCB4 = $0380 ; IOCB for channel 4
   522 = 0390			IOCB5 = $0390 ; IOCB for channel 5
   523 = 03A0			IOCB6 = $03A0 ; IOCB for channel 6
   524 = 03B0			IOCB7 = $03B0 ; IOCB for channel 7
   525
   526 = 03C0			PRNBUF = $03C0 ; 40 bytes up to $3E7
   527
   528 				; CIO Common Device Commands
   529 = 0003			CIO_OPEN =       $03
   530 = 0005			CIO_GET_RECORD = $05
   531 = 0007			CIO_GET_BYTES =  $07
   532 = 0009			CIO_PUT_RECORD = $09
   533 = 000B			CIO_PUT_BYTES =  $0B
   534 = 000C			CIO_CLOSE =      $0C
   535 = 000D			CIO_STATUS =     $0D
   536 = 000E			CIO_SPECIAL =    $0E
   537
   538 				; CIO Device Commands for D:
   539 = 0020			CIO_D_RENAME =      $20 ; Rename a file
   540 = 0021			CIO_D_DELETE =      $21 ; Delete the named file
   541 = 0023			CIO_D_LOCK =        $23 ; Lock/protect the file
   542 = 0024			CIO_D_UNLOCK =      $24 ; unlock/unprotect the file
   543
   544 = 0025			CIO_D_POINT =       $25 ; Move to sector/byte position
   545 = 0026			CIO_D_NOTE =        $26 ; Get current sector/byte position
   546
   547 = 0027			CIO_D_FILELEN =     $27 ; Get file length
   548 = 0029			CIO_D_CD_MYDOS =    $29 ; MyDos cd (change directory)
   549 = 002A			CIO_D_MKDIR_MYDOS = $2A ; MyDos (and SpartaDos) mkdir (make directory)
   550 = 002B			CIO_D_RMDIR_SPDOS = $2B ; SpartaDos rmdir (remove directory)
   551 = 002C			CIO_D_CD_SPDOS    = $2C ; SpartaDos cd (change directory)
   552 = 0030			CIO_D_PWD_MYDOS   = $30 ; MyDos (and SpartaDos) print/get working directory 
   553
   554 = 00FE			CIO_D_FORMAT =      $FE ; Format Disk
   555
   556 				; CIO Device Commands for S:
   557 = 0011			CIO_S_DRAWTO = $11
   558 = 0012			CIO_S_FILL =   $12
   559
   560 				; ICAX1 Common Options (OPEN modes).
   561 = 0004			CIO_ICAX_READ      = $04
   562 = 0008			CIO_ICAX_WRITE     = $08 ; READ + WRITE starts I/O at first byte.
   563
   564 				; ICAX1 Less Common Options (OPEN modes.)
   565 = 0001			CIO_ICAX_E_FORCED     = $01 ; E: FORCED input. Usually with READ + WRITE.
   566 = 0001			CIO_ICAX_D_APPEND     = $01 ; D: Write starts at end of file. Usually with READ + WRITE.
   567 = 0002			CIO_ICAX_D_DIRECTORY  = $02 ; D: DIRECTORY.  Use with READ. 
   568
   569 = 0010			CIO_ICAX_S_TEXTWINDOW = $10 ; S: Open graphics mode with text window. Ignored for 0, 9, 10, 11.
   570 = 0020			CIO_ICAX_S_DONOTCLEAR = $20 ; S: Suppress clear screen for graphics mode. 
   571
   572 				; Note: 
   573 				; The ICAX2 value for S: is the OS graphics mode number.
   574 				; If the mode is 0, 9, 10, or 11 the text Window option is ignored.
   575
   576 				;=================================================
   577 				; OS Page 4, 5, 6   
   578 				;=================================================
   579 = 03FD			CASBUF = $03FD ; 128 bytes up to $047F (ends in page 4)
   580
   581 				; $0480 to $06FF are free if BASIC and FP are not used. 
   582
   583 				; $057E to $05FF
   584 				; Various line/buffer values for FP package.
   585
   586 = 057E			LBPR1 =  $057E ; LBUFF Prefix 1.
   587 = 057F			LBPR2 =  $057F ; LBUFF Prefix 2.
   588 = 0580			LBUFF =  $0580 ; up to $5FF. Text buffer for FP/ATASCII conversions.
   589 = 05E0			PLYARG = $05E0 ; Polynomial arguments for FP package.
   590 = 05E6			FPSCR =  $05E6 ; to $05EB -- FP temporary use
   591 = 05EC			FPSCR1 = $05EC ; to $05FF -- FP temporary use
   592
   593 				;=================================================
   594 				; Cartridge space 
   595 				; Pages $80 through $9F 
   596 				; Pages $A0 through $BF 
   597 				;=================================================
   598 				; CART B -- Atari 800 ONLY
   599 = 8000			CARTB =  $8000 ; Start of Cart B/Right Cart (8K)
   600 = 9FFA			CRBSTA = $9FFA ; word. Cart B/Right Start address.
   601 = 9FFC			CRBFLG = $9FFC ; Cart B/right present.  Copied to $7 CTBFLG
   602 = 9FFD			CRBBTF = $9FFD ; Cart B/right Boot Option bits. $1 = boot disk. $4 = Boot cart. $80 = diagnostic cart 
   603 = 9FFE			CRBINI = $9FFE ; word. Init address for Cart B/Right for cold boot/warm start
   604
   605 = A000			CARTA =  $A000 ; Start of Cart A/Left Cart (8K)
   606 = BFFA			CRASTA = $BFFA ; word. Cart A/Left Start address.
   607 = BFFC			CRAFLG = $BFFC ; Cart A/Left present.  Copied to $6 CTAFLG
   608 = BFFD			CRABTF = $BFFD ; Cart A/Left Boot Option bits. $01 = boot disk. $04 = Boot cart. $80 = diagnostic cart 
   609 = BFFE			CRAINI = $BFFE ; word. Init address for Cart A/Left for cold boot/warm start
   610
   611 				;=================================================
   612 				; XL OS ROM CSET 2 Pages $CC - $CF
   613 				;=================================================
   614 = CC00			ROM_CSET_2 = $CC00
   615
   616 				;=================================================
   617 				; OS Floating Point Package 
   618 				; Pages $D8 through $DF 
   619 				;=================================================
   620 				; FP Routines References:
   621 				;  Page 0 - $D4 to $DB  
   622 				;  Page 5 - $57E to $5FF
   623 				; In/out usually FR0, and LBUFF
   624 				;=================================================
   625 = D800			AFP =    $D800 ; Convert ATASCII to FP
   626 = D8E6			FASC =   $D8E6 ; Convert FP to ATASCII
   627 = D9AA			IFP =    $D9AA ; Convert Integer to FP
   628 = D9D2			FPI =    $D9D2 ; Convert FP to Integer
   629 = DA44			ZFRO =   $DA44 ; Zero FR0
   630 = DA46			ZFR1 =   $DA46 ; Zero FR1
   631 = DA60			FSUB =   $DA60 ; Subtracttion - FR0 minus FR1
   632 = DA66			FADD =   $DA66 ; Addition - FR0 plus FR1
   633 = DADB			FMUL =   $DADB ; Multiplication - FR0 times FR1
   634 = DB28			FDIV =   $DB28 ; Division - FR0 divided by FR1
   635 = DD40			PLYEVL = $DD40 ; Evaluate FP Polynomial 
   636 = DD89			FLD0R =  $DD89 ; Load FR0 from x, Y reg pointer
   637 = DD8D			FLD0P =  $DD8D ; Load FR0 from FLPTR
   638 = DD98			FLD1R =  $DD98 ; Load FR1 from x, Y reg pointer
   639 = DD9C			FLD1P =  $DD9C ; Load FR1 from FLPTR
   640 = DDA7			FST0R =  $DDA7 ; Store FR0 to address in X, Y registers
   641 = DDAB			FST0P =  $DDAB ; Store FR0 using FLPTR 
   642 = DDB6			FMOVE =  $DDB6 ; Move FR0 contents to FR1
   643 = DDC0			EXP =    $DDC0 ; Exponentiation - FP base E 
   644 = DDCC			EXP10 =  $DDCC ; FP base 10 exponentiations
   645 = DECD			LOG =    $DECD ; FP natural log
   646 = DED1			LOG10 =  $DED1 ; FP base 10 log
   647
   648 				;=================================================
   649 				; OS ROM CSET Pages $E0 - $E3 
   650 				;=================================================
   651 = E000			ROM_CSET = $E000
   652
   653
   654 				;=================================================
   655 				; OS ROM VECTORs - Page $E4
   656 				;=================================================
   657 				; Device handler vectors specify:
   658 				; Open 
   659 				; Close 
   660 				; Get Byte 
   661 				; Put Byte 
   662 				; Get Special
   663 				; JMP to handler init routine
   664 = E400			EDITRV = $E400 ; Screen editor vector table.
   665 = E410			SCRENV = $E410 ; Screen editor vector table.
   666 = E420			KEYBDV = $E420 ; Screen editor vector table.
   667 = E430			PRINTV = $E430 ; Screen editor vector table.
   668 = E440			CASETV = $E440 ; Screen editor vector table.
   669
   670 = E450			DISKIV = $E450 ; JMP vector for disk handler init
   671 = E453			DSKINV = $E453 ; JMP vector for disk handler interface.
   672
   673 = E456			CIOV =   $E456 ; JSR vector for CIO. All CIO operations go through this address.
   674 = E459			SIOV =   $E459 ; JMP vector for SIO.
   675
   676 				; JSR to set Vertical Blank Interupt Vector/Timer values.
   677 				; Y register is the LSB of vector/routine or timer value.
   678 				; X register is the MSB of vector/routine or timer value.
   679 				; A register is the number of the Vertical Blank routine to change:
   680 				;    1 == CDTMV1 - decremented Immediate VBI Stage 1 -- JSR to CDTMA1 $0226
   681 				;    2 == CDTMV2 - decremented Immediate VBI Stage 2 -- JSR to CDTMA2 $0228
   682 				;    3 == CDTMV3 - decremented Immediate VBI Stage 2 -- Zero CDTMF3 $022A
   683 				;    4 == CDTMV4 - decremented Immediate VBI Stage 2 -- Zero CDTMF4 $022C
   684 				;    5 == CDTMV5 - decremented Immediate VBI Stage 2 -- Zero CDTMF5 $022E
   685 				;    6 == Immediate VBI
   686 				;    7 == deferred VBI
   687 = E45C			SETVBV = $E45C ; JSR Vector to set timers
   688
   689 				; User Immediate VBI routine should end by a JMP to this address 
   690 				; to continue the OS Vertical Blank routine. 
   691 = E45F			SYSVBV = $E45F ; JMP to end user Immediate VBI
   692
   693 				; User Deferred VBI routine should end by a JMP to this address 
   694 				; to continue the OS Vertical Blank routine. 
   695 = E462			XITVBV = $E462 ; JMP Vector to end user Deferred VBI
   696
   697 = E474			WARMSV = $E474 ; Usr() here will warmstart.
   698 = E477			COLDSV = $E477 ; Usr() here to cold boot the system.
   699
   700 				; After this there is not much that a user program 
   701 				; should reference or call.  
   702 				; I/O should be done by CIO. 
   703 				; Vertical Blank timers should be set by calling SETVBV.
   704 				; Everything else is subject to change or reloaction 
   705 				; in a future operating system.
   386 					icl "DOS.asm"   ; LOMEM, load file start, and run addresses.
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/DOS.asm
     1 				;=================================================
     2 				; DOS memory and vectors
     3 				; For Mads assembler
     4 				; Ken Jennings
     5 				;=================================================
     6 				; Misc values related to DOS and file loading
     7 				;
     8 = 2000			LOMEM_DOS =     $2000 ; First memory after DOS
     9 = 3308			LOMEM_DOS_DUP = $3308 ; First memory after DOS and DUP 
    10 				;
    11 				; Atari RUN ADDRESS.  
    12 				; The binary load file has a segmented structure 
    13 				; specifying starting address, and ending address, 
    14 				; followed by the bytes to load in that memory range.  
    15 				; DOS observes two special addresses when loading data.
    16 				; If the contents of the INIT address changes ater loading
    17 				; a segment DOS calls that address immediately. If the routine
    18 				; returns to DOS cleanly then file loading continues.
    19 				; If the contents of the RUN address changes DOS waits until
    20 				; all segments from the file are loaded and then calls the RUN
    21 				; address target.
    22 				;
    23 = 02E0			DOS_RUN_ADDR =  $02e0 ; Execute here when file loading completes.
    24 = 02E2			DOS_INIT_ADDR = $02e2 ; Execute here immediately then resume loading.
    25
   387 				; --------------------------------------------------------------------------
   388
   389 				; ==========================================================================
   390 				; Macros (No code/data declared)
   391 					icl "macros.asm"
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/macros.asm
     1 				;===============================================================================
     2 				;	MACROS
     3 				;===============================================================================
     4 				; Generic, all-purpose, helper macros to shorten repetitive 
     5 				; tasks and make more readable code
     6 				;===============================================================================
     7
     8 				;===============================================================================
     9 				; 6502 REGISTER MAINTENANCE
    10 				;===============================================================================
    11 				; Various shortcuts for managing 6502 A, X, Y registers typically used 
    12 				; when entering/exiting interrupts.  
    13 				;
    14 				; Also, a couple routines for entry/exit from a routine called by JSR to 
    15 				; preserve the registers and CPU flags, so the routine does not affect
    16 				; the caller.
    17 				;===============================================================================
    18
    19 				;-------------------------------------------------------------------------------
    20 				;                                                               REGSAVEAY A Y
    21 				;-------------------------------------------------------------------------------
    22 				; mRegSaveAY 
    23 				;
    24 				; Save A, Y CPU registers on stack. 
    25 				;-------------------------------------------------------------------------------
    26
    27 				.macro mRegSaveAY 
    28 					PHA 
    29 					TYA 
    30 					PHA  
    31 				.endm 
    32
    33 				;-------------------------------------------------------------------------------
    34 				;                                                               REGSAVEAX A X
    35 				;-------------------------------------------------------------------------------
    36 				; mRegSaveAX
    37 				;
    38 				; Save A, X CPU registers on stack. 
    39 				;-------------------------------------------------------------------------------
    40
    41 				.macro mRegSaveAX  
    42 					PHA 
    43 					TXA 
    44 					PHA  
    45 				.endm 
    46
    47 				;-------------------------------------------------------------------------------
    48 				;                                                               REGSAVEAYX A Y X
    49 				;-------------------------------------------------------------------------------
    50 				; mRegSaveAYX 
    51 				;
    52 				; Save A, Y, X CPU registers on stack. 
    53 				;-------------------------------------------------------------------------------
    54
    55 				.macro mRegSaveAYX  
    56 					PHA 
    57 					TYA 
    58 					PHA 
    59 					TXA 
    60 					PHA 
    61 				.endm 
    62
    63 				;-------------------------------------------------------------------------------
    64 				;                                                               REGRESTOREAY A Y
    65 				;-------------------------------------------------------------------------------
    66 				; mRegRestoreAY
    67 				;
    68 				; Restore A, Y CPU registers from stack. 
    69 				;-------------------------------------------------------------------------------
    70
    71 				.macro mRegRestoreAY  
    72 					PLA 
    73 					TAY 
    74 					PLA 
    75 				.endm 
    76
    77 				;-------------------------------------------------------------------------------
    78 				;                                                               REGRESTOREAX A X
    79 				;-------------------------------------------------------------------------------
    80 				; mRegRestoreAX
    81 				;
    82 				; Restore A, X CPU registers from stack. 
    83 				;-------------------------------------------------------------------------------
    84
    85 				.macro mRegRestoreAX  
    86 					PLA 
    87 					TAX 
    88 					PLA 
    89 				.endm 
    90
    91 				;-------------------------------------------------------------------------------
    92 				;                                                            REGRESTOREAYX A Y X
    93 				;-------------------------------------------------------------------------------
    94 				; mRegRestoreAYX 
    95 				;
    96 				; Restore A, Y, X CPU registers from stack. 
    97 				;-------------------------------------------------------------------------------
    98
    99 				.macro mRegRestoreAYX  
   100 					PLA 
   101 					TAX 
   102 					PLA 
   103 					TAY 
   104 					PLA 
   105 				.endm 
   106
   107 				;-------------------------------------------------------------------------------
   108 				;                                                               REGSAVE P A Y X
   109 				;-------------------------------------------------------------------------------
   110 				; mRegSave 
   111 				;
   112 				; Saves the CPU registers so subroutines do not disturb the 
   113 				; register states and logic/flow of the main code.
   114 				;-------------------------------------------------------------------------------
   115
   116 				.macro mRegSave  
   117 					PHP 
   118 					
   119 					mRegSaveAYX
   120 				.endm 
   121
   122 				;-------------------------------------------------------------------------------
   123 				;                                                            REGRESTORE X Y A P
   124 				;-------------------------------------------------------------------------------
   125 				; mRegRestore 
   126 				;
   127 				; Restore A, Y, X CPU registers from stack. 
   128 				;-------------------------------------------------------------------------------
   129
   130 				.macro mRegRestore  
   131 					mRegRestoreAYX
   132 					
   133 					PLP 
   134 				.endm 
   135
   136 				;-------------------------------------------------------------------------------
   137 				;                                                             REGSAFERTS X Y A P
   138 				;-------------------------------------------------------------------------------
   139 				; mRegSafeRTS 
   140 				;
   141 				; Restores CPU registers for safe return from a routine 
   142 				; that used saveRegs to preserve the CPU registers.
   143 				;
   144 				; Includes the RTS.
   145 				;-------------------------------------------------------------------------------
   146
   147 				.macro mRegSafeRTS  
   148 					mRegRestore
   149 					
   150 					RTS 
   151 				.endm 
   152
   153 				;===============================================================================
   154 				; The Basic Choice - (paper or plastic?)
   155 				;===============================================================================
   156 				; Load an explicit value or load from memeory?
   157 				; This means do not use page 0 references which would 
   158 				; be considered values less than 256, and the 
   159 				; address would be loaded as an explit value instead.
   160 				; (Which could be useful if you know what you're doing).
   161 				;===============================================================================
   162
   163 				.macro mLDA_VM  value
   164 					.if :0<>1
   165 						.error "LDA_VM: 1 argument required"
   166 					.else
   167 						.if :value>$FF
   168 							lda :value  ; get from memory
   169 						.else
   170 							lda #:value ; Get constant value
   171 						.endif
   172 					.endif
   173 				.endm
   174
   175 				.macro mLDX_VM  value
   176 					.if :0<>1
   177 						.error "LDX_VM: 1 argument required"
   178 					.else
   179 						.if :value>$FF
   180 							ldx :value  ; get from memory
   181 						.else
   182 							ldx #:value ; Get constant value
   183 						.endif
   184 					.endif
   185 				.endm
   186
   187 				.macro mLDY_VM  value
   188 					.if :0<>1
   189 						.error "LDY_VM: 1 argument required"
   190 					.else
   191 						.if :value>$FF
   192 							ldy :value  ; get from memory
   193 						.else
   194 							ldy #:value ; Get constant value
   195 						.endif
   196 					.endif
   197 				.endm
   198
   199 				;===============================================================================
   200 				; 16-BIT LOADS
   201 				;===============================================================================
   202 				; Load/move 16-bit values
   203 				;===============================================================================
   204
   205 				;-------------------------------------------------------------------------------
   206 				;                                                                LOADINT_M   A
   207 				;-------------------------------------------------------------------------------
   208 				; mLoadInt_M <Destination Address>, <Source Address>
   209 				;
   210 				; Loads the 16-bit value stored at <Source Address> into <Destination Address>.
   211 				; 
   212 				; Can be used to assign an address to a page 0 location for 
   213 				; later indirect addressing.
   214 				; In general, copies a 16-bit value to any address.   
   215 				; Like (in C):  C = D.
   216 				;-------------------------------------------------------------------------------
   217
   218 				.macro mLoadInt_M  target,source
   219 					.IF :0<>2
   220 						.ERROR "LoadInt_M: 2 arguments (target addr, source addr) required."
   221 					.ELSE
   222 						lda :source
   223 						sta :target
   224 						lda :source + 1
   225 						sta :target + 1
   226 					.ENDIF
   227 				.endm
   228
   229 				;-------------------------------------------------------------------------------
   230 				;                                                                LOADINT_V  A
   231 				;-------------------------------------------------------------------------------
   232 				; mLoadInt_V <Destination Address>, <Value>
   233 				;
   234 				; Loads the immediate 16-bit <Value> into <Destination Address>.
   235 				; 
   236 				; Can be used to assign an address to a page 0 location for 
   237 				; later indirect addressing.
   238 				; In general, stores an immediate 16-bit value at any address.
   239 				; Like (in C):
   240 				;  C = 12  or 
   241 				;  C = &D
   242 				;-------------------------------------------------------------------------------
   243
   244 				.macro mLoadInt_V  target,value
   245 					.if :0<>2
   246 						.error "LoadInt_V: 2 arguments (target addr, 16-bit value) required."
   247 					.else
   248 						lda #<:value
   249 						sta :target
   250 						lda #>:value
   251 						sta :target + 1
   252 					.endif
   253 				.endm
   254
   255 				;===============================================================================
   256 				; DISK SHENANIGANS
   257 				;===============================================================================
   258 				; The Atari executable file is a structured format.  The file contents identify
   259 				; starting address, ending address, and the data to load.  This feature 
   260 				; ordinarily allows the assembler to optimize the file size by describing only
   261 				; the segments of memory needed for the program.  However, it can also be
   262 				; abused to set values into any memory location during the program load time,
   263 				; such as the operating system shadow registers.  This allows the act of 
   264 				; loading the program to also perform a degree of initialization that applies
   265 				; configuration to the system without the program expending its own code 
   266 				; space to load and store values.
   267 				;
   268 				; The assembler supports this simply by changing the program address *=
   269 				; and then declaring storage (.byte, etc.)  These macros capture the 
   270 				; current program address in a temporary variable, set the current
   271 				; address,  declare the supplied value, then restore the program 
   272 				; address to the originally captured value.
   273 				;
   274 				; I think I recall Mac/65 would keep writes like this in the order in 
   275 				; which they occur.  But, it seems atasm collects (optimizes) these changes 
   276 				; of current program address into groups.  Use with caution.  Your Mileage 
   277 				; Will Definitely Vary.
   278 				;
   279 				; Maximum effectiveness using disk load would enable Title screens, 
   280 				; animation, music, etc. at known locations/events while loading the 
   281 				; main program.  Accomplishing this with atasm requires separate builds 
   282 				; and then concatenating the programs together.
   283 				;===============================================================================
   284
   285 				;-------------------------------------------------------------------------------
   286 				;                                                                  DiskPoke
   287 				;-------------------------------------------------------------------------------
   288 				; mDiskPoke <Address> <byte value>
   289 				;
   290 				; Utilize the Atari's structured disk format to load a BYTE value into a memory
   291 				; location at the program load time.
   292 				;-------------------------------------------------------------------------------
   293
   294 				.macro mDiskPoke  address,value
   295 					.if :0<>2
   296 						.error "DiskPoke: 2 arguments (target addr, byte value) required."
   297 					.else
   298 						.if :value>$FF
   299 							.error "DiskPoke: Agument 2 for byte value is greater then $FF"
   300 						.else
   301 							DISKPOKE_TEMP =*
   302 							ORG :address
   303 							.byte :value
   304 							ORG DISKPOKE_TEMP
   305 						.endif
   306 					.endif
   307 				.endm 
   308
   309 				;-------------------------------------------------------------------------------
   310 				;                                                                  DiskDPoke
   311 				;-------------------------------------------------------------------------------
   312 				; mDiskDPoke <Address> <16-bit value>
   313 				;
   314 				; Utilize the Atari's structured disk format to load a 16-bit WORD value into a 
   315 				; memory location at the program load time.
   316 				; 
   317 				; Note that this macro cannot be used until AFTER a valid ORG address is 
   318 				; specified for assembly. If this is not done, then ORG DISKDPOKE_TEMP
   319 				; becomes an error.
   320 				;-------------------------------------------------------------------------------
   321
   322 				.macro mDiskDPoke  address,value
   323 					.if :0<>2
   324 						.error "DiskDPoke: 2 arguments (target addr, integer value) required."
   325 					.else
   326 						DISKDPOKE_TEMP =*
   327 						ORG :address
   328 						.word :value
   329 						ORG DISKDPOKE_TEMP
   330 					.endif
   331 				.endm 
   332
   333 				;-------------------------------------------------------------------------------
   334 				;                                                                CHAINDLI A
   335 				;-------------------------------------------------------------------------------
   336 				; mChainDLI 
   337 				;
   338 				; Use after a DLI to exit and change DLI vector to new address.
   339 				;
   340 				; It will only update the low byte/high byte of the vector when 
   341 				; they are different. 
   342 				;
   343 				; Restore Accumulator from stack.
   344 				;
   345 				; Exits interrupt with RTI.
   346 				;-------------------------------------------------------------------------------
   347
   348 				.macro mChainDLI  ; current_DLI,next_DLI
   349 					.if :0<>2
   350 						.error "mChainDLI: 2 arguments required (Current DLI, Next DLI)
   351 					.endif
   352 				
   353 					; If the same, then no need to change low byte.
   354 					.if [<:current_DLI]<>[<:next_DLI] 
   355 						lda #<:next_DLI ; Low byte of next DLI address
   356 						sta VDSLST      ; Set vector
   357 					.endif
   358 				
   359 					; If the same, then no need to change high byte.
   360 					.if [>:current_DLI]<>[>:next_DLI] 
   361 						lda #>:next_DLI ; High byte of next DLI address
   362 						sta VDSLST+1    ; Set vector
   363 					.endif
   364 				
   365 					pla ; restore A from stack
   366 					rti ; DLI complete
   367 				.endm
   368
   392
   393 				; --------------------------------------------------------------------------
   394
   395 				; ==========================================================================
   396 				; Declare some Page Zero variables.
   397 				; The Atari OS owns the first half of Page Zero.
   398
   399 				; The Atari load file format allows loading from disk to anywhere in
   400 				; memory, therefore indulging in this evilness to define Page Zero
   401 				; variables and load directly into them at the same time...
   402 				; --------------------------------------------------------------------------
   403 					ORG $80
   404
   405 				; ======== M A I N   G A M E   G L O B A L S ======== 
   406
   407 FFFF> 0080-00BC> 00	FrogRow           .byte $00       ; = Frog Y row position (in the beach/boat playfield not counting score lines)
   408 0081 00			FrogNewRow        .byte $00       ; = Main signals to VBI to move row.
   409
   410 0082 00			FrogPMY           .byte $00       ; = Frog's current Player/missile Y coordinate
   411 0083 00			FrogNewPMY        .byte $00       ; = Frog new/next Player/missile Y coordinate
   412 0084 00			FrogPMX           .byte $00       ; = Frog's current Player/missile X coordinate
   413 0085 00			FrogNewPMX        .byte $00       ; = Frog new/next Player/missile X coordinate
   414 0086 00			FrogShape         .byte SHAPE_OFF ; = Image in use -- 0 = off, 1 = frog, 2 = splat, 3 = tombstone 
   415 0087 00			FrogNewShape      .byte SHAPE_OFF ; = Image to use -- 0 = off, 1 = frog, 2 = splat, 3 = tombstone 
   416
   417 0088 00			FrogUpdate        .byte 0         ; 0 = no movement.  >0 = Any reason to change position... <0 = stop and remove frog.
   418
   419 0089 00			FrogSafety        .byte 0         ; = 0 When Frog OK.  !0 == Yer Dead.  Can be set by VBI. Main must change shape.
   420
   421 008A 00			FrogsCrossed      .byte 0         ; = Number Of Frogs crossed in this game
   422 008B 00			FrogsCrossedIndex .byte 0         ; FrogsCrossed + NewLevelStart, limit to range of 0 to 13 difficulty, then times 18.  
   423 				                                  ; FrogsCrossedIndex + FrogRow = Index to read from master lookups. 
   424 008C 00			NewLevelStart     .byte 0         ; = Starting difficulty for new game.  (New level Start  + Frogs Crossed)
   425 008D 00			LastLevelStart    .byte 0         ; = Previous game starting difficulty.
   426
   427 008E 03			NumberOfLives     .byte 3         ; = Is the Number Of Lives remaining in this game
   428 008F 03			NewNumberOfLives  .byte 3         ; = Starting number of lives for new game.
   429 0090 03			LastNumberofLives .byte 3         ; = Previous game starting number of lives.
   430
   431 0091 00			ScoreToAdd        .byte 0         ; = Number To Be Added to Score
   432 0092 00			NumberOfChars     .byte 0         ; = Number Of Characters across for score
   433 0093 00			FlaggedHiScore    .byte 0         ; = Flag For Hi Score.  0 = no high score.  $FF = High score.
   434
   435 0094 00			WobbleX           .byte 0         ; Index into FROG_WOBBLE_SINE_TABLE for X coordinates.
   436 0095 00			WobbleY           .byte 0         ; Index into FROG_WOBBLE_SINE_TABLE for Y coordinates.
   437 0096 00			WobOffsetX        .byte 0         ; 84 for Frog. 80 for Tomb.
   438 0097 00			WobOffsetY        .byte 0         ; 75 for Frog. XX for Tomb.
   439
   440
   441 				; ======== M O R E   M A I N   G L O B A L   S T U F F ======== 
   442
   443 				; Input, event control, and timers.
   444 				; FYI: Frame counters are decremented each frame (by the VBI).
   445 				; Once they decrement to  0 they enable the related activity.
   446
   447 				; After processing input (from the joystick) this is the number of frames
   448 				; to count before new input is accepted.  This prevents moving the frog at
   449 				; 60 fps and maybe-sort-of compensates for jitter/uneven debounce of the 
   450 				; joystick bits by flaky controllers. That's the theory.
   451 0098 00			InputScanFrames   .byte $00 ; = INPUTSCAN_FRAMES
   452 0099 00			InputStick        .byte $00 ; = STICK0 cooked to turn on direction bits + trigger
   453
   454 				; Identify the current event target.  This is what drives which timer/event loop
   455 				; features are in effect.  Value is enumerated from EVENT_LIST table.
   456 009A 00			CurrentEvent      .byte EVENT_INIT ; = identity of current event target.
   457
   458 				; Event values.  Use for counting things for each pass of a screen/event.
   459 009B 00			EventStage        .byte 0 ; An ID for directing multi-part events.
   460 009C 00			EventCounter      .byte 0
   461 009D 00			EventCounter2     .byte 0 ; Used for other counting, such as long event counting.
   462
   463 009E 00 00		BasePmgAddr       .word $0000 ; Pointer to base table per the current display.  Set by VBI.  Used by Main.
   464
   465 				; Miscellaneous temporary values.  Smells like the result of 
   466 				; lazy and stupid subroutine programming. 
   467 00A0			TempWipeColor     ; Used in a color update loop for splash screen.
   468 00A0			SavePF            ; Temp values for SliceColorAndLuma
   469 00A0			TempSaveColor     ; Yet another temp value for .. reasons
   470 00A0 00			ataTEMP1          .byte 0
   471
   472 00A1			SavePFC           ; Temp values for SliceColorAndLuma
   473 00A1			TempTargetColor   ; And another temp value.
   474 00A1 00			ataTEMP2          .byte 0
   475
   476 00A2			EverythingMatches ; Logical condition collection indicating all colors examined do match.
   477 								  ; Bits $10, $8, $4, $2, $1 for COLBK, COLPF0, COLPF1, COLPF2, COLPF3
   478 00A2 00			ataTEMP3          .byte 0
   479
   480 00A3 00 00		MainPointer1      .word $0000 ; Random use for Main code.
   481 00A5 00 00		MainPointer2      .word $0000 ; Random use for Main code.
   482
   483
   484 				; ======== D L I ======== DLI TABLES
   485 				; Pointer to current DLI address chain table.  (ThisDLIAddr),Y = DLI routine low byte.
   486 00A7 23 50		ThisDLIAddr       .word TITLE_DLI_CHAIN_TABLE  ; by default (VBI corrects this)
   487 				; Index read by the Display List Interrupts to change the colors for each line.
   488 				; Note that since entry 0 in the DLI chain tables is for the first entry set
   489 				; by the VBI, the VBI starts the counter for DLI operation at 1 instead of 0
   490 00A9 00			ThisDLI           .byte $00   ; = counts the instance of the DLI for indexing into the color tables.
   491
   492 				; For speed reasons (I think)  the next DLI's values are pre-loaded into zero page.
   493 00AA 00			ColorBak          .byte $00 ; Attempt at optimization to save tya; pha; ldy $, lda $,y....
   494 00AB 00			ColorPF0          .byte $00   
   495 00AC 00			ColorPF1          .byte $00   
   496 00AD 00			ColorPF2          .byte $00   
   497 00AE 00			ColorPF3          .byte $00  
   498 00AF 00			NextHSCROL        .byte $00
   499
   500
   501 				; ======== V B I ======== TIMER FOR MAIN CODE
   502 				; Frame counter set by main code events for delay/speed of main activity.
   503 				; The VBI decrements this value until 0.
   504 				; Main code acts on value 0.
   505 00B0 00			AnimateFrames     .byte $00 
   506 00B1 00			AnimateFrames2    .byte $00
   507 00B2 00			AnimateFrames3    .byte $00  ; WobbleDeWobble
   508 00B3 00			AnimateFrames4    .byte $00  ; Title Label flash
   509
   510 				; ======== V B I ======== MANAGE DISPLAY LISTS
   511 				; DISPLAY_TITLE = 0
   512 				; DISPLAY_GAME  = 1
   513 				; DISPLAY_WIN   = 2
   514 				; DISPLAY_DEAD  = 3
   515 				; DISPLAY_OVER  = 4
   516 				; A display number written here by main code directs the VBI to update the
   517 				; screen pointers and the pointers to the color tables. Updated by VBI to
   518 				; $FF when update is completed.
   519 00B4 FF			VBICurrentDL      .byte $FF ; !$FF = Direct VBI to change to new display.
   520 00B5 00			CurrentDL         .byte DISPLAY_TITLE
   521
   522
   523 				; ======== V B I ======== SCROLLING TITLE MANAGEMENT
   524 00B6 00			VBIEnableScrollTitle .byte $00 ; Flag from Main to VBI to direct to start scrolling. VBI will clear.
   525 00B7 00			TitleHSCROL          .byte $00 ; HSCROLL for title graphics
   526 00B8 00			RestoreTitleTimer    .byte $00 ; After scroll is done, wait this long to return to title.
   527
   528
   529 				; ======== V B I ======== SCROLLING CREDITS MANAGEMENT
   530 				; VBI's Animation counter for scrolling the credit line. when it reaches 0, then scroll.
   531 00B9 02			ScrollCounter     .byte 2
   532 00BA 04			CreditHSCROL      .byte 4  ; Fine scrolling the credits
   533
   534
   535 				; ======== V B I ======== FROG EYEBALL MOVEMENT
   536 				; Eye positions:
   537 				;  - 3 -
   538 				;  0 1 2
   539 				;  - - -
   540 00BB 01			FrogEyeball       .byte 1         ; Image for the Frog Eyeballs. (1) position is default.
   541 00BC 00			FrogRefocus       .byte 0         ; Countdown timer to return the eyeballs to the normal position. (1)
   542
   543
   544 				; ======== V B I ======== SCROLLING BOAT MANAGEMENT
   545 				; FYI -- SCROLLING RANGE
   546 				; Boats Right ;   64
   547 				; Start Scroll position = LMS + 12 (decrement), HSCROL 0  (Increment)
   548 				; End   Scroll position = LMS + 0,              HSCROL 15
   549 				; Boats Left ; + 64 
   550 				; Start Scroll position = LMS + 0 (increment), HSCROL 15  (Decrement)
   551 				; End   Scroll position = LMS + 12,            HSCROL 0
   552 				; Keep Current Address for LMS, and index to HSCROL_TABLE
   553
   554 				; Boat movements are managed by the VBI.
   555 				; The frame count value comes from BOAT_FRAMES based on the number of 
   556 				; frogs that crossed the river (FrogsCrossed) (0 to 10 difficulty level).
   557 				;CurrentRowLoop     .byte 0   ; Count from 0 to 18 in VBI
   558 = 00BD			CurrentBoatFrames  .ds   19  ; How many frames does each row wait?
   559 				; Count frames until next boat movement. (Note that 0 correctly means move every frame).
   560 00D0-00FB> 33 22		BoatFramesPointer  .word BOAT_FRAMES 
   561 				; How many color clocks did boats move on this frame (to move the frog accordingly)
   562 00D2 B2 22		BoatMovePointer    .word BOAT_SHIFT
   563
   564
   565 				; ======== V B I ======== BOAT ANIMATED COMPONENTS
   566 				; VBI's Animation counter for changing one of the animation parts of the boats.
   567 				; (Front water spray, back water spray, either left or right boats.)  
   568 				; Every 2 frames one of these components are updated, and then at the next 
   569 				; turn the next component is updated.  Therefore only one component may be 
   570 				; updated in a VBI.
   571 				; This would animate each component at 8 frames per image update. 
   572 00D4 02			BoatyMcBoatCounter .byte 2  ; decrement.  On 0 animate a component.
   573 00D5 00			BoatyComponent     .byte 0  ; 0, 1, 2, 3 one of the four boat parts.
   574 00D6 00			BoatyFrame         .byte 0  ; counts 0 to 7.
   575
   576 				; Need a pointer for random uses?
   577 00D7 00 00		VBIPointer1        .word $0000
   578 00D9 00 00		VBIPointer2        .word $0000
   579
   580
   581 				; ======== V B I ======== PRESS A BUTTON MANAGEMENT
   582 				; ON/Off status of the Press A Button Prompt. 
   583 				; Main code sets 0 to turn it off.
   584 				; Main code sets 1 to turn it on. 
   585 				; Visibility actions performed by VBI.
   586 00DB 00			EnablePressAButton .byte 0
   587 00DC 00			PressAButtonState  .byte 0           ; 0 means fading background color down. !0 means fading up.
   588 00DD 03			PressAButtonFrames .byte BLINK_SPEED ; Timer value for Press A Button Prompt updating.
   589 00DE 00			PressAButtonColor  .byte 0           ; The actual color of the prompt.
   590 00DF 00			PressAButtonText   .byte 0           ; The text luminance.
   591
   592
   593 				; ======== V B I ======== The world's most inept sound system. 
   594
   595 				; Pointer used by the VBI service routine for the current sequence under work:
   596 00E0 00 00		SOUND_POINTER .word $0000
   597
   598 				; Pointer to the sound entry in use for each voice.
   599 00E2			SOUND_FX_LO
   600 00E2 00			SOUND_FX_LO0 .byte 0
   601 00E3 00			SOUND_FX_LO1 .byte 0
   602 00E4 00			SOUND_FX_LO2 .byte 0
   603 00E5 00			SOUND_FX_LO3 .byte 0 
   604
   605 00E6			SOUND_FX_HI
   606 00E6 00			SOUND_FX_HI0 .byte 0
   607 00E7 00			SOUND_FX_HI1 .byte 0
   608 00E8 00			SOUND_FX_HI2 .byte 0
   609 00E9 00			SOUND_FX_HI3 .byte 0 
   610
   611 				; Sound Control value coordinates between the main process and the VBI 
   612 				; service routine to turn on/off/play sounds. Control Values:
   613 				; 0   = Set by Main to direct VBI to stop managing sound pending an 
   614 				;       update from MAIN. This does not stop the POKEY's currently 
   615 				;       playing sound.  It is set by the VBI when a sequence is complete 
   616 				;       to indicate the channel is idle/unmanaged. 
   617 				; 1   = MAIN sets to direct VBI to start playing a new sound FX.
   618 				; 2   = VBI sets when it is playing to inform MAIN that it has taken 
   619 				;       direction and is now busy.
   620 				; 255 = Direct VBI to silence the channel immediately.
   621 				;
   622 				; So, the procedure for playing sound.
   623 				; 1) MAIN sets the channel's SOUND_CONTROL to 0.
   624 				; 2) MAIN sets the channel's SOUND_FX_LO/HI pointer to the sound effects 
   625 				;    sequence to play.
   626 				; 3) MAIN sets the channel's SOUND_CONTROL to 1 to tell VBI to start.
   627 				; 4) VBI sets the channel's SOUND_CONTROL value to 2 when playing, then 
   628 				;    when the sequence is complete, back to value 0.
   629
   630 00EA			SOUND_CONTROL
   631 00EA 00			SOUND_CONTROL0  .byte $00
   632 00EB 00			SOUND_CONTROL1  .byte $00
   633 00EC 00			SOUND_CONTROL2  .byte $00
   634 00ED 00			SOUND_CONTROL3  .byte $00
   635
   636 				; When these are non-zero, the current settings continue for the next frame.
   637 00EE			SOUND_DURATION
   638 00EE 00			SOUND_DURATION0 .byte $00
   639 00EF 00			SOUND_DURATION1 .byte $00
   640 00F0 00			SOUND_DURATION2 .byte $00
   641 00F1 00			SOUND_DURATION3 .byte $00
   642
   643
   644 				; ======== D I S P L A Y   L I S T ======== EVILNESS
   645 				; Each display list (except the game screen) ends with a JMP to 
   646 				; here, BOTTOM_OF_DISPLAY.  These Display List instructions 
   647 				; provide the Press A Button prompt and the scrolling credit lines.
   648 				; The GAME screen jumps to the DL_SCROLLING_CREDIT location, 
   649 				; because it does not need the prompt.
   650 				;
   651 				; This laziness provides a constant, common DL section.  Only one 
   652 				; set of code is needed to manage the credit fine scrolling on 
   653 				; every Display.  If each Display List had its own instructions for 
   654 				; the credit line, then there would need to be more complicated 
   655 				; code using a lookup table to grab addresses for the credit line's 
   656 				; LMS based on the current display list in use.
   657 				; 
   658 				; Having one, common Display List code pointing to the scrolling text 
   659 				; also eliminates any possibility of the text glitching when switching 
   660 				; between displays.   
   661
   662 00F2			BOTTOM_OF_DISPLAY                                 ; Prior to this DLI SPC1 set colors and HSCROL
   663 00F2				mDL_LMS DL_TEXT_2,ANYBUTTON_MEM               ; (190-197) (+0 to +7)   Prompt to start game.
Macro: MDL_LMS [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/ANTIC.asm]
     5 = 0002				MDL_TEMP=DL_TEXT_2&$0F
    11 00F2 42				.byte DL_TEXT_2|DL_LMS
    12 00F3 40 49			.word ANYBUTTON_MEM   
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03.asm
   664 00F5 80				.by DL_BLANK_1|DL_DLI                         ; (198)     (+8)         DLI SPC2, set COLBK/COLPF2/COLPF1 for scrolling text.
   665 00F6			DL_SCROLLING_CREDIT
   666 = 00F7			SCROLL_CREDIT_LMS = [* + 1]
   667 00F6				mDL_LMS DL_TEXT_2|DL_HSCROLL,SCROLLING_CREDIT ; (199-206) (+9 to +16)  The perpetrators identified
Macro: MDL_LMS [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/ANTIC.asm]
     5 = 0002				MDL_TEMP=DL_TEXT_2|DL_HSCROLL&$0F
    11 00F6 52				.byte DL_TEXT_2|DL_HSCROLL|DL_LMS
    12 00F7 00 47			.word SCROLLING_CREDIT   
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03.asm
   668 				; Note that as long as the system VBI is functioning the address 
   669 				; provided for JVB does not matter at all.  The system VBI will update
   670 				; ANTIC after this using the address in the shadow registers (SDLST)
   671 00F9				mDL_JVB TITLE_DISPLAYLIST        ; Restart display.
Macro: MDL_JVB [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/ANTIC.asm]
     6 00F9 41				.byte DL_JUMP_VB
     7 00FA 00 46			.word TITLE_DISPLAYLIST   
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03.asm
   672
   673
   674 				; In the event stupid programming tricks means some things can't be saved on 
   675 				; the stack, then protect them here....
   676 = 00FD			SAVEA = $FD
   677 = 00FE			SAVEX = $FE
   678 = 00FF			SAVEY = $FF
   679
   680 				; ======== E N D   O F   P A G E   Z E R O ======== 
   681
   682 				; Now for the Game Code and Data...
   683 				; Should be the first usable memory after DOS (and DUP?).
   684
   685 00FC				ORG LOMEM_DOS
   686 				;	ORG LOMEM_DOS_DUP ; Use this if following DOS won't work.  or just use $5000
   687
   688 					; Label And Credit Where Ultimate Credit Is Due
   689 2000-2A7C> 2A 2A 20 54 + 	.by "** Thanks to the Word (John 1:1), Creator of heaven, and earth, and "
   690 2044 73 65 6D 69 63 6F + 	.by "semiconductor chemistry and physics making all this fun possible. "
   691 2086 2A 2A 20 44 61 6C + 	.by "** Dales" ATASCII_HEART "ft PET FROGGER by John C. Dale, November 1983. "
   692 20BE 2A 2A 20 41 74 61 + 	.by "** Atari port by Ken Jennings, August 2019, Version 03. "
   693 20F6 2A 2A 20 49 6D 70 + 	.by "** Improved graphics for the playfield and frog. "
   694 2127 46 69 6E 65 20 53 + 	.by "Fine Scrolling Boats. Custom character set for boats. "
   695 215D 50 6C 61 79 65 72 + 	.by "Player/Missile Frog. "
   696 2172 43 75 73 74 6F 6D + 	.by "Customized Display Lists and DLIs. "
   697 2195 4D 6F 73 74 20 67 + 	.by "Most game logic moved to VBI. "
   698 21B3 2A 2A 20 53 70 65 + 	.by "** Special Thanks to playtesters "
   699 21D4 2D 54 68 65 20 44 + 	.by "-The Doctor-, Philsan, Faicuai, and Mclaneinc. **"
   700
   701
   702 				; ==========================================================================
   703 				; Include the Main Code Parts
   704 				; --------------------------------------------------------------------------
   705
   706 2205				icl "Frogger03Game.asm"         ; GAMESTART and Game event loop in this file
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03Game.asm
     1 				; ==========================================================================
     2 				; Pet Frogger
     3 				; (c) November 1983 by John C. Dale, aka Dalesoft
     4 				; for the Commodore Pet 4032
     5 				; ==========================================================================
     6 				; Ported (parodied) to Atari 8-bit computers
     7 				; by Ken Jennings (if this were 1983, aka FTR Enterprises)
     8 				; ==========================================================================
     9 				; Version 00, November 2018
    10 				; Version 01, December 2018
    11 				; Version 02, February 2019
    12 				; Version 03, August 2019
    13 				; ==========================================================================
    14
    15 2205			EVENT_TARGET_TABLE
    16 2205 C4 25			.word EventGameInit-1           ; 0  = EVENT_INIT
    17 2207 39 26			.word EventScreenStart-1        ; 1  = EVENT_START
    18 2209 4E 26			.word EventTitleScreen-1        ; 2  = EVENT_TITLE
    19 220B F2 26			.word EventTransitionToGame-1   ; 3  = EVENT_TRANS_GAME
    20 220D 63 27			.word EventGameScreen-1         ; 4  = EVENT_GAME    
    21 220F B6 27			.word EventTransitionToWin-1    ; 5  = EVENT_TRANS_WIN 
    22 2211 BA 27			.word EventWinScreen-1          ; 6  = EVENT_WIN      
    23 2213 E5 27			.word EventTransitionToDead-1   ; 7  = EVENT_TRANS_DEAD  
    24 2215 0C 28			.word EventDeadScreen-1         ; 8  = EVENT_DEAD      
    25 2217 42 28			.word EventTransitionGameOver-1 ; 9  = EVENT_TRANS_OVER 
    26 2219 4F 28			.word EventGameOverScreen-1     ; 10 = EVENT_OVER      
    27 221B 12 26			.word EventTransitionToTitle-1  ; 11 = EVENT_TRANS_TITLE
    28
    29
    30 				; ==========================================================================
    31 				; The Game Entry Point where AtariDOS calls for startup.
    32 				; 
    33 				; And the perpetual loop calling the game's event dispatch routine.
    34 				; The code needs this routine as a starting place, so that the 
    35 				; routines called from the subroutine table have a place to return
    36 				; to.  Otherwise the RTS from those routines would be at the 
    37 				; top level and exit the game.
    38 				; --------------------------------------------------------------------------
    39
    40 221D			GameStart
    41
    42 221D 20 23 22			jsr GameLoop 
    43
    44 2220 4C 1D 22			jmp GameStart ; Do While More Electricity
    45
    46
    47 				; ==========================================================================
    48 				; GAME LOOP
    49 				;
    50 				; The main event dispatch loop for the game... said Capt Obvious.
    51 				; Very vaguely like an event loop or state loop across the progressive
    52 				; game states which are (loosely) based on the current mode of
    53 				; the display.
    54 				;
    55 				; Each event sets CurrentEvent to change to another event target.
    56 				; --------------------------------------------------------------------------
    57
    58 2223			GameLoop
    59
    60 2223 20 17 29			jsr libScreenWaitFrame     ; Wait for end of frame, start of new frame.
    61
    62 				; Due to the frame sync above, at this point the code
    63 				; is running at/near the top of the screen refresh.
    64
    65 2226 A5 9A			lda CurrentEvent           ; Get the current event
    66 2228 0A				asl                        ; Times 2 for size of address
    67 2229 AA				tax                        ; Use as index
    68
    69 222A BD 06 22			lda EVENT_TARGET_TABLE+1,x ; Get routine high byte
    70 222D 48				pha                        ; Push to stack
    71 222E BD 05 22			lda EVENT_TARGET_TABLE,x   ; Get routine low byte 
    72 2231 48				pha                        ; Push to stack
    73
    74 2232 60				rts                        ; Forces calling the address pushed on the stack.
    75
    76 					; When the called routine ends with rts, it will return to the place 
    77 					; that called this routine which is up in GameStart.
    78
    79 				; ==========================================================================
    80 				; END OF GAME EVENT LOOP
    81 				; --------------------------------------------------------------------------
    82
   707 2233				icl "Frogger03GameSupport.asm"  ; Score and Frog management
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03GameSupport.asm
     1 				; ==========================================================================
     2 				; Pet Frogger
     3 				; (c) November 1983 by John C. Dale, aka Dalesoft
     4 				; for the Commodore Pet 4032
     5 				; ==========================================================================
     6 				; Ported (parodied) to Atari 8-bit computers
     7 				; by Ken Jennings (if this were 1983, aka FTR Enterprises)
     8 				; ==========================================================================
     9 				; Version 00, November 2018
    10 				; Version 01, December 2018
    11 				; Version 02, February 2019
    12 				; Version 03, August 2019
    13 				; ==========================================================================
    14
    15 				; ==========================================================================
    16 				; GAME SUPPORT
    17 				; ==========================================================================
    18 				;
    19 				; Miscellaneous supporting data.
    20 				; Clear game scores.
    21 				; Add 500 to game score (and increment saved Frogs)
    22 				; Add 10 to game score.
    23 				; Determine if current score is high score
    24 				; Move the frog up a row.
    25 				; Automatic, logical frog horizontal movement when boats move.
    26 				; Set boats' speed based on number of frogs saved.
    27 				;
    28 				; --------------------------------------------------------------------------
    29
    30 				; ==========================================================================
    31 				; Originally, this was coarse scroll movement and the frog moved the 
    32 				; width of a character.  
    33 				; Based on number of frogs, how many frames between the boats' 
    34 				; character-based coarse scroll movement:
    35 				; ANIMATION_FRAMES .byte 30,25,20,18,15,13,11,10,9,8,7,6,5,4,3
    36 				;
    37 				; Fine scroll increments 4 times to equal one character 
    38 				; movement per timer above. Frog movement is two color clocks,
    39 				; or half a character per horizontal movement.
    40 				;
    41 				; Minimum coarse scroll speed was 2 characters per second, or 8 
    42 				; color clocks per second, or between 7 and 8 frames per color clock.
    43 				; The fine scroll will start at 7 frames per color clock.
    44 				;
    45 				; Maximum coarse scroll speed (3 frames == 20 character movements 
    46 				; per second) was the equivalent of 4 color clocks in 3 frames.
    47 				; The fine scroll speed will max out at 3 color clockw per frame.
    48 				;
    49 				; The Starting speed is slower than the coarse scrolling version.
    50 				; It ramps up to maximum speed in fewer levels/rescued frogs, and 
    51 				; the maximum speed is faster than the fastest coarse scroll
    52 				; speed (60 FPS fine scroll is faaast.)
    53
    54 				; FYI -- SCROLLING RANGE
    55 				; Boats Right ;   64
    56 				; Start Scroll position = LMS + 12 (decrement), HSCROL 0  (Increment)
    57 				; End   Scroll position = LMS + 0,              HSCROL 15
    58 				; Boats Left ; + 64 
    59 				; Start Scroll position = LMS + 0 (increment), HSCROL 15  (Decrement)
    60 				; End   Scroll position = LMS + 12,            HSCROL 0
    61
    62 				; Difficulty Progression Enhancement.... Each row can have its own frame 
    63 				; counter and scroll distance. 
    64 				; (and by making rows closer to the bottom run faster it produces a 
    65 				; kind of parallax effect. almost).
    66
    67 				; Possible scrolling speeds:
    68 				; Speed 3  (Maybe as exciting as "meh".)
    69 				; 6 Frames per 1 pixel/color clock scroll
    70 				; NTSC 10 pixels/second (2.5 characters/second.)
    71 				; PAL  8.3 pixels/second (about two characters/second.)
    72
    73 				;Speed 4  (Good enough for small kids?)
    74 				;5 Frames per 1 pixel/color clock scroll
    75 				;NTSC 12 pixels/second (3 characters/second.)
    76 				;PAL  10 pixels/second (2.5 characters/second.)
    77
    78 				;Speed 5 (15 fps is entering the range of actual animation)
    79 				;4 Frames per 1 pixel/color clock scroll
    80 				;NTSC 15 pixels/second (4 characters/second.)
    81 				;PAL  12.5 pixels/second (about 3 characters/second.)
    82
    83 				;Speed 6
    84 				;3 Frames per 1 pixel/color clock scroll
    85 				;NTSC 20 pixels/second (5 characters/second.) (about one boat length)
    86 				;PAL  16.6 pixels/second (about 4 characters/second.)
    87
    88 				;Speed 7
    89 				;2 Frames per 1 pixel/color clock scroll
    90 				;NTSC 30 pixels/second (7.5 characters/second.)
    91 				;PAL  25 pixels/second (about 6 characters/second.)
    92
    93 				;Speed 8
    94 				;1 Frames per 1 pixel/color clock scroll
    95 				;NTSC 60 pixels/second (15 characters/second.)
    96 				;PAL  50 pixels/second (12.5 characters/second.)
    97
    98 = 0006			MAX_FROG_SPEED = 6 ; Number of difficulty levels (which means 7)
    99 = 0007			MAX_FROG_LIVES = 7  ; Maximum number of starting frog lives.
   100
   101 				; SO, per playtesters speeds 1 to 3 are painfully slow.
   102 				; 10 and 11 are Spaceballs "ludicrous" speed.  Therefore, 
   103 				; these are eliminated from the list.   Speeds 4 through 9 
   104 				; are used.
   105
   106 				; About the arrays below.  18 bytes per row instead of 19:
   107 				; FrogRow ranges from 0 to 18 which is 19 rows.  The first and
   108 				; last rows are always have values 0.  When reading a row from the array,
   109 				; the index will overshoot the end of a row (18th entry) and read the 
   110 				; beginning of the next row as the 19th entry.  Since both always 
   111 				; use values 0, they are logically overlapped.  Therefore, each array 
   112 				; row needs only 18 bytes instead of 19.  Only the last row needs 
   113 				; the trailing 19th 0 added.
   114 				; 14 difficulty levels is the max, because of 6502 indexing.
   115 				; 18 bytes per row * 14 levels is 252 bytes.
   116 				; More levels would require more pointer expression to reach each row
   117 				; rather than simply (BOAT_FRAMES),Y.
   118
   119 2233			BOAT_FRAMES ; Number of frames to wait to move boat. (top to bottom) (Difficulty 0 to 13)
   120 2233 00 05 05 00 05 05 + 	.by 0 5 5 0 5 5 0 5 5 0 5 5 0 5 5 0 5 5   ; Difficulty 0 
   121 2245 00 05 05 00 04 05 + 	.by 0 5 5 0 4 5 0 4 4 0 4 5 0 4 5 0 4 4   ; Difficulty 1 
   122 2257 00 04 04 00 03 04 + 	.by 0 4 4 0 3 4 0 3 3 0 4 3 0 3 4 0 3 3   ; Difficulty 2
   123 2269 00 03 03 00 02 03 + 	.by 0 3 3 0 2 3 0 2 2 0 3 2 0 2 3 0 2 2   ; Difficulty 3 
   124 227B 00 02 02 00 01 02 + 	.by 0 2 2 0 1 2 0 1 1 0 2 1 0 1 2 0 1 1   ; Difficulty 4 
   125 228D 00 01 01 00 00 01 + 	.by 0 1 1 0 0 1 0 0 0 0 1 0 0 0 1 0 0 0   ; Difficulty 5 
   126 229F 00 00 00 00 00 00 + 	.by 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ; Difficulty 6 
   127
   128 22B2			BOAT_SHIFT  ; Number of color clocks to scroll boat. (add or subtract)
   129 22B2 00 01 01 00 01 01 + 	.by 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1   ; Difficulty 0
   130 22C4 00 01 01 00 01 01 + 	.by 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1   ; Difficulty 1
   131 22D6 00 01 01 00 01 01 + 	.by 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1   ; Difficulty 2
   132 22E8 00 01 01 00 01 01 + 	.by 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1   ; Difficulty 3
   133 22FA 00 01 01 00 01 01 + 	.by 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1   ; Difficulty 4
   134 230C 00 01 01 00 01 01 + 	.by 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1   ; Difficulty 5
   135 231E 00 01 01 00 01 01 + 	.by 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 ; Difficulty 6
   136
   137 2331			MOVING_ROW_STATES ; 19 entries describing boat directions. Beach (0), Right (1), Left (FF) directions.
   138 2331 00 01 FF 00 01 FF + 	.by 0 1 $FF 0 1 $FF 0 1 $FF 0 1 $FF 0 1 $FF 0 1 $FF 0
   139
   140 = 0019			PM_OFFS = 25 ; offset to line up P/M Vertical Y line to Playfield scan line
   141
   142 2344			FROG_PMY_TABLE ; 19 entries providing Frog Y position for each row.  (Each row is no longer equal size.)
   143 2344 2A 33 3D			.by [ 17+PM_OFFS] [ 26+PM_OFFS] [ 36+PM_OFFS] ; Beach, Boat Right, Boat Left
   144 2347 46 4F 59			.by [ 45+PM_OFFS] [ 54+PM_OFFS] [ 64+PM_OFFS] 
   145 234A 62 6B 75			.by [ 73+PM_OFFS] [ 82+PM_OFFS] [ 92+PM_OFFS] 
   146 234D 7E 87 91			.by [101+PM_OFFS] [110+PM_OFFS] [120+PM_OFFS] 
   147 2350 9A A3 AD			.by [129+PM_OFFS] [138+PM_OFFS] [148+PM_OFFS] 
   148 2353 B6 BF C9			.by [157+PM_OFFS] [166+PM_OFFS] [176+PM_OFFS] 
   149 2356 D2				.by [185+PM_OFFS]                             ; Home Beach
   150
   151
   152 				; ==========================================================================
   153 				; FROG MOVE UP
   154 				; ==========================================================================
   155 				; Add 10 to the score.
   156 				; Decrement the Row counter.
   157 				; Set new Frog screen position.
   158 				;
   159 				; On return BEQ means the frog has reached safety. (Row 0)
   160 				; Thus BNE means continue game.
   161 				;
   162 				; FROG_PMY_TABLE is the lookup for vertical positions, because each row 
   163 				; on screen is not equal height.  Rather than a pile of logical comparisons
   164 				; and math the resulting values are put in the table.
   165 				; 
   166 				; Uses A, X
   167 				;
   168 				; Returns Row number, and Z flag indicates game can continue.
   169 				; --------------------------------------------------------------------------
   170
   171 2357			FrogMoveUp
   172
   173 2357 20 E4 23			jsr Add10ToScore     ; 10 points for moving forward.
   174
   175 235A A6 80			ldx FrogRow          ; Get the current Row number
   176 235C F0 01			beq bFMU_SkipDex     ; Already 0.
   177 235E CA				dex                  ; Minus 1 row.
   178 235F			bFMU_SkipDex
   179 235F 86 81			stx FrogNewRow       ; Save new Row Number. 
   180 2361 BD 44 23			lda FROG_PMY_TABLE,x ; Get the new Player/Missile Y position based on row number.
   181 2364 85 83			sta FrogNewPMY       ; Update Frog position on screen. 
   182
   183 2366 A5 81			lda FrogNewRow       ; Tell caller the new row number.
   184
   185 2368 60				rts
   186
   187
   188 				; ==========================================================================
   189 				; FROG EYE FOCUS
   190 				; ==========================================================================
   191 				; The Frog's eyes move based on the joystick input direction.
   192 				; Default position for the eyes is #1.
   193 				;
   194 				; Eye positions:
   195 				;  - 3 -
   196 				;  0 1 2
   197 				;  - - -
   198 				;
   199 				; Set the eye position.
   200 				; Set the Timer for how long the eye will remain at that position 
   201 				; before returning to the default.
   202 				; Flag the mandatory redraw notification for the VBI.
   203 				;
   204 				; A is the Eye position.
   205 				; --------------------------------------------------------------------------
   206
   207 2369			FrogEyeFocus
   208
   209 2369 85 BB			sta FrogEyeball ; Set the eyeball shape.
   210 236B A9 3C			lda #60         ; Set one second timer.
   211 236D 85 BC			sta FrogRefocus
   212 236F E6 88			inc FrogUpdate  ; Set mandatory Frog Update on next frame.
   213
   214 2371 60				rts
   215
   216
   217 				; ==========================================================================
   218 				; CLEAR GAME SCORES
   219 				; ==========================================================================
   220 				; The high score is un-flagged to clear it for the following reasons:
   221 				; - The new number of lives is greater than the last game.
   222 				; - The new level start is less than the last game.
   223 				;
   224 				; Clear the score digits to zeros. (That is, internal screen code for "0".)
   225 				; If a high score is flagged, then do not clear the high score.
   226 				; And some other things at game start.
   227 				; --------------------------------------------------------------------------
   228
   229 2372			ClearGameScores
   230
   231 2372 A5 8F			lda NewNumberOfLives 
   232 2374 C5 90			cmp LastNumberOfLives
   233 2376 F0 02			beq bCGS_TestLevel         ; New == Last, do Level test
   234 2378 B0 08			bcs bCGS_UnflagHiScore     ; New > Last.  REset high score.
   235
   236 237A			bCGS_TestLevel
   237 237A A5 8C			lda NewLevelStart 
   238 237C C5 8D			cmp LastLevelStart
   239 237E F0 0B			beq bCGS_SkipUnflagHiScore ; New == Last.  Do not unset high score.
   240 2380 B0 09			bcs bCGS_SkipUnflagHiScore
   241
   242 2382			bCGS_UnflagHiScore             ; Clear High Score Flag to trigger erasing high score.
   243 2382 A9 00			lda #0
   244 2384 85 93			sta FlaggedHiScore
   245 2386 A9 4F			lda #COLOR_PINK+$F        ; Strobe high score label.
   246 2388 8D 94 51			sta COLPM2_TABLE
   247
   248 238B			bCGS_SkipUnflagHiScore
   249
   250 238B A2 07			ldx #$07                   ; 8 digits. 7 to 0
   251 238D A9 10			lda #INTERNAL_0            ; Atari internal code for "0"
   252 				 
   253 238F			bCGS_LoopClearScores
   254 238F 9D DB 33			sta MyScore,x              ; Put zero/"0" in score buffer.
   255
   256 2392 A4 93			ldy FlaggedHiScore         ; Has a high score been flagged? ($FF)
   257 2394 30 03			bmi bCGS_NextScoreDigit    ; If so, then skip clearing Hi score and go to the next digit.
   258
   259 2396 9D E3 33			sta HiScore,x              ; Also put zero/"0" in the high score.
   260
   261 2399			bCGS_NextScoreDigit
   262 2399 CA				dex                        ; decrement index to score digits.
   263 239A 10 F3			bpl bCGS_LoopClearScores   ; went from 0 to $FF? no, loop for next digit.
   264
   265 					; Set current lives and current start level.
   266 					; The prior values are now set the same as the New/current game's.
   267 239C A5 8C			lda NewLevelStart
   268 239E 85 8D			sta LastLevelStart
   269 23A0 20 50 24			jsr MultiplyFrogsCrossed ; Multiply by 18, make index base, set difficulty address pointers.
   270
   271 23A3 A5 8F			lda NewNumberOfLives       ; Reset Number of 
   272 23A5 85 8E			sta NumberOfLives          ; lives to new game config.
   273 23A7 85 90			sta LastNumberOfLives
   274
   275 23A9 20 99 34			jsr StrobeScoreLabel       ; Strobe the score label.  VBI will decrement it.
   276 23AC 20 A2 34			jsr StrobeLivesLabel       ; And strobe the Lives counter label.
   277
   278 23AF 60				rts
   279
   280
   281 				; ==========================================================================
   282 				; ADD 500 TO SCORE
   283 				; ==========================================================================
   284 				; Add 500 to score.  (duh.)   Due to successful frog crossing.
   285 				;
   286 				; Isn't it interesting how the boats keep moving while the Main code 
   287 				; line is locked into waiting for sound to complete.
   288 				;
   289 				; Uses A, X
   290 				; --------------------------------------------------------------------------
   291
   292 23B0			Add500ToScore
   293
   294 23B0 E6 8A			inc FrogsCrossed        ; Add to frogs successfully crossed the rivers.
   295 23B2 20 AB 34			jsr StrobeSavedLabel    ; Glow the Saved label.  VBI will decrement it.
   296 23B5 20 10 34			jsr PrintFrogsAndLives  ; update the head count
   297
   298 23B8 A0 05			ldy #5 
   299
   300 23BA			bA5TS_loop
   301 23BA 20 CE 23			jsr Add100ToScore       ; What it says.  +100             (regs Saved in, restored out).
   302 23BD 20 EA 31			jsr PlayBling           ; Sound per each 100 point award. (regs Saved in, restored out).
   303 23C0 20 EB 33			jsr CopyScoreToScreen   ; Update the screen information.  (Uses A, X.)
   304
   305 23C3			ba5TS_AudioPause            ; Wait for audio to finish.
   306 23C3 A5 EB			lda SOUND_CONTROL1      ; Is channel 1 still busy?
   307 23C5 D0 FC			bne ba5TS_AudioPause    ; Yes.  Do While more electricity.
   308
   309 23C7 88				dey
   310 23C8 D0 F0			bne bA5TS_loop          ;  Loop 5 times for 500 points.
   311
   312 23CA 20 50 24			jsr MultiplyFrogsCrossed ; Multiply by 18, make index base, set difficulty address pointers.
   313
   314 23CD 60				rts
   315
   316
   317 				; ==========================================================================
   318 				; ADD 100 TO SCORE
   319 				; ==========================================================================
   320 				; Add 100 to score.  (duh.) 
   321 				; (Preserve  A X Y , because this is called from a loop elsewhere)
   322 				;
   323 				; Uses A, X
   324 				; --------------------------------------------------------------------------
   325
   326 23CE			Add100ToScore
   327
   328 23CE				mRegSaveAYX          ; Save A, X, and Y.
Macro: MREGSAVEAYX [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/macros.asm]
     1 23CE 48				PHA 
     2 23CF 98				TYA 
     3 23D0 48				PHA 
     4 23D1 8A				TXA 
     5 23D2 48				PHA 
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03GameSupport.asm
   329
   330 23D3 A9 01			lda #1            ; Represents "100" Since we don't need to add to the tens and ones columns.
   331 23D5 85 91			sta ScoreToAdd    ; Save to add 1
   332 23D7 A2 05			ldx #5            ; Offset from start of "00000*00" to do the adding.
   333 23D9 86 92			stx NumberOfChars ; Position offset in score.
   334 23DB 20 F0 23			jsr AddToScore    ; Deal with score update.
   335
   336 23DE				mRegRestoreAYX       ; Restore Y, X, and A
Macro: MREGRESTOREAYX [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/macros.asm]
     1 23DE 68				PLA 
     2 23DF AA				TAX 
     3 23E0 68				PLA 
     4 23E1 A8				TAY 
     5 23E2 68				PLA 
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03GameSupport.asm
   337
   338 23E3 60				rts
   339
   340
   341 				; ==========================================================================
   342 				; ADD 10 TO SCORE
   343 				; ==========================================================================
   344 				; Add 10 to score.  (duh.)
   345 				;
   346 				; Uses A, X
   347 				; --------------------------------------------------------------------------
   348
   349 23E4			Add10ToScore
   350
   351 23E4 A9 01			lda #1            ; Represents "10" Since we don't need to add to the ones column.
   352 23E6 85 91			sta ScoreToAdd    ; Save to add 1
   353 23E8 A2 06			ldx #6            ; Offset from start of "000000*0" to do the adding.
   354 23EA 86 92			stx NumberOfChars ; Position offset in score.
   355 23EC 20 F0 23			jsr AddToScore    ; Deal with score update.
   356
   357 23EF 60				rts
   358
   359
   360 				; ==========================================================================
   361 				; ADD TO SCORE
   362 				; ==========================================================================
   363 				; Add value in ScoreToAdd to the score at index position
   364 				; NumberOfChars in the score digits.
   365 				;
   366 				; A, Y, X registers  are preserved.
   367 				; --------------------------------------------------------------------------
   368
   369 23F0			AddToScore
   370
   371 23F0				mRegSaveAYX          ; Save A, X, and Y.
Macro: MREGSAVEAYX [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/macros.asm]
     1 23F0 48				PHA 
     2 23F1 98				TYA 
     3 23F2 48				PHA 
     4 23F3 8A				TXA 
     5 23F4 48				PHA 
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03GameSupport.asm
   372
   373 23F5 A6 92			ldx NumberOfChars    ; index into "00000000" to add score.
   374 23F7 A5 91			lda ScoreToAdd       ; value to add to the score
   375 23F9 18				clc
   376 23FA 7D DB 33			adc MyScore,x
   377 23FD 9D DB 33			sta MyScore,x
   378
   379 2400			EvaluateCarry            ; (re)evaluate if carry occurred for the current position.
   380 2400 BD DB 33			lda MyScore,x
   381 2403 C9 1A			cmp #[INTERNAL_0+10] ; Did math carry past the "9"?
   382 2405 90 0B			bcc ExitAddToScore   ; less than.  it did not carry. go to exit.
   383
   384 				; The score carried past "9", so it must be adjusted and
   385 				; the next/greater position is added.
   386 2407 E9 0A			sbc #10              ; Subtract 10 from current value (carry is already set)
   387 2409 9D DB 33			sta MyScore,x        ; update current position.
   388 240C CA				dex                  ; Go to previous position in score.
   389 240D FE DB 33			inc MyScore,x        ; Add 1 to carry to the previous digit.
   390 2410 D0 EE			bne EvaluateCarry    ; This cannot go from $FF to 0, so it must be not zero.
   391
   392 2412			ExitAddToScore           ; All done.
   393 2412 20 99 34			jsr StrobeScoreLabel ; Glow the score label.  VBI will decrement it.
   394
   395 2415 20 1E 24			jsr HighScoreOrNot   ; If My score is high score, then copy to high score. (and glow it if needed.)
   396
   397 2418				mRegRestoreAYX       ; Restore Y, X, and A
Macro: MREGRESTOREAYX [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/macros.asm]
     1 2418 68				PLA 
     2 2419 AA				TAX 
     3 241A 68				PLA 
     4 241B A8				TAY 
     5 241C 68				PLA 
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03GameSupport.asm
   398
   399 241D 60				rts
   400
   401
   402 				; ==========================================================================
   403 				; HIGH SCORE OR NOT
   404 				; ==========================================================================
   405 				; Figure out if My Score is the High Score.
   406 				; If so, then copy My Score to High Score.
   407 				;
   408 				; A  and  X  used.
   409 				; --------------------------------------------------------------------------
   410
   411 241E			HighScoreOrNot
   412
   413 241E A2 00			ldx #0
   414
   415 2420			CompareScoreToHighScore
   416 2420 BD E3 33			lda HiScore,x
   417 2423 DD DB 33			cmp MyScore,x
   418 2426 F0 03			beq ContinueCheckingScores  ; They are the same, keep trying
   419 2428 90 07			bcc CopyNewHighScore        ; Hi score less than My score.
   420 242A 60				rts                         ; Hi score greater than My Score.  stop checking.
   421
   422 242B			ContinueCheckingScores
   423 242B E8				inx
   424 242C E0 07			cpx #7                      ; Are all 7 digits tested?
   425 242E D0 F0			bne CompareScoreToHighScore ; No, then go do next digit.
   426 2430 60				rts                         ; Yes.  Done.
   427
   428 2431			CopyNewHighScore                ; It is a high score.
   429 2431 BD DB 33			lda MyScore,x               ; Copy my score to high score
   430 2434 9D E3 33			sta HiScore,x
   431 2437 E8				inx
   432 2438 E0 07			cpx #7                      ; Copy until the remaining 7 digits are done.
   433 243A D0 F5			bne CopyNewHighScore
   434
   435 243C 20 B4 34			jsr StrobeHiScoreLabel      ; Glow the high score label.  VBI will decrement it.
   436
   437 243F A9 FF			lda #$FF
   438 2441 85 93			sta FlaggedHiScore          ; Flag the high score. Score must have changed to get here.
   439
   440 				;ExitHighScoreOrNot
   441 2443 60				rts
   442
   443
   444 				; ==========================================================================
   445 				; DEC THIS COLOR OR NOT
   446 				; ==========================================================================
   447 				; Support code to optimize the tedium of managing four colors for the 
   448 				; status labels in seven memory locations.
   449 				;
   450 				; Given a color value in A, determine if it is a color (not 0) 
   451 				; and if the luminance value is not 6.
   452 				; If it can be decremented, then subtract 1.
   453 				;
   454 				; Return result in CPU Flags.  0 = Do Not.   !0 = Do decrement.
   455 				;
   456 				; A   is the color to test/update.
   457 				; X   ia used for temporary storage and decrementing.
   458 				; --------------------------------------------------------------------------
   459
   460 2444			DecThisColorOrNot
   461
   462 2444 AA				tax                        ; Save original value.
   463 2445 F0 08			beq ReallyExitFromDecColor ; If 0, then done, no need to restore.
   464
   465 2447 29 0F			and #$0F                   ; Remove color component
   466 2449 C9 06			cmp #STATUS_LUMA           ; Is luminance 6?
   467 244B F0 01			beq ExitDecThisColorOrNot  ; No.  
   468
   469 244D CA				dex                        ; Decrement saved value.
   470
   471 244E			ExitDecThisColorOrNot
   472 244E 8A				txa                        ; Get original value.  Unless it was decremented, then it is different.
   473
   474 244F			ReallyExitFromDecColor
   475 244F 60				rts
   476
   477
   478 				; ==========================================================================
   479 				; MULTIPLY FROGS CROSSED
   480 				; ==========================================================================
   481 				; 1) FrogsCrossed + NewLevelStart == Current Difficulty (FrogsCrossedIndex)
   482 				; 2) Multiply FrogsCrossedIndex times 18 and save. 
   483 				; This determines the base entry in the difficulty arrays that control each 
   484 				; boat's speed on screen.
   485 				;
   486 				; Uses A
   487 				; -------------------------------------------------------------------------- 
   488
   489 2450			MultiplyFrogsCrossed
   490
   491 2450 A5 8A			lda FrogsCrossed           ; How many Frogs saved?
   492 2452 18				clc                        ; Plus...
   493 2453 65 8C			adc NewLevelStart          ; the starting difficulty level.
   494 2455 C9 07			cmp #MAX_FROG_SPEED+1      ; Number of difficulty levels. 0 to 8 OK.  9 not so much
   495 2457 90 02			bcc bMFC_SkipLimitCrossed  ; Exceeded the number of levels?
   496 2459 A9 06			lda #MAX_FROG_SPEED        ; Yes.  Reset to max level.
   497
   498 245B			bMFC_SkipLimitCrossed
   499 245B 0A				asl                        ; Times 2
   500 245C 85 8B			sta FrogsCrossedIndex      ; Save Times 2
   501 245E 0A				asl                        ; Times 4
   502 245F 0A				asl                        ; Times 8
   503 2460 0A				asl                        ; Times 16
   504 2461 18				clc
   505 2462 65 8B			adc FrogsCrossedIndex      ; Add to self (*2) + (*16) == (*18)
   506 2464 85 8B			sta FrogsCrossedIndex      ; And Save Times 18
   507
   508 2466 20 6A 24			jsr MakeDifficultyPointers ; Set pointers to the array row for the difficulty values.
   509
   510 2469 60				rts
   511
   512
   513 				; ==========================================================================
   514 				; MAKE DIFFICULTY POINTERS
   515 				; ==========================================================================
   516 				; Get the Address of the start of the current difficulty data.
   517 				; These are the BOAT_FRAMES and BOAT_SHIFT base addresses plus the 
   518 				; FrogsCrossedIndex. 
   519 				; From Here the code can use the FrogRow as Y index and reference the 
   520 				; master data by (ZeroPage),Y.
   521 				; 
   522 				; Uses A
   523 				; -------------------------------------------------------------------------- 
   524
   525 246A			MakeDifficultyPointers
   526
   527 					; BoatFramesPointer = BOATFRAMES + FrogsCrossedIndex (multiplied by 18)
   528
   529 246A A9 33			lda #<BOAT_FRAMES       ; Add low byte of the Frames base address
   530 246C 18				clc
   531 246D 65 8B			adc FrogsCrossedIndex   ; To the current index
   532 246F 85 D0			sta BoatFramesPointer   ; Save as pointer to the frames array.
   533 2471 A9 22			lda #>BOAT_FRAMES       ; and add high byte of the Frames base address
   534 2473 69 00			adc #0
   535 2475 85 D1			sta BoatFramesPointer+1 ; Save as pointer to the frames array.
   536
   537 					; BoatMovePointer = BOAT_SHIFT + FrogsCrossedIndex (multiplied by 18)
   538
   539 2477 A9 B2			lda #<BOAT_SHIFT        ; Add low byte of the movement base address
   540 2479 18				clc
   541 247A 65 8B			adc FrogsCrossedIndex   ; To the current index
   542 247C 85 D2			sta BoatMovePointer     ; Save as pointer to the shift/speed array.
   543 247E A9 22			lda #>BOAT_SHIFT        ; and add high byte of the Frames base address
   544 2480 69 00			adc #0
   545 2482 85 D3			sta BoatMovePointer+1   ; Save as pointer to the shift/speed array.
   546
   547 2484 60				rts
   548
   708
   709 2485				icl "Frogger03EventSetups.asm"  ; Set Entry criteria for the event/screen
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03EventSetups.asm
     1 				; ==========================================================================
     2 				; Pet Frogger
     3 				; (c) November 1983 by John C. Dale, aka Dalesoft
     4 				; for the Commodore Pet 4032
     5 				; ==========================================================================
     6 				; Ported (parodied) to Atari 8-bit computers
     7 				; by Ken Jennings (if this were 1983, aka FTR Enterprises)
     8 				; ==========================================================================
     9 				; Version 00, November 2018
    10 				; Version 01, December 2018
    11 				; Version 02, February 2019
    12 				; Version 03, August 2019
    13 				; ==========================================================================
    14
    15 				; ==========================================================================
    16 				; SETUPS
    17 				; ==========================================================================
    18 				; All the routines to move to a different screen/event state.
    19 				; --------------------------------------------------------------------------
    20
    21
    22 				; ==========================================================================
    23 				; SETUP TRANSITION TO TITLE
    24 				; ==========================================================================
    25 				; Prep values to begin the Transition Event for the Title Screen. That is:
    26 				; Initialize scrolling line in title text.
    27 				; Tell VBI to switch to title screen.
    28 				;
    29 				; Transition events:
    30 				; Stage 1: Scroll in the Title. (three lines, one at a time.)
    31 				; Stage 2: Brighten line 4 luminance.
    32 				; Stage 3: Initialize setup for Press Button on Title screen.
    33 				;
    34 				; Uses A, X
    35 				; --------------------------------------------------------------------------
    36
    37 2485			SetupTransitionToTitle
    38
    39 2485 A9 02			lda #TITLE_SPEED         ; Animation moving speed.
    40 2487 20 81 28			jsr ResetTimers
    41
    42 248A A9 3C			lda #60
    43 248C 85 B3			sta AnimateFrames4       ; Title screen flashing.
    44 248E A9 00			lda #0
    45 2490 85 9D			sta EventCounter2        ; First label (score flashes)
    46 2492 85 9B			sta EventStage           ; Drawing Title.
    47 2494 20 4C 33			jsr TitleRender          ; 0 is erase title.
    48 2497 20 66 3A			jsr TitleSetOrigin       ; Make sure left buffer is visible.
    49
    50 249A 20 AE 3A			jsr HideButtonPrompt     ; Tell VBI the prompt flashing is disabled.
    51 249D 20 15 3B			jsr RemoveFrogOnScreen   ; Remove the frog (from Game Over) if visible 
    52
    53 24A0 A9 01			lda #1
    54 24A2 85 9B			sta EventStage           ; Declare stage 1 behavior for Title Screen.
    55
    56 24A4 A9 00			lda #DISPLAY_TITLE       ; Tell VBI to change displays. VBI will reset origin.
    57 24A6 20 64 34			jsr ChangeScreen         ; Then copy the color tables.  
    58
    59 24A9 A9 0B			lda #EVENT_TRANS_TITLE   ; Change to Title Screen transition.
    60 24AB 85 9A			sta CurrentEvent
    61
    62 24AD A9 54			lda #OFF_FROGX           ; Set new X position to middle of screen.
    63 24AF 85 96			sta WobOffsetX
    64
    65 24B1 A9 4B			lda #OFF_FROGY           ; Set new Y position to origin. (row 18)
    66 24B3 85 97			sta WobOffsetY
    67
    68 24B5 20 60 3C			jsr WobbleDeWobbleX_Now  ; Force immediate calculation of new X position.
    69 24B8 20 70 3C			jsr WobbleDeWobbleY_Now  ; Force immediate calculation of new Y position.
    70
    71 24BB 20 0A 3B			jsr SetFrogOnScreen      ; set Frog shape, set eye position, turn on VBI updates.
    72 				                             ; and finally enable VBI to start P/M redraw. (>0 is ON)
    73
    74 24BE 60				rts
    75
    76
    77 				; ==========================================================================
    78 				; SETUP TRANSITION TO GAME SCREEN
    79 				; ==========================================================================
    80 				; Prep values to run the game screen.
    81 				;
    82 				; Uses A, X
    83 				; --------------------------------------------------------------------------
    84
    85 24BF			SetupTransitionToGame
    86
    87 24BF A9 00			lda #TITLE_WIPE_SPEED  ; Speed of fade/dissolve for transition
    88 24C1 20 81 28			jsr ResetTimers
    89
    90 24C4 20 AE 3A			jsr HideButtonPrompt   ; Tell VBI the prompt flashing is disabled.
    91
    92 24C7 A9 FF			lda #$FF               ; Remove the animated thing from display.
    93 24C9 85 88			sta FrogUpdate         ; This cause VBI to erase and not redraw.
    94
    95 24CB A9 19			lda #25
    96 24CD 85 9D			sta EventCounter2      ; Prep the first transition loop.
    97
    98 24CF A5 B5			lda CurrentDL
    99 24D1 C9 03			cmp #DISPLAY_DEAD
   100 24D3 F0 0A			beq GameStartAtTwo     ; This is Dead display.  Skip ahead to Part Two.
   101 24D5 C9 02			cmp #DISPLAY_WIN
   102 24D7 F0 06			beq GameStartAtTwo     ; This is Win display.  Skip ahead to Part Two.
   103
   104 				;GameStartAtOne             ; Not Dead, Not Win.  Must be OVER, or other.
   105 24D9 A9 01			lda #1                 ; First transition stage: Loop from bottom to top
   106 24DB 85 9B			sta EventStage
   107 24DD D0 10			bne TransitionToGameSetEvent
   108
   109 24DF			GameStartAtTwo ; Coming here from WIN will end up with black Scores/Status text.
   110 					           ; Fix this first by restoring the original colors. 
   111 24DF AD 68 4E			lda GAME_COLPF1_COLORS+1
   112 24E2 8D E7 50			sta COLPF1_TABLE+1
   113 24E5 AD 69 4E			lda GAME_COLPF1_COLORS+2
   114 24E8 8D E8 50			sta COLPF1_TABLE+2
   115 					; setup for fade in Game screen.
   116 24EB A9 02			lda #2
   117 24ED 85 9B			sta EventStage
   118
   119 24EF			TransitionToGameSetEvent
   120 24EF A9 03			lda #EVENT_TRANS_GAME  ; Next step is operating the transition animation.
   121 24F1 85 9A			sta CurrentEvent
   122
   123 24F3 60				rts
   124
   125
   126 				; ==========================================================================
   127 				; SETUP GAME SCREEN
   128 				; ==========================================================================
   129 				; Prep values to run the game screen.
   130 				;
   131 				; The actual game display was switched on by the Trans Game event.
   132 				;
   133 				; Uses A, X
   134 				; --------------------------------------------------------------------------
   135
   136 24F4			SetupGame
   137
   138 24F4 A9 00			lda #0
   139 24F6 85 89			sta FrogSafety         ; Schrodinger's current frog is known to be alive.
   140
   141 24F8 20 AE 3A			jsr HideButtonPrompt   ; Tell VBI the prompt flashing is disabled on the game screen.
   142
   143 24FB A9 00			lda #0                 ; Zero "old" position to trigger Updates to redraw first time.
   144 24FD 85 84			sta FrogPMX
   145 24FF 85 82			sta FrogPMY
   146 2501 85 86			sta FrogShape          ; 0 is "off"  (it would already be off by default)
   147
   148 2503 A2 12			ldx #18                ; 18 (dec), number of screen rows of game field.
   149 2505 86 81			stx FrogNewRow
   150 2507 86 80			stx FrogRow
   151
   152 2509 BD 44 23			lda FROG_PMY_TABLE,x   ; Get the new Player/Missile Y position based on row number.
   153 250C 85 83			sta FrogNewPMY         ; Update Frog position on screen. 
   154
   155 250E A9 7B			lda #MID_FROGX         ; Set new X position to middle of screen.
   156 2510 85 85			sta FrogNewPMX
   157
   158 2512 20 0A 3B			jsr SetFrogOnScreen    ; set Frog shape, set eye position, turn on VBI updates.
   159
   160 2515 20 AE 31			jsr PlayWaterFX        ; Start water noises.  Now.
   161 2518 20 BA 31			jsr PlayEnginesFX      ; Start engine noises.  Now.
   162
   163 251B A9 04			lda #EVENT_GAME        ; Yes, change to game screen event.
   164 251D 85 9A			sta CurrentEvent
   165
   166 251F 60				rts
   167
   168
   169 				; ==========================================================================
   170 				; SETUP TRANSITION TO WIN SCREEN
   171 				; ==========================================================================
   172 				; Prep values to run the Transition Event for the Win screen
   173 				;
   174 				; The Ode To Joy winning song is played on two channels started a 
   175 				; frame apart (1/60th sec NTSC).  Hopefully this makes a ringing/echo 
   176 				; kind of effect.
   177 				;
   178 				; Uses A, X
   179 				; --------------------------------------------------------------------------
   180
   181 2520			SetupTransitionToWin
   182
   183 2520 20 B0 23			jsr Add500ToScore
   184
   185 2523 A9 02			lda #DISPLAY_WIN        ; Tell VBI to change screens.
   186 2525 20 64 34			jsr ChangeScreen        ; Then copy the color tables.
   187
   188 2528 20 41 32			jsr PlayOdeToJoy        ; Play Ode To Joy for saving the frog.  Uses two channels, 2 and 3.
   189
   190 252B A2 01			ldx #1                  ; Shutup 1
   191 252D A0 00			ldy #SOUND_OFF
   192 252F 20 7D 32			jsr SetSound
   193
   194 2532 A9 05			lda #EVENT_TRANS_WIN   ; Next step is operating the transition animation.
   195 2534 85 9A			sta CurrentEvent
   196
   197 2536 60				rts
   198
   199
   200 				; ==========================================================================
   201 				; SETUP WIN SCREEN
   202 				; ==========================================================================
   203 				; Prep values to run the Win screen
   204 				;
   205 				; Uses A, X
   206 				; --------------------------------------------------------------------------
   207
   208 2537			SetupWin
   209
   210 2537 A9 05			lda #WIN_CYCLE_SPEED    ;
   211 2539 20 81 28			jsr ResetTimers
   212
   213 253C A9 EE			lda #238                ; Color scrolling 238 to 16;  Light to dark. Increment.
   214 253E 85 9C			sta EventCounter
   215
   216 2540 A9 00			lda #0
   217 2542 85 9B			sta EventStage          ; Stage 0 is color scrolling and input checking.
   218
   219 2544 A9 06			lda #EVENT_WIN          ; Change to wins screen.
   220 2546 85 9A			sta CurrentEvent
   221 					
   222 2548 60				rts
   223
   224
   225 				; ==========================================================================
   226 				; SETUP TRANSITION TO DEAD SCREEN
   227 				; ==========================================================================
   228 				; Prep values to run the Transition Event for the dead frog.
   229 				; Splat frog.
   230 				; Set timer to 1.5 second wait.
   231 				;
   232 				; VBI established Schrodinger knows the frog is dead.
   233 				;
   234 				; Uses A, X
   235 				; --------------------------------------------------------------------------
   236
   237 2549			SetupTransitionToDead
   238
   239 2549 20 05 3B			jsr SetSplatteredOnScreen  ; splat the frog:
   240
   241 254C C6 8E			dec NumberOfLives       ; subtract a life.
   242 254E 20 A2 34			jsr StrobeLivesLabel    ; Flash the Lives counter label.
   243 2551 20 EB 33			jsr CopyScoreToScreen   ; Update the screen information
   244 2554 20 10 34			jsr PrintFrogsAndLives
   245
   246 2557 A9 78			lda #FROG_WAKE_SPEED    ; Initial delay 2 sec for frog corpse viewing/mourning
   247 2559 20 81 28			jsr ResetTimers
   248
   249 255C A9 01			lda #1                  ; Set Stage 1 in the fading control.
   250 255E 85 9B			sta EventStage
   251
   252 2560 20 5F 32			jsr PlayFuneral         ; Setup channel 3 to play funeral dirge for the dead frog.
   253
   254 2563 A2 01			ldx #1                  ; Shutup 1
   255 2565 A0 00			ldy #SOUND_OFF
   256 2567 20 7D 32			jsr SetSound
   257 					
   258 					; In this case we do not want the Transition to change to the next 
   259 					; display immediately as the player must have time to view and 
   260 					; mourn the splattered frog remains laying in state.  There will be 
   261 					; a pause of about 1.5 seconds for player's tears. 
   262
   263 256A A9 07			lda #EVENT_TRANS_DEAD  ; Next step is operating the transition animation.
   264 256C 85 9A			sta CurrentEvent
   265
   266 256E 60				rts
   267
   268
   269 				; ==========================================================================
   270 				; SETUP DEAD SCREEN
   271 				; ==========================================================================
   272 				; Prep values to run the Dead screen
   273 				;
   274 				; Uses A, X
   275 				; --------------------------------------------------------------------------
   276
   277 256F			SetupDead
   278
   279 256F 20 15 3B			jsr RemoveFrogOnScreen  ; Scrape splattered frog off screen.
   280
   281 2572 A9 05			lda #DEAD_CYCLE_SPEED   ; Animation moving speed.
   282 2574 20 81 28			jsr ResetTimers
   283
   284 2577 A9 03			lda #DISPLAY_DEAD       ; Tell VBI to change screens.
   285 2579 20 64 34			jsr ChangeScreen        ; Then copy the color tables.
   286
   287 257C A9 00			lda #0                  ; Color cycling index for dead.
   288 257E 85 9C			sta EventCounter
   289 2580 85 9B			sta EventStage          ; Stage 0 is background color scroll.
   290
   291 2582 A9 08			lda #EVENT_DEAD         ; Change to dead screen event.
   292 2584 85 9A			sta CurrentEvent
   293
   294 2586 60				rts
   295
   296
   297 				; ==========================================================================
   298 				; SETUP TRANSITION TO GAME OVER SCREEN
   299 				; ==========================================================================
   300 				; Prep values to run the Transition Event for the Game Over.
   301 				;
   302 				; Fade out all lines of the Dead Screen.  
   303 				; Fade in the lines of the Game Over Screen.
   304 				;
   305 				; This seems gratuitous, but it is necessary, because the screen can 
   306 				; be switched so fast that the user pressing the button on the Dead 
   307 				; Screen may not be able to release the button fast enough and end 
   308 				; up immediately dismissing the game over screen.  Not feeling enterprising,
   309 				; so just use the Dead value for fading.
   310 				;
   311 				; Uses A, X
   312 				; --------------------------------------------------------------------------
   313
   314 2587			SetupTransitionToGameOver
   315
   316 2587 A9 04			lda #DEAD_FADE_SPEED   ; Animation moving speed.
   317 2589 20 81 28			jsr ResetTimers 
   318
   319 258C 20 AE 3A			jsr HideButtonPrompt   ; Tell VBI the prompt flashing is disabled.
   320
   321 258F A9 09			lda #EVENT_TRANS_OVER ; Change to transition to Game Over.
   322 2591 85 9A			sta CurrentEvent
   323
   324 2593 60				rts
   325
   326
   327 				; ==========================================================================
   328 				; SETUP GAME OVER
   329 				; ==========================================================================
   330 				; Setup the Game Over screen
   331 				;
   332 				; Prep values to run the Game Over screen
   333 				;
   334 				; Uses A, X
   335 				; --------------------------------------------------------------------------
   336
   337 2594			SetupGameOver
   338
   339 2594 A9 04			lda #GAME_OVER_SPEED    ; Animation moving speed.
   340 2596 20 81 28			jsr ResetTimers
   341
   342 2599 A9 04			lda #DISPLAY_OVER       ; Tell VBI to change screens.
   343 259B 20 64 34			jsr ChangeScreen        ; Then copy the color tables.
   344
   345 259E A9 00			lda #0                  ; base color for sine scroll. 
   346 25A0 85 9C			sta EventCounter
   347 25A2 85 9B			sta EventStage          ; And set stage 0 for color scroll and waiting for input.
   348 				                
   349 25A4 85 84			sta FrogPMX             ; Zero "old" position to trigger Updates to redraw first time.
   350 25A6 85 82			sta FrogPMY
   351 25A8 85 86			sta FrogShape           ; 0 is "off"  (it would already be off by default)
   352
   353 25AA A9 54			lda #OFF_TOMBX          ; Set new X position to middle of screen.
   354 25AC 85 96			sta WobOffsetX
   355
   356 25AE A9 4B			lda #OFF_TOMBY          ; Set new Y position to origin. (row 18)
   357 25B0 85 96			sta WobOffsetX
   358
   359 25B2 A9 03			lda #SHAPE_TOMB         ; Set new tomb shape.
   360 25B4 85 87			sta FrogNewShape
   361
   362 25B6 20 60 3C			jsr WobbleDeWobbleX_Now ; Force immediate calculation of new X position.
   363 25B9 20 70 3C			jsr WobbleDeWobbleY_Now ; Force immediate calculation of new Y position.
   364
   365 25BC A9 01			lda #1
   366 25BE 85 88			sta FrogUpdate
   367
   368 25C0 A9 0A			lda #EVENT_OVER         ; Change to Game Over screen.
   369 25C2 85 9A			sta CurrentEvent
   370
   371 25C4 60				rts
   710 25C5				icl "Frogger03Events.asm"       ; Run the current event/screen
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03Events.asm
     1 				; ==========================================================================
     2 				; Pet Frogger
     3 				; (c) November 1983 by John C. Dale, aka Dalesoft
     4 				; for the Commodore Pet 4032
     5 				; ==========================================================================
     6 				; Ported (parodied) to Atari 8-bit computers
     7 				; by Ken Jennings (if this were 1983, aka FTR Enterprises)
     8 				; ==========================================================================
     9 				; Version 00, November 2018
    10 				; Version 01, December 2018
    11 				; Version 02, February 2019
    12 				; Version 03, August 2019
    13 				; ==========================================================================
    14
    15 				; ==========================================================================
    16 				; Frogger EVENTS
    17 				;
    18 				; All the routines to run for each screen/state.
    19 				; --------------------------------------------------------------------------
    20
    21 				; Note that there is no mention in this code for scrolling the credits
    22 				; text.  This is entirely handled by the Vertical blank routine.  Every
    23 				; display list ends with common instructions that show the scrolling 
    24 				; credit text. The VBI routine updates the common Display List's LMS 
    25 				; pointer to the text.  Since the VBI is in control of this on all screens
    26 				; it means every display has continuous, seamless scrolling credit text 
    27 				; even when the display changes, and no matter what else is happening.
    28
    29 				; Screen enumeration states for current processing condition.
    30 				; Note that the order here does not imply the only order of
    31 				; movement between screens/event activity.  The enumeration
    32 				; could be entirely random.
    33
    34 = 0000			EVENT_INIT        = 0  ; One Time initialization.
    35
    36 = 0001			EVENT_START       = 1  ; Entry Point for New Game setup.
    37 = 0002			EVENT_TITLE       = 2  ; Credits and Instructions.
    38
    39 = 0003			EVENT_TRANS_GAME  = 3  ; Transition animation from Title to Game.
    40 = 0004			EVENT_GAME        = 4  ; GamePlay
    41
    42 = 0005			EVENT_TRANS_WIN   = 5  ; Transition animation from Game to Win.
    43 = 0006			EVENT_WIN         = 6  ; Crossed the river!
    44
    45 = 0007			EVENT_TRANS_DEAD  = 7  ; Transition animation from Game to Dead.
    46 = 0008			EVENT_DEAD        = 8  ; Yer Dead!
    47
    48 = 0009			EVENT_TRANS_OVER  = 9  ; Transition animation from Dead to Game Over.
    49 = 000A			EVENT_OVER        = 10 ; Game Over.
    50
    51 = 000B			EVENT_TRANS_TITLE = 11 ; Transition animation from Game Over to Title.
    52
    53 				; Screen Order/Path
    54 				;                       +-------------------------+
    55 				;                       V                         |
    56 				; Screen Title ---> Game Screen -+-> Win Screen  -+
    57 				;       ^               ^        |
    58 				;       |               |        +-> Dead Screen -+-> Game Over -+
    59 				;       |               |                         |              |
    60 				;       |               +-------------------------+              |
    61 				;       +--------------------------------------------------------+
    62
    63
    64 				; ==========================================================================\
    65 				; EVENT GAME INIT
    66 				; ==========================================================================
    67 				; The Game Starting Point.  Event Entry 0.
    68 				; Called only once at start.  
    69 				; Transition to Title from here and all other events 
    70 				; will use non-zero events.
    71 				; Note that the vast majority of game values in page 0 are automatically
    72 				; set/initialized as load time, so there does not need to be any first-
    73 				; time setup code here.
    74 				; --------------------------------------------------------------------------
    75
    76 25C5			EventGameInit
    77 					; Atari initialization stuff...
    78
    79 25C5 A9 00			lda #AUDCTL_CLOCK_64KHZ    ; Set only this one bit for clock.
    80 25C7 8D 08 D2			sta AUDCTL                 ; Global POKEY Audio Control.
    81 25CA A9 03			lda #3                     ; Set SKCTL to 3 to stop possible cassette noise, 
    82 25CC 8D 0F D2			sta SKCTL                  ; so say Mapping The Atari and De Re Atari.
    83 25CF 20 73 32			jsr StopAllSound           ; Zero all AUDC and AUDF
    84
    85 25D2 A9 40			lda #>CHARACTER_SET        ; Set custom character set.  Global to game, forever.
    86 25D4 8D F4 02			sta CHBAS
    87
    88 25D7 A9 40			lda #NMI_VBI               ; Turn Off DLI
    89 25D9 8D 0E D4			sta NMIEN
    90
    91 25DC A9 00			lda #0
    92 25DE 85 A9			sta ThisDLI
    93
    94 25E0 A9 2B			lda #<Score1_DLI; TITLE_DLI ; Set DLI vector. (will be reset by VBI on screen setup)
    95 25E2 8D 00 02			sta VDSLST
    96 25E5 A9 2B			lda #>Score1_DLI; TITLE_DLI
    97 25E7 8D 01 02			sta VDSLST+1
    98 					
    99 25EA A9 C0			lda #[NMI_DLI|NMI_VBI]     ; Turn On DLIs
   100 25EC 8D 0E D4			sta NMIEN
   101
   102 					; Changing the Display List is potentially tricky.  If the update is
   103 					; interrupted by the Vertical blank, then it could mess up the display
   104 					; list address and crash the Atari.
   105 					;
   106 					; So, this problem is solved by giving responsibility for Display List
   107 					; changes to a custom Vertical Blank Interrupt. The main code simply
   108 					; writes a byte to a page 0 location monitored by the Vertical Blank
   109 					; Interrupt and this directs the interrupt to change the current
   110 					; display list.  Easy-peasy and never updated at the wrong time.
   111
   112 25EF A0 20			ldy #<MyImmediateVBI       ; Add the VBI to the system (Display List dictatorship)
   113 25F1 A2 29			ldx #>MyImmediateVBI
   114 25F3 A9 06			lda #6                     ; 6 = Immediate VBI
   115 25F5 20 5C E4			jsr SETVBV                 ; Tell OS to set it
   116
   117 25F8 A0 67			ldy #<MyDeferredVBI        ; Add the VBI to the system (Lazy hippie timers, colors, sound.)
   118 25FA A2 29			ldx #>MyDeferredVBI
   119 25FC A9 07			lda #7                     ; 7 = Deferred VBI
   120 25FE 20 5C E4			jsr SETVBV                 ; Tell OS to set it
   121
   122 2601 A9 00			lda #0
   123 2603 85 93			sta FlaggedHiScore
   124 2605 85 99			sta InputStick             ; no input from joystick
   125
   126 2607 A9 0E			lda #COLOR_BLACK+$E        ; COLPF3 is white on all screens. it is up to DLIs to modify otherwise.
   127 2609 8D C7 02			sta COLOR3
   128
   129 260C 20 1A 3B			jsr libPmgInit             ; Will also reset SDMACTL settings for P/M DMA
   130
   131 260F 20 85 24			jsr SetupTransitionToTitle ; will set CurrentEvent = EVENT_TRANS_TITLE
   132
   133 2612 60				rts                         ; And now ready to go back to main game loop . . . .
   134
   135
   136 				; ==========================================================================
   137 				; EVENT TRANSITION TO TITLE
   138 				; ==========================================================================
   139 				; Event Process TRANSITION TO TITLE
   140 				; The setup for Transition to Title will turned on the Title Display.
   141 				; Stage 1: Start sound effects for rezz in Title graphics.
   142 				; Stage 2: Go To Start event
   143 				; --------------------------------------------------------------------------
   144
   145 2613			EventTransitionToTitle
   146
   147 2613 A5 B0			lda AnimateFrames          ; Did animation counter reach 0 ?
   148 2615 D0 1F			bne EndTransitionToTitle   ; Nope.  Nothing to do.
   149 2617 A9 02			lda #TITLE_SPEED           ; yes.  Reset it.
   150 2619 20 81 28			jsr ResetTimers
   151
   152 261C A5 9B			lda EventStage             ; What stage are we in?
   153 261E C9 01			cmp #1
   154 2620 D0 0C			bne GoToStartEventForTitle
   155 				 
   156 					; === STAGE 1 ===
   157
   158 2622 20 9E 31			jsr ToPlayFXScrollOrNot    ; Start slide sound playing if not playing now.
   159
   160 				;FinishedNowSetupStage2
   161 2625 20 26 32			jsr PlaySaberHum           ; Play light saber hum using two channels.
   162
   163 2628 A9 02			lda #2                     ; Set stage 2 as next part of Title screen event...
   164 262A 85 9B			sta EventStage
   165 262C D0 08			bne EndTransitionToTitle
   166
   167 					; === STAGE 2 ===
   168
   169 262E			GoToStartEventForTitle
   170 262E A9 00			lda #0 
   171 2630 85 9B			sta EventStage
   172
   173 2632 A9 01			lda #EVENT_START           ; Yes, change to event to start new game.
   174 2634 85 9A			sta CurrentEvent
   175
   176 2636			EndTransitionToTitle
   177 2636 20 49 3C			jsr WobbleDeWobble         ; Frog following spirograph art path on the title.
   178
   179 2639 60				rts
   180
   181
   182 				; ==========================================================================
   183 				; EVENT SCREEN Start
   184 				; ==========================================================================
   185 				; Event process SCREEN START/NEW GAME
   186 				; Copy the prior game setup to the prior game values.
   187 				; Clear the Game Scores and get ready for the Press A Button prompt.
   188 				;
   189 				; Sidebar: This is oddly inserted between Transition to Title and the
   190 				; Title to finish internal initialization per game due to doofus-level
   191 				; lack of design planning, blah blah.
   192 				; The title screen has already been presented by Transition To Title.
   193 				; --------------------------------------------------------------------------
   194
   195 263A			EventScreenStart            ; This is New Game and Transition to title.
   196
   197 263A A5 8C			lda NewLevelStart       ; Copy the new game setups to the last (i.e. current) game vars
   198 263C 85 8D			sta LastLevelStart      
   199
   200 263E A5 8F			lda NewNumberOfLives    ; Copy the new game setups to the last (i.e. current) game vars
   201 2640 85 90			sta LastNumberofLives
   202 2642 85 8E			sta NumberOfLives
   203
   204 2644 20 FD 33			jsr ClearSavedFrogs     ; Erase the saved frogs from the screen. (Zero the frog count)
   205 2647 20 10 34			jsr PrintFrogsAndLives  ; Update the screen memory for the status.
   206
   207 264A A9 02			lda #EVENT_TITLE        ; Next step is operating the title screen input.
   208 264C 85 9A			sta CurrentEvent
   209
   210 264E 60				rts
   211
   212
   213 				; ==========================================================================
   214 				; EVENT TITLE Screen
   215 				; ==========================================================================
   216 				; Event Process TITLE SCREEN
   217 				; The activity on the title screen:
   218 				; Always draw the animated frog. The frog animation is called on every 
   219 				; frame since WobbleDeWobble manages timing and movement. 
   220 				; The animated Rezz-in for the title text is also called on all frames.   
   221 				; There is no AnimateFrames control of the speed until the animations
   222 				; and scrolling for stage 2 and 3.
   223 				; Stages: 
   224 				; 0) Random rezz in for Title graphics.
   225 				; Not Stage 0.
   226 				; 1|4) Blink Prompt for joystick button.  Joystick button input is accepted.
   227 				; Joystick button input is not observed during Stages 2, and 3.
   228 				; 1) Just input checking per above, and testing Option/Select.
   229 				; 2) Shifting Left Graphics down.
   230 				; 3) OPTION or SELECT animation  scroll in from Right to Left.
   231 				; 4) Waiting to return to Stage 0 (AnimateFrames2 timer). and Button Input.
   232 				; --------------------------------------------------------------------------
   233
   234 264F			EventTitleScreen
   235
   236 				; =============== Stage * ; Always run the frog and the label flashing. . .
   237
   238 264F 20 49 3C			jsr WobbleDeWobble         ; Frog drawing spirograph path on the title.
   239 2652 20 1F 33			jsr FlashTitleLabels       ; and cycle the label flashing.
   240
   241 2655 A5 9B			lda EventStage
   242 2657 D0 1B			bne bETS_InputStage        ; stage is >0, so title treatment is over.
   243
   244 				; =============== Stage 0      ; Animating Title only while sound runs
   245
   246 2659 AD 3A 4E			lda TITLE_UNDERLINE_FADE+6
   247 265C 8D BE 50			sta COLPF0_TABLE+9
   248
   249 265F A5 ED			lda SOUND_CONTROL3         ; Is channel 3 busy?
   250 2661 F0 08			beq bETS_EndTitleAnimation ; No. Stop the title animation.
   251
   252 				;bETS_RandomizeLogo
   253 2663 A9 FF			lda #$FF                   ; Channel 3 is playing sound, so animate.
   254 2665 20 4C 33			jsr TitleRender            ; and -1  means draw the random masked title.
   255 2668 4C F2 26			jmp EndTitleScreen         ; Do not process input during the randomize.
   256
   257 266B			bETS_EndTitleAnimation
   258 266B A9 01			lda #1                     ; Draw the title as solid and stop animation.
   259 266D 85 9B			sta EventStage             ; Stage 1 is always skip the title drawing.
   260 266F 85 DB			sta EnablePressAButton     ; Turn On the prompt to press button (for later below).
   261 2671 20 4C 33			jsr TitleRender            ; and 1 also means draw the solid title.
   262
   263 				; =============== Stage-ish Not 0-ish, handling button input when Option/Select hacks are not in motion. 
   264
   265 2674			bETS_InputStage 
   266
   267 				;CheckTitleInput
   268 2674 A5 DB			lda EnablePressAButton     ; Is button input on?
   269 2676 F0 11			beq CheckFunctionButton    ; No.  A later stage may still be running.
   270
   271 2678 20 F4 3A			jsr RunPromptForButton     ; Blink Prompt to press Joystick button and check input.
   272 267B F0 0C			beq CheckFunctionButton    ; No joystick button.  Try a function key.
   273
   274 				;ProcessTitleScreenInput        ; Button pressed. Prepare for the screen transition to the game.
   275 267D 20 BF 24			jsr SetupTransitionToGame
   276
   277 					; This was part of the Start event, but after the change to keep the 
   278 					; scores displayed on the title screen it would end up erasing the 
   279 					; last game score as soon as the title transition animation completed.
   280 					; Therefore resetting the score is deferred until leaving the Title.
   281 2680 20 72 23			jsr ClearGameScores     ; Zero the score.  And high score if not set.
   282 2683 20 10 34			jsr PrintFrogsAndLives  ; Update the screen memory.
   283
   284 2686 4C F2 26			jmp EndTitleScreen
   285
   286
   287 				; For the Option/Select handling it is easy to maintain safe input (no 
   288 				; flaky on/offs) because once a key is read it takes a while to scroll 
   289 				; the text in, giving the user time to release the key.
   290 				; 
   291 				; OPTION = Change number of frogs.
   292 				; SELECT = Change game level/difficulty.
   293 				;
   294 				; If the Current selection for frogs is greater than the last game's (or 
   295 				; the default) OR the current level is less than the last game's starting 
   296 				; difficulty, then the high score is cleared on game start.
   297
   298 2689			CheckFunctionButton
   299 2689 A5 9B			lda EventStage
   300 268B C9 01			cmp #1                   ; 1) Just doing input checking per above, and testing Option/Select.
   301 268D D0 06			bne bETS_Stage2          ; Not Stage 1.  Go to Stage 2.  Skip checking console keys.
   302
   303 268F 20 C9 28			jsr CheckForConsoleInput ; If Button pressed, then sets Stage 2, and EventCounter for TitleShiftDown.
   304 2692 4C F2 26			jmp EndTitleScreen       ; Regardless of the console input, this is the end of stage 1.
   305
   306 				; =============== Stage 2    ; Shifting Left buffer pixels down.
   307
   308 2695			bETS_Stage2
   309 2695 C9 02			cmp #2                   ; 2) slide left buffer down.
   310 2697 D0 26			bne bETS_Stage3          ; Not Stage 2.  Try Stage 3.
   311
   312 				;CheckTitleSlideDown 
   313 2699 A5 B0			lda AnimateFrames
   314 269B D0 55			bne EndTitleScreen       ; Animation frames not 0.  Wait till next time.
   315
   316 269D 20 54 39			jsr TitleShiftDown       ; Shift Pixels down
   317
   318 26A0 A6 9C			ldx EventCounter         ; Get the counter
   319 26A2 20 CC 33			jsr FadeTitleUnderlines  ; Fade (or not) the green underlines to yellow.
   320
   321 26A5 C6 9C			dec EventCounter         ; Decrement number of times this is done.
   322 26A7 30 08			bmi bETS_Stage2_ToStage3 ; When it is done, go to stage 3. 
   323
   324 26A9 A9 03			lda #TITLE_DOWN_SPEED    ; The down shift is not done, so 
   325 26AB 20 81 28			jsr ResetTimers          ; Reset animation/input frame counter.      
   326 26AE 4C F2 26			jmp EndTitleScreen
   327
   328 26B1			bETS_Stage2_ToStage3         ; Setup for next Stage
   329 26B1 A9 03			lda #3
   330 26B3 85 9B			sta EventStage
   331
   332 26B5 20 8F 37			jsr RandomizeTitleColors ; Random color gradient for the Text pixels.
   333
   334 26B8 20 FE 31			jsr PlayLefts            ;  Play Left movement sound for title graphics on OPTION and SELECT
   335 26BB E6 B6			inc VBIEnableScrollTitle ; Turn on Title fine scrolling.
   336 26BD D0 33			bne EndTitleScreen
   337
   338 				; =============== Stage 3    ; Scrolling in pixels from Right to Left. 
   339
   340 26BF			bETS_Stage3
   341 26BF C9 03			cmp #3
   342 26C1 D0 10			bne bETS_Stage4
   343
   344 				;CheckTitleScroll
   345 26C3 A5 B6			lda VBIEnableScrollTitle   ; Is VBI busy scrolling option text?
   346 26C5 D0 2B			bne EndTitleScreen         ; Yes.  Nothing more to do here.
   347
   348 					; Readjust display to show the left buffer visible 
   349 					; and reset scrolling origin.
   350 26C7 20 7C 3A			jsr TitleCopyRightToLeftGraphics ; Copy right buffer to left buffer.
   351 26CA 20 66 3A			jsr TitleSetOrigin               ; Reset LMS to point to left buffer
   352
   353 				;bETS_Stage3_ToStage4         ; Setup for next Stage
   354 26CD A9 04			lda #4
   355 26CF 85 9B			sta EventStage
   356 26D1 D0 1F			bne EndTitleScreen
   357
   358 				; =============== Stage 4 ; Waiting on RestoreTitleTimer to return to Stage 0. 
   359
   360 26D3			bETS_Stage4                  ; Stage 4, allow console input.
   361 26D3 20 C9 28			jsr CheckForConsoleInput ; If Button pressed, then sets Stage 2, and EventCounter for TitleShiftDown.
   362 26D6 F0 06			beq bETS_CheckAutoReturn ; No console key pressed.  So, check if return is automatic.
   363 26D8 A9 00			lda #0                   ; Console key input returns us to Stage 2, so zero the auto timer.
   364 26DA 85 B8			sta RestoreTitleTimer
   365 26DC F0 14			beq EndTitleScreen
   366
   367 26DE			bETS_CheckAutoReturn
   368 26DE A5 B8			lda RestoreTitleTimer    ; Wait for Input timeout to expire.
   369 26E0 D0 10			bne EndTitleScreen       ; No timeout yet.
   370
   371 					; Expired auto timer... Return to Stage 0.
   372 26E2 20 9E 31			jsr ToPlayFXScrollOrNot  ; Start slide sound playing if not playing now.
   373 26E5 BD 34 4E			lda TITLE_UNDERLINE_FADE,x ; Return underlines to green (SELECT/OPTION faded them out.)
   374 26E8 8D BD 50			sta COLPF0_TABLE+8
   375 26EB A9 00			lda #0
   376 26ED 85 9B			sta EventStage
   377
   378 26EF 20 A6 37			jsr ResetTitleColors     ; Original title colors.
   379
   380
   381 26F2			EndTitleScreen
   382
   383 26F2 60				rts
   384
   385
   386 				; ==========================================================================
   387 				; EVENT TRANSITION TO GAME
   388 				; ==========================================================================
   389 				; Event Process TRANSITION TO GAME SCREEN
   390 				; The Activity in the transition area, based on timer.
   391 				; Stage 1) Fade out text lines  from bottom to top.
   392 				;          Decrease COLPF1 brightness from bottom   to top.
   393 				;          When COLPF1 reaches 0 change COLPF2 to COLOR_BLACK.
   394 				; Stage 2) Setup Game screen display.  Set all colors to black.
   395 				; Stage 3) Fade in text lines from top to bottom.
   396 				;          Decrease COLPF1 brightness from top to bottom.
   397 				;          When COLPF1 reaches 0 change COLPF2 to COLOR_BLACK.
   398 				; --------------------------------------------------------------------------
   399
   400 26F3			EventTransitionToGame
   401
   402 26F3 A5 B0			lda AnimateFrames        ; Did animation counter reach 0 ?
   403 26F5 D0 6C			bne EndTransitionToGame  ; Nope.  Nothing to do.
   404 26F7 A9 00			lda #TITLE_WIPE_SPEED    ; yes.  Reset it.
   405 26F9 20 81 28			jsr ResetTimers
   406
   407 26FC A5 9B			lda EventStage           ; What stage are we in?
   408 26FE C9 01			cmp #1
   409 2700 D0 2A			bne TestTransGame2       ; Not the fade out, try next stage
   410
   411 					; === STAGE 1 ===
   412 					; Fade out text lines  from bottom to top.
   413 					; Fade out COLPF0 and COLPF1 at the same time.
   414 					; When luminance reaches 0, set color to 0. 
   415 					; When COLPF0/COLPF1 reach 0 then change COLPF2/COLBK to COLOR_BLACK.
   416 2702 20 3B 37			jsr FadeColPfToBlack     ; Decrement color 0, color 1, until zero.  Return COLPF0 | COLPF1 ...
   417 2705 F0 05			beq ZeroCOLPF2           ; ... If both are 0, then zero the background.
   418 2707 20 3B 37			jsr FadeColPfToBlack     ; V03 tester recommends speeding up the transition. Do it again.
   419 270A D0 57			bne EndTransitionToGame  ; ... If either color is non-zero, done for this pass.
   420
   421 270C			ZeroCOLPF2                   ; FadeColPfToBlack returned 0, so the text (and pixel) is 0.  
   422 270C A9 00			lda #0                   ; Therefore, zero the background(s).
   423 					;                        ; FYI: FadeColPfToBlack  did  ldx EventCounter2
   424 270E 9D 17 51			sta COLPF2_TABLE,x
   425 2711 9D 84 50			sta COLBK_TABLE,x
   426
   427 2714 C6 9D			dec EventCounter2
   428 2716 A5 9D			lda EventCounter2
   429 2718 C9 02			cmp #2
   430 271A D0 47			bne EndTransitionToGame ; 1 is the last entry. 0 is stop looping.
   431
   432 					; Finished stage 1, now setup Stage 2
   433 271C 20 EB 33			jsr CopyScoreToScreen   ; Make sure the score is updated in Game screen memory.
   434 271F 20 10 34			jsr PrintFrogsAndLives  ; And the frog list.
   435 2722 A9 02			lda #2                  ; Go to next phase TestTransGame2
   436 2724 85 9B			sta EventStage
   437 2726 A9 00			lda #0
   438 2728 85 9D			sta EventCounter2 ; return to 0.
   439 272A F0 37			beq EndTransitionToGame
   440
   441 					; === STAGE 2 ===
   442 					; Setup Game screen display.
   443 					; Set all colors to black.
   444 272C			TestTransGame2
   445 272C C9 02			cmp #2
   446 272E D0 0F			bne TestTransGame3
   447
   448 2730 A9 01			lda #DISPLAY_GAME        ; Tell VBI to change screens.
   449 2732 20 64 34			jsr ChangeScreen         ; Then copy the color tables.
   450
   451 					; Finished stage 2, now setup Stage 3
   452
   453 2735 A9 03			lda #3
   454 2737 85 9B			sta EventStage
   455 2739 A9 02			lda #2
   456 273B 85 9D			sta EventCounter2 
   457 273D F0 24			beq EndTransitionToGame
   458
   459 					; === STAGE 3 ===
   460 					; Fade in text lines from top to bottom.
   461 					; This looked so simple on paper. 
   462 					; Now that there are four colors per line the 
   463 					; fade up to the target values is much more complicated.
   464 					; Read the mess that is IncrementTableColors elsewhere.
   465 273F			TestTransGame3
   466 273F C9 03			cmp #3
   467 2741 D0 20			bne EndTransitionToGame
   468
   469 2743 A6 9D			ldx EventCounter2
   470 2745 20 DB 35			jsr IncrementTableColors ; Complicated fade up of four color registers.
   471 2748 F0 05			beq TransGameNextLine    ; if done, then move to next line
   472 274A 20 DB 35			jsr IncrementTableColors ; Do it again. V03 playtesters think this should be faster.
   473 274D D0 14			bne EndTransitionToGame  ; All colors do not match yet. Be back later to do more.
   474
   475 274F			TransGameNextLine            ; All colors match on this line.  Do next line.
   476 274F E6 9D			inc EventCounter2        ; Next screen line.
   477 2751 A5 9D			lda EventCounter2
   478 2753 C9 17			cmp #23                  ; Reached the limit?  
   479 2755 D0 0C			bne EndTransitionToGame  ; No.  Finish this pass.
   480
   481 					; Finished stage 3, now go to the main event.
   482 2757 A9 01			lda #EVENT_START         ; Yes, change to event to start new game.
   483 2759 85 9A			sta CurrentEvent
   484
   485 275B A9 03			lda #BLINK_SPEED          ; Text Blinking speed for prompt ?
   486 275D 20 81 28			jsr ResetTimers
   487
   488 2760 20 F4 24			jsr SetupGame
   489
   490 2763			EndTransitionToGame
   491
   492 2763 60				rts
   493
   494
   495 				; ==========================================================================
   496 				; EVENT GAME SCREEN
   497 				; ==========================================================================
   498 				; Event Process: GAME SCREEN
   499 				; Play the game.
   500 				; 
   501 				; Many of the things in Version 02 have become non-events 
   502 				; in Version 03 for the main line code.  The MAIN game logic is 
   503 				; now very simple due to things moving the VBI...
   504 				; 1) When the input timer allows, get controller input.
   505 				; 2) Process frog Movement per controller.
   506 				; 2.a) Determine exit to Win screen
   507 				; 2.b) Determine exit to Dead screen.
   508 				; All the messy stuff is in the VBI...
   509 				; VBI determines frog death conditions.
   510 				; VBI scrolls boats.
   511 				; VBI moves frog if frog is on a boat row.
   512 				; VBI animates boat parts.
   513 				; --------------------------------------------------------------------------
   514
   515 2764			EventGameScreen
   516 				; ==========================================================================
   517 				; GAME SCREEN - Joystick Input Section
   518 				; --------------------------------------------------------------------------
   519
   520 					; VBI manages frog falling off the boats.
   521 2764 A5 89			lda FrogSafety           ; Did the VBI flag that Shrodinger's frog is dead?
   522 2766 D0 4B			bne DoSetupForYerDead    ; Yes.  No input allowed.  Start the funeral.
   523
   524 2768 20 9E 28			jsr CheckInput           ; Get cooked stick or trigger if timer permits.
   525 276B F0 3D			beq EndOfJoystickMoves   ; Nothing pressed, Skip the input section.
   526
   527 				;ProcessJoystickInput         ; Reminder: Input Bits: "0 0 0 Trigger Right Left 0 Up"
   528 276D A5 99			lda InputStick           ; Get the cooked joystick state... 
   529
   530 				;UpStickTest
   531 276F 6A				ror                      ; Roll out low bit. UP
   532 2770 90 0C			bcc LeftStickTest        ; No bit. Try Left.
   533
   534 2772 A9 03			lda #3                   ; Eyeballs left
   535 2774 20 69 23			jsr FrogEyeFocus
   536
   537 2777 20 57 23			jsr FrogMoveUp           ; Yes, go do UP. Subtract from FrogRow and PM Y position.
   538 277A F0 23			beq DoSetupForFrogWins   ; Returned 0.  No more rows to cross. Update to frog Wins!
   539 277C D0 26			bne FrogHasMoved         ; Row greater than 0.  Done with this.
   540
   541
   542 277E			LeftStickTest
   543 277E 6A				ror                      ; Roll out empty bit. DOWN (it is unused)
   544 277F 6A				ror                      ; Roll out low bit. LEFT
   545 2780 90 0D			bcc RightStickTest       ; No bit. Try Right.
   546
   547 2782 A9 00			lda #0                   ; Eyeballs left
   548 2784 20 69 23			jsr FrogEyeFocus
   549
   550 2787 A4 84			ldy FrogPMX              ; Get current Frog position
   551 2789 88				dey                      ; - minus 2 color clocks is 1/2 character.
   552 278A 88				dey
   553
   554 278B 84 85			sty FrogNewPMX           ; Save as new suggested location.
   555 					
   556 278D D0 15			bne FrogHasMoved         ; Done here.  Frog moved.  Always branches.
   557
   558
   559 278F			RightStickTest
   560 278F 6A				ror                      ; Roll out low bit. RIGHT
   561 2790 90 18			bcc EndOfJoystickMoves   ; No bit.  Replace Frog on screen.  Try boat animation.
   562
   563 2792 A9 02			lda #2                   ; Eyeballs Right
   564 2794 20 69 23			jsr FrogEyeFocus
   565
   566 2797 A4 84			ldy FrogPMX              ; Get current Frog position
   567 2799 C8				iny                      ; - plus 2 color clocks. is 1/2 character.
   568 279A C8				iny 
   569 279B 84 85			sty FrogNewPMX           ; Save as new suggested location.
   570 279D D0 05			bne FrogHasMoved         ; Done here.  Frog moved.  Always branches.
   571
   572 					; Safe location at the far beach.  the Frog is saved.
   573 279F			DoSetupForFrogWins
   574 279F 20 20 25			jsr SetupTransitionToWin
   575 27A2 D0 12			bne EndGameScreen        ; last action in function is lda/sta a non-zero value.
   576
   577 27A4			FrogHasMoved
   578 27A4 20 C2 31			jsr PlayThump            ; Sound for when frog moves.
   579 27A7 20 EB 33			jsr CopyScoreToScreen    ; Make sure the score is in sync.
   580
   581 27AA			EndOfJoystickMoves
   582
   583 27AA 20 AA 31			jsr ToReplayFXWaterOrNot   ; Time to replay the water noises?
   584 27AD 20 B6 31			jsr ToReplayFXEnginesOrNot ; Time to replay the engine noises?
   585 27B0 4C B6 27			jmp EndGameScreen          ; Done with game loop.
   586
   587 27B3			DoSetupForYerDead
   588 27B3 20 49 25			jsr SetupTransitionToDead
   589
   590 27B6			EndGameScreen
   591
   592 27B6 60				rts
   593
   594
   595 				; ==========================================================================
   596 				; EVENT TRANSITION TO Win
   597 				; ==========================================================================
   598 				; Event Process TRANSITION TO WIN
   599 				; V03 currently removes the transition to Win screen.
   600 				; Now, just does immediate switch to the Win screen.
   601 				;
   602 				; Prior version...
   603 				; The Activity in the transition area, based on timer.
   604 				; 1) wipe screen from top to middle, and bottom to middle.
   605 				; 2) Display the Frogs SAVED!
   606 				; 3) Setup to do the Win screen event.
   607 				; --------------------------------------------------------------------------
   608
   609 27B7			EventTransitionToWin
   610
   611 27B7 20 37 25			jsr SetupWin             ; Setup for Wins screen 
   612
   613 27BA			EndTransitionToWin
   614
   615 27BA 60				rts
   616
   617
   618 				; ==========================================================================
   619 				; EVENT WIN Screen
   620 				; ==========================================================================
   621 				; Event Process WIN SCREEN
   622 				;
   623 				; Scroll Rainbow colors on screen while waiting for a button press.
   624 				; Scroll up at top. light to dark.  
   625 				; Scroll down at bottom.  Dark to light.
   626 				; Do not use $0x or $Fx  (Min 16, max 238)
   627 				; 
   628 				; Setup for next transition.
   629 				; --------------------------------------------------------------------------
   630
   631 27BB			EventWinScreen
   632
   633 27BB A5 9B			lda EventStage              ; Stage 0 is waiting for input
   634 27BD D0 0A			bne WinScreenCheckTimers    ; If not stage 0, then no input.
   635
   636 27BF 20 F4 3A			jsr RunPromptForButton      ; Check button press.
   637 27C2 F0 05			beq WinScreenCheckTimers    ; No input.   Do timers.
   638
   639 27C4			ProcessWinScreenInput           ; Button is pressed. Prepare for the screen transition.
   640 27C4 20 AE 3A			jsr HideButtonPrompt        ; Turn off the prompt
   641 27C7 E6 9B			inc EventStage              ; Setup Stage 1 for the screen fading ...
   642
   643 27C9			WinScreenCheckTimers
   644 					; While there is no input, then animate colors.
   645 27C9 A5 B0			lda AnimateFrames           ; Did animation counter reach 0 ?
   646 27CB D0 18			bne EndWinScreen            ; Nope.  Nothing to do.
   647 27CD A9 05			lda #WIN_CYCLE_SPEED        ; yes.  Reset animation timer.
   648 27CF 20 81 28			jsr ResetTimers
   649
   650 27D2 A5 9B			lda EventStage
   651 27D4			WinStageZero
   652 27D4 D0 05			bne WinStageOne             ; Not Stage Zero
   653
   654 27D6 20 EF 36			jsr WinRainbow              ; Run the Art.
   655 27D9 F0 0A			beq EndWinScreen
   656
   657 27DB			WinStageOne ; and Stage Two and Three for the fade out effects.
   658 27DB 20 8F 35			jsr CommonSplashFade ; Do Stage 1, 2, 3.  On exit, expect A = EventStage
   659
   660 				; The actual end.
   661
   662 27DE			WinStageFour                  ; Evaluate return to game, or game over.
   663 27DE C9 04			cmp #4                    ; Is EventStage == 4?
   664 27E0 D0 03			bne EndWinScreen
   665
   666 27E2 20 BF 24			jsr SetupTransitionToGame
   667
   668 27E5			EndWinScreen
   669
   670 27E5 60				rts
   671
   672
   673 				; ==========================================================================
   674 				; EVENT TRANSITION TO DEAD
   675 				; ==========================================================================
   676 				; Event Process TRANSITION TO DEAD
   677 				; The Activity in the transition area, based on timer.
   678 				; 0) On Entry, wait (2 sec) to observe splattered frog. (timer set in 
   679 				;    the setup event)
   680 				; 1) Greyscale for all playfield lines, except frog's line.
   681 				; 2) Allow another 2 seconds of waiting.
   682 				; 3) Launch the Dead Frog Display.
   683 				; --------------------------------------------------------------------------
   684
   685 27E6			EventTransitionToDead
   686
   687 27E6 A5 B0			lda AnimateFrames        ; Did animation counter reach 0 ? (1.5 sec delay)
   688 27E8 D0 22			bne EndTransitionToDead  ; Nope.  Nothing to do.
   689 27EA A9 78			lda #FROG_WAKE_SPEED     ; yes.  Reset it. (2 more seconds) to wait for stage 2
   690 27EC 20 81 28			jsr ResetTimers
   691
   692 27EF A5 9B			lda EventStage         ; What stage are we in?
   693 27F1 C9 01			cmp #1
   694 27F3 D0 14			bne TestTransDead2       ; Not the Playfield blackout, try next stage
   695
   696 				; ======== Stage 1 ========
   697 				; Grey the playfield.   Leave frog line alone. 
   698 27F5 A2 12			ldx #18
   699
   700 27F7			LoopDeadToBlack
   701 27F7 E4 80			cpx FrogRow             ; Is X the same as Frog Row?
   702 27F9 F0 05			beq SkipGreyFrog        ; Yes, do not grey this line.
   703
   704 				;SkipRedFrog
   705 27FB A9 00			lda #COLOR_BLACK        ; Choose black instead.
   706
   707 				; A subroutine, because it is too much code for the EventTransitionToDead
   708 				; branches to reach around. 
   709 				;SkipBlackFrog
   710 27FD 20 5A 37			jsr GreyEachColorTable  
   711
   712 2800			SkipGreyFrog
   713 2800 CA				dex                     ; Next row.
   714 2801 10 F4			bpl LoopDeadToBlack     ; 18 to 0...
   715
   716 2803 A9 02			lda #2
   717 2805 85 9B			sta EventStage           ; Identify Stage 2 
   718 2807 D0 03			bne EndTransitionToDead  ; Nothing else to do.
   719 					; When the first mourning timer ran out, it was reset to FROG_WAKE_SPEED again, 
   720 					; so it will be another 2 seconds before Stage 2 can start. 
   721
   722 				; ======== Stage 2 ========
   723 				; Ready to go to the Dead screen.
   724 2809			TestTransDead2
   725 2809 20 6F 25			jsr SetupDead            ; Setup for Dead screen (wait for input loop)
   726
   727 280C			EndTransitionToDead
   728
   729 280C 60				rts
   730
   731
   732 				; ==========================================================================
   733 				; EVENT DEAD Screen
   734 				; ==========================================================================
   735 				; Event Process DEAD SCREEN
   736 				; 0a) While no button, animate the background colors. 
   737 				; 0b) If Button Press, then start fade to black.
   738 				; 1) Black background for scrolling colors.
   739 				; 2) Fade background colors behind text.
   740 				; 3) Fade text colors to black.
   741 				; 4) Determine transition to Game or GameOver.
   742 				; --------------------------------------------------------------------------
   743
   744 280D			EventDeadScreen
   745
   746 280D A5 9B			lda EventStage            ; Stage 0 is waiting for input
   747 280F D0 0A			bne DeadScreenCheckTimers ; Not stage 0, skip button check
   748
   749 2811 20 F4 3A			jsr RunPromptForButton    ; Check button press.
   750 2814 F0 05			beq DeadScreenCheckTimers ; No input, continue with timer checks.
   751
   752 				;ProcessDeadScreenInput        ; Button is pressed. 
   753 2816 20 AE 3A			jsr HideButtonPrompt      ; Turn off the prompt
   754 2819 E6 9B			inc EventStage            ; Setup Stage 1 for the screen fading ...
   755
   756 281B			DeadScreenCheckTimers
   757 					; Check timers.  Animate colors per the stage.
   758 281B A5 B0			lda AnimateFrames         ; Did animation counter reach 0 ?
   759 281D D0 23			bne EndDeadScreen         ; Nope.  Nothing to do.
   760 281F A9 05			lda #DEAD_CYCLE_SPEED     ; yes.  Reset animation timer.
   761 2821 20 81 28			jsr ResetTimers
   762
   763 2824 A5 9B			lda EventStage   
   764 2826			DeadStageZero                 ; Stage 0  cycling the background.
   765 2826 D0 07			bne DeadStageOne          ; non zero is stage 1 or 2 or 3 or ...
   766
   767 2828 20 DE 34			jsr DeadFrogRain
   768 282B A9 00			lda #0
   769 282D F0 13			beq EndDeadScreen         ; Stage 1 is set by the input handling earlier.
   770
   771
   772 282F			DeadStageOne                  ; and Stage Two and Three for the fade out effects.
   773 282F 20 8F 35			jsr CommonSplashFade      ; Do Stage 1, 2, 3.  On exit, expect A = EventStage
   774
   775 				; The actual end.
   776
   777 2832			DeadStageFour                 ; Evaluate return to game, or game over.
   778 2832 C9 04			cmp #4                    ; Is EventStage == 4?
   779 2834 D0 0C			bne EndDeadScreen
   780
   781 2836 A5 8E			lda NumberOfLives         ; Have we run out of frogs?
   782 2838 F0 05			beq SwitchToGameOver      ; Yes.  Game Over.
   783
   784 283A 20 BF 24			jsr SetupTransitionToGame ; Go back to game screen.
   785 283D D0 03			bne EndDeadScreen
   786
   787 283F			SwitchToGameOver
   788 283F 20 87 25			jsr SetupTransitionToGameOver
   789
   790 2842			EndDeadScreen
   791
   792 2842 60				rts
   793
   794
   795 				; ==========================================================================
   796 				; EVENT TRANSITON TO OVER
   797 				; ==========================================================================
   798 				; Event Process TRANSITION TO OVER
   799 				;
   800 				; Fade out all lines of the Dead Screen.  
   801 				; Fade in the lines of the Game Over Screen.
   802 				;
   803 				; This seems gratuitous, but it is necessary, because the screen can 
   804 				; be switched so fast that the user pressing the button on the Dead 
   805 				; Screen may not be able to release the button fast enough and end 
   806 				; up immediately dismissing the game over screen.  
   807 				;
   808 				; 1) Fade display to black.
   809 				; 2) Switch to Game Over display.
   810 				; 3) Fade in the Game Over text. 
   811 				; $) Switch to the Game Over event.
   812 				;
   813 				; Not feeling enterprising, so just use the Fade value from the Dead event.
   814 				; --------------------------------------------------------------------------
   815
   816 2843			EventTransitionGameOver
   817
   818 2843 A5 B0			lda AnimateFrames         ; Did animation counter reach 0 ?
   819 2845 D0 08			bne EndTransitionGameOver ; Nope.  Nothing to do.
   820 2847 A9 04			lda #GAME_OVER_SPEED      ; yes.  Reset it.
   821 2849 20 81 28			jsr ResetTimers
   822
   823 				;DoneWithTranOver               ; call counter is 0.  go to game over.
   824 284C 20 94 25			jsr SetupGameOver
   825
   826 284F			EndTransitionGameOver
   827
   828 284F 60				rts
   829
   830
   831 				; ==========================================================================
   832 				; EVENT GAME OVER SCREEN
   833 				; ==========================================================================
   834 				; Event Process GAME OVER SCREEN
   835 				; The Activity in the transition area, based on timer.
   836 				;
   837 				; --------------------------------------------------------------------------
   838
   839 2850			EventGameOverScreen
   840
   841 2850 A5 9B			lda EventStage
   842 2852 D0 10			bne OverScreenCheckTimers ; Not stage 0, skip button check
   843
   844 2854 20 49 3C			jsr WobbleDeWobble        ; tomb drawing spirograph art on the game over.  must do every frame.
   845 2857 20 F4 3A			jsr RunPromptForButton    ; Check button press.
   846 285A F0 08			beq OverScreenCheckTimers ; No press.  Skip the input section.  continue with timers, color scrolling.
   847
   848 				;ProcessGameOverScreenInput    ; a key is pressed. Prepare for the screen transition.
   849 285C 20 AE 3A			jsr HideButtonPrompt      ; Turn off the prompt
   850 285F E6 9B			inc EventStage            ; Setup Stage 1 for the screen fading ...
   851
   852 2861 20 15 3B			jsr RemoveFrogOnScreen    ; Tell VBI to erase and stop redrawing the animated object.
   853
   854 2864			OverScreenCheckTimers
   855 					; Animate the scrolling.
   856 2864 A5 B0			lda AnimateFrames         ; Did animation counter reach 0 ?
   857 2866 D0 18			bne EndGameOverScreen     ; No. Nothing to do.
   858 2868 A9 04			lda #GAME_OVER_SPEED      ; yes.  Reset animation timer.
   859 286A 20 81 28			jsr ResetTimers
   860
   861 286D A5 9B			lda EventStage   
   862 286F			OverStageZero                 ; Stage 0  cycling the background.
   863 286F D0 05			bne OverStageOne          ; non zero is stage 1 or 2 or 3 or ...
   864
   865 2871 20 A3 36			jsr GameOverRedSine       ; Load up the background colors. 
   866 2874 F0 0A			beq EndGameOverScreen     ; Yes.  Exit now. 
   867
   868 2876			OverStageOne                  ; and Stage Two and Three for the fade out effects.
   869 2876 20 8F 35			jsr CommonSplashFade      ; Do Stage 1, 2, 3.  On exit, expect A = EventStage, ends at 4
   870
   871 				; The actual end.
   872
   873 2879			OverStage4
   874 2879 C9 04			cmp #4                    ; Is EventStage == 4?
   875 287B D0 03			bne EndGameOverScreen
   876
   877 287D 20 85 24			jsr SetupTransitionToTitle
   878
   879 2880			EndGameOverScreen
   880
   881 2880 60				rts
   882
   711
   712 2881				icl "Frogger03TimerAndIO.asm"   ; Timer, countdowns, VBI, DLI
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03TimerAndIO.asm
     1 				; ==========================================================================
     2 				; Pet Frogger
     3 				; (c) November 1983 by John C. Dale, aka Dalesoft
     4 				; for the Commodore Pet 4032
     5 				; ==========================================================================
     6 				; Ported (parodied) to Atari 8-bit computers
     7 				; by Ken Jennings (if this were 1983, aka FTR Enterprises)
     8 				; ==========================================================================
     9 				; Version 00, November 2018
    10 				; Version 01, December 2018
    11 				; Version 02, February 2019
    12 				; Version 03, August 2019
    13 				; ==========================================================================
    14
    15 				; ==========================================================================
    16 				; TIMER STUFF AND INPUT
    17 				;
    18 				; Miscellaneous:
    19 				; Timer ranges
    20 				; Joystick input,
    21 				; Tick Tock values,
    22 				; Count downs,
    23 				; DLI and VBI routines.
    24 				; Prompt for Button press.
    25 				;
    26 				; --------------------------------------------------------------------------
    27
    28 				; ==========================================================================
    29 				; Animation speeds of various displayed items.   Number of frames to wait...
    30 				; --------------------------------------------------------------------------
    31 = 0003			BLINK_SPEED       = 3    ; Speed of updates to Press A Button prompt.
    32
    33 = 0002			TITLE_SPEED       = 2    ; Scrolling speed for title. 
    34 = 0003			TITLE_DOWN_SPEED  = 3    ; Shift title down before scroll.
    35 = 00B4			TITLE_RETURN_WAIT = 180  ; Time to wait to return to Stage 0.
    36 = 0000			TITLE_WIPE_SPEED  = 0    ; Title screen to game screen fade speed.
    37
    38 = 0002			WOBBLEX_SPEED     = 2    ; Speed of flying objects on Title and Game Over.
    39 = 0003			WOBBLEY_SPEED     = 3    ; Speed of flying objects on Title and Game Over.
    40
    41 = 0078			FROG_WAKE_SPEED   = 120  ; Initial delay about 2 sec for frog corpse viewing/mourning
    42 = 0004			DEAD_FADE_SPEED   = 4    ; Fade the game screen to black for Dead Frog
    43 = 0005			DEAD_CYCLE_SPEED  = 5    ; Speed of color animation on Dead screen
    44
    45 = 0004			WIN_FADE_SPEED    = 4    ; Fade the game screen to black to show Win
    46 = 0005			WIN_CYCLE_SPEED   = 5    ; Speed of color animation on Win screen 
    47
    48 = 0004			GAME_OVER_SPEED   = 4    ; Speed of Game over background animation
    49
    50
    51 				; Timer values.  NTSC.
    52 				; About 9-ish Inputs per second.
    53 				; After processing input (from the joystick) this is the number of frames
    54 				; to count before new input is accepted.  This prevents moving the frog at
    55 				; 60 fps and maybe compensates for any jitter/uneven toggling of the joystick
    56 				; bits by flaky controllers.
    57 				; At 9 events per second the frog moves horizontally 18 color clocks, max. 
    58 = 0007			INPUTSCAN_FRAMES = $07  ; previously $09
    59
    60
    61 				; PAL Timer values.  PAL ?? guesses...
    62 				; About 7 keys per second.
    63 				; KEYSCAN_FRAMES = $07
    64 				; based on number of frogs, how many frames between boat movements...
    65 				;ANIMATION_FRAMES .byte 25,21,17,14,12,11,10,9,8,7,6,5
    66 				; Not really sure what to do about the new model using the 
    67 				; BOAT_FRAMES/BOAT_SHIFT lists.
    68 				; PAL would definitely be a different set of speeds.
    69
    70
    71 				; ==========================================================================
    72 				; RESET TIMERS
    73 				; ==========================================================================
    74 				; Reset Input Scan Timer and AnimateFrames Timer.
    75 				;
    76 				; A  is the time to set for animation.
    77 				; --------------------------------------------------------------------------
    78
    79 2881			ResetTimers
    80
    81 2881 85 B0			sta AnimateFrames
    82
    83 2883 48				pha ; preserve it for caller.
    84
    85 2884 A5 98			lda InputScanFrames
    86 2886 D0 04			bne EndResetTimers
    87
    88 2888 A9 07			lda #INPUTSCAN_FRAMES
    89 288A 85 98			sta InputScanFrames
    90
    91 288C			EndResetTimers
    92 288C 68				pla ; get this back for the caller.
    93
    94 288D 60				rts
    95
    96
    97 				; ==========================================================================
    98 				; CHECK INPUT                                                 A  X
    99 				; ==========================================================================
   100 				; Check for input from the controller....
   101 				;
   102 				; Eliminate Down direction.
   103 				; Eliminate conflicting directions.
   104 				; Add trigger to the input stick value.
   105 				;
   106 				; STICK0 Joystick bits that matter:  
   107 				; ----1111  OR  "NA NA NA NA Right Left Down Up".
   108 				; A zero value bit means joystick is pushed in that direction.
   109 				; Note that 1 bit means no input and 0 bit means the direction
   110 				; is pressed.  For logical reasons I want to reverse this and 
   111 				; turn it into 1 bit means input.
   112 				; 
   113 				; The original version of this was an obscenely ill-conceived,
   114 				; sloppy mess of a dozen bit floggings and comparisons.
   115 				; The new version eliminates a lot of that original bit mashing
   116 				; with a simple lookup table. The only extra part now is adding
   117 				; the trigger to the input information.
   118 				;
   119 				; Description of the bit twiddling below:
   120 				;
   121 				; Cook the bits to turn on the directions we care about and zero
   122 				; the other bits, therefore, if the resulting stick value is 0 then 
   123 				; it means no input, which is an easier evaluation.
   124 				; - Down input is ignored (masked out).
   125 				; - Since up movement is the most likely to result in death the 
   126 				;   up movement must be exclusively up.  If a horizontal 
   127 				;   movement is also on at the same time then the up movement 
   128 				;   will be masked out.
   129 				;
   130 				; Arcade controllers with individual buttons would allow 
   131 				; accidentally (or intentionally) pushing both left and right 
   132 				; directions at the same time.  To avoid unnecessary fiddling 
   133 				; with the frog in this situation eliminate both motions if both
   134 				; are engaged.
   135 				;
   136 				; STRIG0 Button
   137 				; 0 is button pressed., !0 is not pressed.
   138 				; If STRIG0 input then set bit $10 (OR ---1----  for trigger.
   139 				;
   140 				; Return  A  with InputStick value of cooked Input bits where 
   141 				; the direction and trigger set are 1 bits.  
   142 				;
   143 				; Resulting Bit values:   
   144 				; 00011101  OR  "NA NA NA Trigger Right Left NA Up"
   145 				; THEREFORE,
   146 				; STICK   / BITS    / FILTERED / BITS
   147 				; R L D U / 0 0 0 0 / - - - -  / 0 0 0 0  - input is technically impossible 
   148 				; R L D - / 0 0 0 1 / - - - -  / 0 0 0 0  - input is technically impossible 
   149 				; R L - U / 0 0 1 0 / - - - -  / 0 0 0 0  - input is technically impossible 
   150 				; R L - - / 0 0 1 1 / - - - -  / 0 0 0 0  - input is technically impossible 
   151 				; R - D U / 0 1 0 0 / - - - -  / 0 0 0 0  - input is technically impossible 
   152 				; R - D - / 0 1 0 1 / R - - -  / 1 0 0 0  - down ignored 
   153 				; R - - U / 0 1 1 0 / R - - -  / 1 0 0 0  - up must be exclusively up 
   154 				; R - - - / 0 1 1 1 / R - - -  / 1 0 0 0  - right 
   155 				; - L D U / 1 0 0 0 / - - - -  / 0 0 0 0 -  input is technically impossible 
   156 				; - L D - / 1 0 0 1 / - L - -  / 0 1 0 0  - down ignored 
   157 				; - L - U / 1 0 1 0 / - L - -  / 0 1 0 0  - up must be exclusively up 
   158 				; - L - - / 1 0 1 1 / - L - -  / 0 1 0 0  - left  
   159 				; - - D U / 1 1 0 0 / - - - -  / 0 0 0 0  - input is technically impossible 
   160 				; - - D - / 1 1 0 1 / - - - -  / 0 0 0 0  - down ignored 
   161 				; - - - U / 1 1 1 0 / - - - U  / 0 0 0 1  - up is exclusively up 
   162 				; - - - - / 1 1 1 1 / - - - -  / 0 0 0 0  - nothing
   163 				; --------------------------------------------------------------------------
   164
   165 288E			STICKEMUPORNOT_TABLE ; cooked joystick values
   166 288E 00 00 00 00 00 08 + 	.by $00 $00 $00 $00 $00 $08 $08 $08 $00 $04 $04 $04 $00 $00 $01 $00
   167
   168 289E			CheckInput
   169
   170 289E A5 98			lda InputScanFrames        ; Is input timer delay  0?
   171 28A0 D0 22			bne SetNoInput             ; No. thus nothing to scan. (and exit)
   172
   173 28A2 AE 78 02			ldx STICK0                 ; The OS nicely separates PIA nybbles for us
   174 28A5 BD 8E 28			lda STICKEMUPORNOT_TABLE,x ; Convert input into workable, filtered output.
   175 28A8 85 99			sta InputStick             ; Save it.
   176
   177 				;AddTriggerInput
   178 28AA AD 84 02			lda STRIG0                 ; 0 is button pressed., !0 is not pressed.
   179 28AD D0 06			bne DoneWithBitCookery     ; if non-zero, then no button pressed.
   180
   181 28AF A5 99			lda InputStick             ; The current stick input value.
   182 28B1 09 10			ora #%00010000             ; Turn on 5th bit/$10 for the trigger.
   183 28B3 85 99			sta InputStick             ; Save it.  (fall through for return..)
   184
   185 28B5			DoneWithBitCookery             ; Some input was captured?
   186 28B5 A5 99			lda InputStick             ; Return the input value?
   187 28B7 F0 0F			beq ExitCheckInput         ; No, nothing happened here.  Just exit.
   188
   189 28B9 A9 07			lda #INPUTSCAN_FRAMES      ; Because there was input collected, then
   190 28BB 85 98			sta InputScanFrames        ; Reset the input timer.
   191
   192 				;ExitInputCollection            ; Input occurred
   193 28BD A9 00			lda #0                     ; Kill the attract mode flag
   194 28BF 85 4D			sta ATRACT                 ; to prevent color cycling.
   195
   196 28C1 A5 99			lda InputStick             ; Return the input value.
   197 28C3 60				rts
   198
   199 28C4			SetNoInput
   200 28C4 A9 00			lda #0
   201 28C6 85 99			sta InputStick             ; Force no data for input.
   202
   203 28C8			ExitCheckInput
   204 28C8 60				rts
   205
   206
   207 				; ==========================================================================
   208 				; CHECK FOR CONSOLE INPUT
   209 				; ==========================================================================
   210 				; Support Routine CHECK FOR CONSOLE INPUT
   211 				; Evaluate if console key is pressed.
   212 				; This is called during the Title-specific event.
   213 				; If a console key is pressed then do the associated game config value 
   214 				; changes, prepare the Title line scrolling, and set the Title screen 
   215 				; to execute at Stage 2.
   216 				;
   217 				; Returns:
   218 				; 0 for no input.
   219 				; !0 for a CONSOLE key was pressed.
   220 				; --------------------------------------------------------------------------
   221
   222 28C9			CheckForConsoleInput
   223
   224 28C9			CheckOptionKey
   225 28C9 AD 1F D0			lda CONSOL                 ; Get Option, Select, Start buttons
   226 28CC 29 04			and #CONSOLE_OPTION        ; Is Option pressed?  0 = pressed. 1 = not
   227 28CE D0 17			bne CheckSelectKey         ; No.  Try the select.
   228
   229 28D0 20 D6 31			jsr PlayTink               ; Button pressed. Set Pokey channel 2 to tink sound.
   230
   231 					; increment starting frogs.
   232 					; generate string for right buffer
   233 28D3 A6 8C			ldx NewLevelStart          
   234 28D5 E8				inx
   235 28D6 E0 07			cpx #[MAX_FROG_SPEED+1]    ; 13 + 1
   236 28D8 D0 02			bne bCFCI_SkipResetLevel
   237 28DA A2 00			ldx #0
   238 28DC			bCFCI_SkipResetLevel
   239 28DC 86 8C			stx NewLevelStart          ; Updated starting level.
   240
   241 28DE 20 BB 39			jsr TitlePrepLevel
   242 28E1 20 50 24			jsr MultiplyFrogsCrossed ; Multiply by 18, make index base, set difficulty address pointers.
   243 28E4 4C 02 29			jmp bCFCI_StartupStage2
   244
   245
   246 28E7			CheckSelectKey
   247 28E7 AD 1F D0			lda CONSOL                 ; Get Option, Select, Start buttons
   248 28EA 29 02			and #CONSOLE_SELECT        ; Is SELECT pressed?  0 = pressed. 1 = not
   249 28EC D0 26			bne bCFCI_End              ; No.  Finished with all.
   250
   251 28EE 20 D6 31			jsr PlayTink               ; Button pressed. Set Pokey channel 2 to tink sound.
   252
   253 					; increment lives.
   254 					; generate string for right buffer
   255 28F1 A6 8F			ldx NewNumberOfLives
   256 28F3 E8				inx
   257 28F4 E0 08			cpx #[MAX_FROG_LIVES+1]    ; 7 + 1
   258 28F6 D0 02			bne bCFCI_SkipResetLives
   259 28F8 A2 01			ldx #1
   260 28FA			bCFCI_SkipResetLives
   261 28FA 86 8F			stx NewNumberOfLives      ; Get the updated number of new lives for the next game.
   262 28FC 20 D0 39			jsr TitlePrepLives        ; Get the scrolling buffer ready.
   263 28FF 20 59 34			jsr WriteNewLives         ; Update the status line to match the new number of frogs.
   264
   265 2902			bCFCI_StartupStage2
   266 2902 A9 02			lda #2
   267 2904 85 9B			sta EventStage            ; Stage 2 is the shift Left Buffer down.
   268 2906 A9 06			lda #6
   269 2908 85 9C			sta EventCounter          ; Do it six times.
   270 290A A9 03			lda #TITLE_DOWN_SPEED
   271 290C 20 81 28			jsr ResetTimers           ; Reset animation/input frame counter.
   272
   273 290F 20 12 32			jsr PlayDowns             ; Play down movement sound for title graphics on OPTION and SELECT
   274 2912 D0 02			bne bCFCI_Exit            ; Return !0 exit.
   275
   276 2914			bCFCI_End
   277 2914 A9 00			lda #0  ; 0 means nothing happened.
   278
   279 2916			bCFCI_Exit
   280 2916 60				rts
   281
   282
   283 				;==============================================================================
   284 				;                                                           SCREENWAITFRAME  A
   285 				;==============================================================================
   286 				; Subroutine to wait for the current frame to finish display.
   287 				;
   288 				; ScreenWaitFrame  uses A
   289 				;==============================================================================
   290
   291 2917			libScreenWaitFrame
   292
   293 2917 48				pha                 ; Save A, so caller is not disturbed.
   294 2918 A5 14			lda RTCLOK60        ; Read the jiffy clock incremented during vertical blank.
   295
   296 291A			bLoopWaitFrame
   297 291A C5 14			cmp RTCLOK60        ; Is it still the same?
   298 291C F0 FC			beq bLoopWaitFrame  ; Yes.  Then the frame has not ended.
   299
   300 291E 68				pla                 ; restore A
   301 291F 60				rts                 ; No.  Clock changed means frame ended.  exit.
   302
   303
   304
   305 				;==============================================================================
   306 				;                                                           MyImmediateVBI
   307 				;==============================================================================
   308 				; Immediate Vertical Blank Interrupt.
   309 				;
   310 				; Frame-critical tasks:
   311 				; Force steady state of DLI.
   312 				; Manage switching displays.
   313 				;
   314 				; Optional Input: VBICurrentDL  
   315 				; ID number for new Display sent by Main.  Reset to -1 by VBI.
   316 				; DISPLAY_TITLE = 0
   317 				; DISPLAY_GAME  = 1
   318 				; DISPLAY_WIN   = 2
   319 				; DISPLAY_DEAD  = 3
   320 				; DISPLAY_OVER  = 4
   321 				;
   322 				; Output: CurrentDL 
   323 				; Set by VBI to the display number when the Display is changed.
   324 				;==============================================================================
   325
   326 2920			MyImmediateVBI
   327
   328 				; ======== Manage Changing Display List ========
   329 2920 A5 B4			lda VBICurrentDL            ; Did Main code signal to change displays?
   330 2922 30 2E			bmi VBIResetDLIChain        ; -1, No, just restore current DLI chain.
   331
   332 				;VBISetupDisplay
   333 2924 AA				tax                         ; Use VBICurrentDL  as index to tables.
   334
   335 2925 BD 00 50			lda DISPLAYLIST_LO_TABLE,x  ; Copy Display List Pointer
   336 2928 8D 30 02			sta SDLSTL                  ; for the OS
   337 292B BD 05 50			lda DISPLAYLIST_HI_TABLE,x
   338 292E 8D 31 02			sta SDLSTH
   339
   340 2931 BD 0F 50			lda DLI_LO_TABLE,x          ; Copy Display List Interrupt chain table starting address
   341 2934 85 A7			sta ThisDLIAddr
   342 2936 BD 14 50			lda DLI_HI_TABLE,x
   343 2939 85 A8			sta ThisDLIAddr+1
   344
   345 293B BD DC 52			lda BASE_PMG_LO_TABLE,x     ; Copy PMG Settings table base address
   346 293E 85 9E			sta BasePmgAddr
   347 2940 BD E1 52			lda BASE_PMG_HI_TABLE,x
   348 2943 85 9F			sta BasePmgAddr+1
   349
   350 2945 86 B5			stx CurrentDL               ; Let Main know this is now the current screen.
   351 2947 A9 FF			lda #$FF                    ; Turn off the signal from Main to change screens.
   352 2949 85 B4			sta VBICurrentDL
   353
   354 294B E0 00			cpx #DISPLAY_TITLE          ; Is this the Title display?
   355 294D D0 03			bne VBIResetDLIChain        ; No, continue with DLI reset.
   356 294F 20 66 3A			jsr TitleSetOrigin          ; Title screen.  Reset scrolling to origin.
   357
   358 2952			VBIResetDLIChain
   359 2952 A0 00			ldy #0
   360 2954 B1 A7			lda (ThisDLIAddr),y         ; Grab 0 entry from this DLI chain
   361 2956 8D 00 02			sta VDSLST                  ; and restart the DLI routine.
   362 2959 A9 2B			lda #>TITLE_DLI
   363 295B 8D 01 02			sta VDSLST+1
   364
   365 295E C8				iny                         ; !!! Start at 1, because entry 0 provided the starting DLI address !!!
   366 295F 84 A9			sty ThisDLI 
   367 					; This means indexed pulls from the color tables are +1 from the current DLI.
   368
   369 				; Stage colors and HSCROL for first DLI into page 0 
   370 				; to make selecting these faster during the DLI.
   371 2961 20 24 2C			jsr SetupAllColors
   372
   373 2964			ExitMyImmediateVBI
   374
   375 2964 4C 5F E4			jmp SYSVBV ; Return to OS.  XITVBV for Deferred interrupt.
   376
   377
   378
   379 				;==============================================================================
   380 				;                                                           MyDeferredVBI
   381 				;==============================================================================
   382 				; Deferred Vertical Blank Interrupt.
   383 				;
   384 				; Tasks that tolerate more laziness.  In fact, most of the screen activity
   385 				; occurs here.
   386 				;
   387 				; Manage death of frog. 
   388 				; Fine Scroll the boats.
   389 				; Update Player/Missile object display.
   390 				; Perform the boat parts animations.
   391 				; Manage timers and countdowns.
   392 				; Scroll the line of credit text.
   393 				; Blink the Press Button prompt if enabled.
   394 				;==============================================================================
   395
   396 2967			MyDeferredVBI
   397
   398 				; ======== Manage Frog Death  ========
   399 				; Here we are at the end of the frame.  Collision is checked first.  
   400 				; The actual movement processing happens last.
   401 				; If the CURRENT row of the frog is on a moving boat row, then go collect 
   402 				; the collision information with the "safe" area of the boat 
   403 				; (the horizontal lines, COLPF2 are the safety color).
   404 				; "Current" from the VBI point of view means the last place the frog was 
   405 				; displayed on the previous frame.  ("New" is where the frog will be 
   406 				; displayed on the next frame.)
   407 				; The collision check code will flag the death accordingly.
   408 				; The Flag-Of-Death (FrogSafety) tells the Main code to splatter the frog 
   409 				; shape, and start the other activities to announce death.
   410
   411 2967			ManageDeathOfASalesfrog
   412 2967 A5 B5			lda CurrentDL                ; Get current display list
   413 2969 C9 01			cmp #DISPLAY_GAME            ; Is this the Game display?
   414 296B D0 0A			bne EndOfDeathOfASalesfrog   ; No. So no collision processing. 
   415
   416 296D A6 80			ldx FrogRow                  ; What screen row is the frog currently on?
   417 296F BD 31 23			lda MOVING_ROW_STATES,x      ; Is the current Row a boat row?
   418 2972 F0 03			beq EndOfDeathOfASalesfrog   ; No. So skip collision processing. 
   419
   420 2974 20 80 3C			jsr CheckRideTheBoat         ; Make sure the frog is riding the boat. Otherwise it dies.
   421
   422 2977			EndOfDeathOfASalesfrog
   423 				;	sta HITCLR                   ; Always reset the P/M collision bits for next frame.
   424
   425
   426 				; ======== Manage Boat fine scrolling ========
   427 				; Atari scrolling is such low overhead. 
   428 				; (Evaluate frog shift if it is on a boat row).
   429 				; On a boat row...
   430 				; Update a fine scroll register.
   431 				; Update a coarse scroll register sometimes.
   432 				; Done.   
   433 				; Scrolling is practically free.  
   434 				; It may be easier only on an Amiga.
   435
   436 2977			ManageBoatScrolling
   437 2977 A5 B5			lda CurrentDL                 ; Get current display list
   438 2979 C9 01			cmp #DISPLAY_GAME             ; Is this the Game display?
   439 297B D0 29			bne EndOfBoatScrolling        ; No.  Skip the scrolling logic.
   440
   441 297D A0 01			ldy #1                        ; Current Row.  Row 0 is the safe zone, no scrolling happens there.
   442
   443 				; Common code to each row. 
   444 				; Loop through rows.
   445 				; If is is a moving row, then check the row's timer/frame counter.
   446 				; If the timer is over, then reset the timer, and then fine scroll 
   447 				; the row (also moving the frog with it as needed.)
   448
   449 297F			LoopBoatScrolling
   450 					; Need row in X and Y due to different 6502 addressing modes in the timer and scroll functions.
   451 297F 98				tya                           ; A = Y, Current Row 
   452 2980 AA				tax                           ; X = A, Current Row.  Can't dec zeropage,x, darn you cpu.
   453
   454 2981 B9 31 23			lda MOVING_ROW_STATES,y       ; Get the current Row State
   455 2984 F0 1B			beq EndOfScrollLoop           ; Not a scrolling row.  Go to next row.
   456 2986 08				php                           ; Save the + or - status until later.
   457 					; We know this is either left or right, so this block is common code
   458 					; to update the row's speed counter based on the row entry.
   459 2987 B5 BD			lda CurrentBoatFrames,x       ; Get the row's frame delay value.
   460 2989 F0 06			beq ResetBoatFrames           ; If BoatFrames is 0, time to make the donuts.
   461 298B D6 BD			dec CurrentBoatFrames,x       ; Not zero, so decrement
   462 298D 28				plp                           ; oops.  got to dispose of that.
   463 298E 4C A1 29			jmp EndOfScrollLoop           
   464
   465 2991			ResetBoatFrames
   466 2991 B1 D0			lda (BoatFramesPointer),y     ; Get master value for row's frame delay
   467 2993 95 BD			sta CurrentBoatFrames,x       ; Restart the row's frame speed delay.
   468
   469 2995 28				plp                           ; Get the current Row State (again.)
   470 2996 30 06			bmi LeftBoatScroll            ; 0 already bypassed.  1 = Right, -1 (FF) = Left.
   471
   472 2998 20 B3 38			jsr RightBoatFineScrolling    ; Do Right Boat Fine Scrolling.  (and frog X update) 
   473 299B 4C A1 29			jmp EndOfScrollLoop           ; end of this row.  go to the next one.
   474
   475 299E			LeftBoatScroll
   476 299E 20 E5 38			jsr LeftBoatFineScrolling     ; Do Left Boat Fine Scrolling.  (and frog X update) 
   477
   478 29A1			EndOfScrollLoop                   ; end of this row.  go to the next one.
   479 29A1 C8				iny                           ; Y reliably has Row.  X was changed.
   480 29A2 C0 12			cpy #18                       ; Last entry is beach.  Do not bother to go further.
   481 29A4 D0 D9			bne LoopBoatScrolling         ; Not 18.  Process the next row.
   482
   483 29A6			EndOfBoatScrolling
   484
   485
   486 				; ======== Manage InputScanFrames Delay Counter ========
   487 				; It is MAIN's job to act when the timer is 0, and reset it if needed.
   488
   489 29A6			DoManageInputClock
   490 29A6 A5 98			lda InputScanFrames          ; Is input delay already 0?
   491 29A8 F0 02			beq DoAnimateClock           ; Yes, do not decrement it again.
   492 29AA C6 98			dec InputScanFrames          ; Minus 1.
   493
   494 				; ======== Manage Main code's timer.  Decrement while non-zero. ========
   495 				; It is MAIN's job to act when the timer is 0, and reset it if needed.
   496
   497 29AC			DoAnimateClock
   498 29AC A5 B0			lda AnimateFrames            ; Is animation countdown already 0?
   499 29AE F0 02			beq DoAnimateClock2          ; Yes, do not decrement now.
   500 29B0 C6 B0			dec AnimateFrames            ; Minus 1
   501
   502 				; ======== Manage Another Main code timer.  Decrement while non-zero. ========
   503 				; It is MAIN's job to act when the timer is 0, and reset it if needed.
   504
   505 29B2			DoAnimateClock2
   506 29B2 A5 B1			lda AnimateFrames2           ; Is animation countdown already 0?
   507 29B4 F0 02			beq DoAnimateClock3          ; Yes, do not decrement now.
   508 29B6 C6 B1			dec AnimateFrames2           ; Minus 1
   509
   510 				; ======== Manage Another Main code timer.  Decrement while non-zero. ========
   511 				; It is MAIN's job to act when the timer is 0, and reset it if needed.
   512
   513 29B8			DoAnimateClock3
   514 29B8 A5 B2			lda AnimateFrames3           ; Is animation countdown already 0?
   515 29BA F0 02			beq DoAnimateClock4          ; Yes, do not decrement now.
   516 29BC C6 B2			dec AnimateFrames3           ; Minus 1
   517 					
   518 				; ======== Manage Another Main code timer.  Decrement while non-zero. ========
   519 				; It is MAIN's job to act when the timer is 0, and reset it if needed.
   520
   521 29BE			DoAnimateClock4
   522 29BE A5 B3			lda AnimateFrames4           ; Is animation countdown already 0?
   523 29C0 F0 02			beq EndOfTimers              ; Yes, do not decrement now.
   524 29C2 C6 B3			dec AnimateFrames4           ; Minus 1
   525
   526 29C4			EndOfTimers
   527
   528 				; ======== Manage Frog Eyeball motion ========
   529 				; If the timer is non-zero, Change eyeball position and force redraw.
   530 				; This nicely multi-tasks the eyes to return to center even if MAIN is 
   531 				; is not doing anything related to the frog.
   532
   533 29C4			DoAnimateEyeballs
   534 29C4 A5 BC			lda FrogRefocus              ; Is the eye move counter greater than 0?
   535 29C6 F0 10			beq EndOfClockChecks         ; No, Nothing else to do here.
   536 29C8 C6 BC			dec FrogRefocus              ; Subtract 1.
   537 29CA D0 0C			bne EndOfClockChecks         ; Has not reached 0, so nothing left to do here.
   538 29CC A5 86			lda FrogShape                ; Maybe the player raced the timer to the next screen...
   539 29CE C9 01			cmp #SHAPE_FROG              ; ... so verify the frog is still displayable.
   540 29D0 D0 06			bne EndOfClockChecks         ; Not the frog, so do not animate eyes.
   541 29D2 A9 01			lda #1                       ; Inform the Frog renderer  
   542 29D4 85 BB			sta FrogEyeball              ; to use the default/centered eyeball.
   543 29D6 85 88			sta FrogUpdate               ; and set mandatory redraw.
   544
   545 29D8			EndOfClockChecks
   546
   547
   548 				; ======== Reposition the Frog (or Splat). ========
   549 				; At this point everyone and their cousin have been giving their advice 
   550 				; about the frog position.  The main code changed position based on joystick
   551 				; input.  The VBI change position if the frog was on a scrolling boat row.
   552 				; Here, finally apply the position and move the frog image.
   553
   554 29D8			MaintainFrogliness
   555 29D8 A5 88			lda FrogUpdate               ; Nonzero means something important needs to be updated.
   556 29DA D0 04			bne SimplyUpdatePosition
   557
   558 29DC A5 87			lda FrogNewShape             ; Get the new frog shape.
   559 29DE F0 03			beq NoFrogUpdate             ; 0 is off, so no movement there at all, so skip all
   560
   561 				; ==== Frog and boat position gyrations are done.  ==== Is there actual movement?
   562 29E0			SimplyUpdatePosition
   563 29E0 20 73 3E			jsr ProcessNewShapePosition  ; limit object to screen.  redraw the object.
   564
   565 29E3			NoFrogUpdate
   566
   567
   568 				; ======== Fade Score Label Text  ========
   569 				; Game will brighten text label when changing a value.
   570 				; Here we detect if a change needs to be made, and then 
   571 				; decrement the color if so.  All colors end at luminance
   572 				; value $04.  Luminance $00 means no further consideration.
   573
   574 29E3			ManageScoredFades
   575 29E3 A6 B5			ldx CurrentDL
   576 29E5 BD D2 52			lda MANAGE_SCORE_COLORS_TABLE,x
   577 29E8 F0 32			beq EndManageScoreFades
   578
   579 29EA			DoFadeScore
   580 29EA AD 8E 51			lda COLPM0_TABLE       ; Get Color.
   581 29ED 20 44 24			jsr DecThisColorOrNot  ; Can it be decremented?
   582 29F0 8D 8E 51			sta COLPM0_TABLE       ; Re-Save Color
   583 29F3 8D 91 51			sta COLPM1_TABLE       ; Second half of the same object is same color
   584
   585 29F6			DoFadeHiScore
   586 29F6 AD 94 51			lda COLPM2_TABLE       ; Get Color.
   587 29F9 20 44 24			jsr DecThisColorOrNot  ; Can it be decremented?
   588 29FC 8D 94 51			sta COLPM2_TABLE       ; Re-Save Color 
   589
   590 29FF			DoFadeLives
   591 29FF BD D7 52			lda MANAGE_LIVES_COLORS_TABLE,x ; Is this a thing to do on this display.
   592 2A02 F0 18			beq EndManageScoreFades
   593
   594 2A04 AD 8F 51			lda COLPM0_TABLE+1     ; Get Color.
   595 2A07 20 44 24			jsr DecThisColorOrNot  ; Can it be decremented?
   596 2A0A 8D 8F 51			sta COLPM0_TABLE+1     ; Re-Save Color
   597 2A0D 8D 92 51			sta COLPM1_TABLE+1     ; Second half of the same object is same color
   598
   599 2A10			DoFadeSaved
   600 2A10 AD 95 51			lda COLPM2_TABLE+1     ; Get Color.
   601 2A13 20 44 24			jsr DecThisColorOrNot  ; Can it be decremented?
   602 2A16 8D 95 51			sta COLPM2_TABLE+1     ; Re-Save Color
   603 2A19 8D 98 51			sta COLPM3_TABLE+1     ; Second half of the same object is same color
   604
   605 2A1C			EndManageScoreFades
   606
   607
   608 				; ======== Manage Title Graphics Fine Scrolling  ========
   609 				; Left Scroll the title graphics.
   610 				; When it reaches target location reset the flag to disable scrolling.
   611 				; Set the timer to tell MAIN to restore the title.
   612 				; If the timer is non-zero, then decrement it.
   613 				;
   614 				; MAIN is expected to setup buffers and reset scroll position to 
   615 				; origin before setting  VBIEnableScrollTitle  to start scrolling.
   616
   617 2A1C			ManageTitleScrolling
   618 2A1C A5 B6			lda VBIEnableScrollTitle     ; Is scrolling turned on?
   619 2A1E F0 10			beq WaitToRestoreTitle       ; No. See if the timer needs something.
   620
   621 2A20 20 2D 39			jsr TitleLeftScroll          ; Scroll it
   622 2A23 20 23 39			jsr TitleIsItAtTheEnd        ; Is it done?  Zero return is over.
   623 2A26 D0 0E			bne EndManageTitleScrolling  ; Nope.  Do again on the next frame.
   624
   625 2A28 A9 00			lda #0                       ; Reached target position.
   626 2A2A 85 B6			sta VBIEnableScrollTitle     ; Turn off further left scrolling.
   627 2A2C A9 B4			lda #TITLE_RETURN_WAIT       ; Set the timer to wait to restore the title.
   628 2A2E 85 B8			sta RestoreTitleTimer        ; Set new timeout value.
   629
   630 2A30			WaitToRestoreTitle               ; Tell Main when to restore title.
   631 2A30 A5 B8			lda RestoreTitleTimer        ; Get timer value.
   632 2A32 F0 02			beq EndManageTitleScrolling  ; Its 0?  Then skip this.
   633 2A34 C6 B8			dec RestoreTitleTimer        ; Decrement timer when non-zero.
   634
   635 2A36			EndManageTitleScrolling
   636
   637
   638 				; ======== Animate Boat Components ========
   639 				; Parts of the boats are animated to look like they're moving 
   640 				; through the water.
   641 				; When BoatyMcBoatCounter is 0, then animate based on BoatyComponent
   642 				; thus only one part of a boat is animated on any given vertical blank.
   643 				; 0 = Right Boat Front
   644 				; 1 = Right Boat Back
   645 				; 2 = Left Boat Front
   646 				; 3 = Left Boat Back
   647 				;BoatyFrame         .byte 0  ; counts 0 to 7.
   648 				;BoatyMcBoatCounter .byte 2  ; decrement.  On 0 animate a component.
   649 				;BoatyComponent     .byte 0  ; 0, 1, 2, 3 one of the four boat parts.
   650
   651 2A36			ManageBoatAnimations
   652 2A36 C6 D4			dec BoatyMcBoatCounter        ; subtract from scroll delay counter
   653 2A38 D0 1B			bne ExitBoatyness             ; Not 0 yet, so no animation.
   654
   655 					; One of the boat components will be animated. 
   656 2A3A A9 02			lda #2                        ; Reset counter to original value.
   657 2A3C 85 D4			sta BoatyMcBoatCounter
   658
   659 2A3E A6 D6			ldx BoatyFrame                ; going to load a frame, which one?
   660 2A40 20 B2 37			jsr DoBoatCharacterAnimation  ; load the frame for the current component.
   661
   662 				; Finish by setting up for next frame/component.
   663 2A43 E6 D5			inc BoatyComponent            ; increment to next visual component for next time.
   664 2A45 A5 D5			lda BoatyComponent            ; get it to mask it 
   665 2A47 29 03			and #$03                      ; mask it to value 0 to 3
   666 2A49 85 D5			sta BoatyComponent            ; Save it.
   667 2A4B D0 08			bne ExitBoatyness             ; it is non-zero, so no new frame counter.
   668
   669 				; Whenever the boat component returns to 0, then update the frame counter...
   670 2A4D E6 D6			inc BoatyFrame                ; next frame.
   671 2A4F A5 D6			lda BoatyFrame                ; get it to mask it.
   672 2A51 29 07			and #$07                      ; mask it to 0 to 7
   673 2A53 85 D6			sta BoatyFrame                ; save it.
   674
   675 2A55			ExitBoatyness
   676
   677
   678 				; ======== Manage the prompt flashing for Press A Button ========
   679 2A55			ManagePressAButtonPrompt
   680 2A55 A5 DB			lda EnablePressAButton
   681 2A57 D0 08			bne DoAnimateButtonTimer      ; Not zero means enabled.
   682 					; Prompt is off.  Zero everything.
   683 2A59 85 DE			sta PressAButtonColor         ; Set background
   684 2A5B 85 DF			sta PressAButtonText          ; Set text.
   685 2A5D 85 DD			sta PressAButtonFrames        ; This makes sure it will restart as soon as enabled.
   686 2A5F F0 0B			beq DoCheesySoundService  
   687
   688 				; Note that the Enable/Disable behavior connected to the timer mechanism 
   689 				; means that the action will occur when this timer executes with value 1 
   690 				; or 0. At 1 it will be decremented to become 0. The value 0 is evaluated 
   691 				; immediately.
   692 2A61			DoAnimateButtonTimer
   693 2A61 A5 DD			lda PressAButtonFrames   
   694 2A63 F0 04			beq DoPromptColorchange       ; Timer is Zero.  Go switch colors.
   695 2A65 C6 DD			dec PressAButtonFrames        ; Minus 1
   696 2A67 D0 03			bne DoCheesySoundService      ; if it is still non-zero end this section.
   697
   698 2A69			DoPromptColorchange
   699 2A69 20 BC 3A			jsr ToggleButtonPrompt        ; Manipulates colors for prompt.
   700
   701 2A6C			DoCheesySoundService              ; World's most inept sound sequencer.
   702 2A6C 20 90 32			jsr SoundService
   703
   704
   705 				; ======== Manage scrolling the Credits text ========
   706 2A6F			ScrollTheCreditLine               ; Scroll the text identifying the perpetrators
   707 2A6F C6 B9			dec ScrollCounter             ; subtract from scroll delay counter
   708 2A71 D0 07			bne EndOfScrollTheCredits     ; Not 0 yet, so no scrolling.
   709 2A73 A9 02			lda #2                        ; Reset counter to original value.
   710 2A75 85 B9			sta ScrollCounter
   711
   712 2A77 20 77 38			jsr FineScrollTheCreditLine   ; Do the business.
   713
   714 2A7A			EndOfScrollTheCredits
   715
   716
   717 2A7A			ExitMyDeferredVBI
   718
   719 2A7A 4C 62 E4			jmp XITVBV                    ; Return to OS.  SYSVBV for Immediate interrupt.
   720
   721
   722 				;==============================================================================
   723
   724
   725 2A7D				.align $0100 ; Make the DLIs start in the same page to simplify chaining. I hope.
   726
   727
   728 				;==============================================================================
   729 				;                                                           MyDLI
   730 				;==============================================================================
   731 				; Display List Interrupts
   732 				;
   733 				; Note the DLIs don't care where the ThisDLI index ends as 
   734 				; this is managed by the VBI.
   735 				;==============================================================================
   736
   737 				; shorthand for starting DLI  (that do not JMP immediately to common code)
   738 					.macro mStart_DLI
   739 						mregSaveAY
   740 				
   741 						ldy ThisDLI
   742 					.endm
   743
   744
   745 				;==============================================================================
   746 				; TITLE DLIs
   747 				;==============================================================================
   748
   749 2B00			TITLE_DLI  ; Placeholder for VBI to restore staring address for DLI chain.
   750
   751 				;==============================================================================
   752 				; TITLE_DLI_BLACKOUT                                             
   753 				;==============================================================================
   754 				; DLI Sets background to Black for blank areas.
   755 				;
   756 				; Note that the Title screen uses the COLBK table for both COLBK and COLPF2.
   757 				; -----------------------------------------------------------------------------
   758
   759 2B00			TITLE_DLI_BLACKOUT  ; DLI Sets background to Black for blank area.
   760
   761 2B00-2DC9> 48			pha
   762
   763 2B01 A9 00			lda #COLOR_BLACK     ; Black for background and text background.
   764 2B03 8D 0A D4			sta WSYNC            ; sync to end of scan line
   765 2B06 8D 1A D0			sta COLBK            ; Write new border color.
   766 2B09 8D 18 D0			sta COLPF2           ; Write new background color
   767
   768 2B0C 98				tya
   769 2B0D 48				pha
   770 2B0E A4 A9			ldy ThisDLI
   771
   772 2B10 4C 05 2C			jmp SetupAllOnNextLine_DLI ; Load colors for next DLI and end.
   773
   774
   775 				;==============================================================================
   776 				; TITLE_DLI_TEXTBLOCK                                             
   777 				;==============================================================================
   778 				; DLI sets COLPF1 text luminance from the table, COLBK and COLPF2 to 
   779 				; start a text block.
   780 				; Since there is no text in blank lines, it does not matter that COLPF1 is 
   781 				; written before WSYNC.
   782 				; Also, since text characters are not defined to the top/bottom edge of the 
   783 				; character it is  safe to change COLPF1 in a sloppy way.
   784 				; -----------------------------------------------------------------------------
   785
   786 2B13			TITLE_DLI_TEXTBLOCK
   787
   788 2B13				mStart_DLI
Macro: MSTART_DLI [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03TimerAndIO.asm]
     1 2B13 48				PHA 
     2 2B14 98				TYA 
     3 2B15 48				PHA  
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03TimerAndIO.asm
     3 2B16 A4 A9				ldy ThisDLI
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03TimerAndIO.asm
   789
   790 2B18 A5 AC			lda ColorPf1         ; Get text luminance from zero page.
   791 2B1A 8D 17 D0			sta COLPF1           ; write new text luminance.
   792
   793 2B1D A5 AA			lda ColorBak         ; Get background from zero page.
   794 2B1F 8D 0A D4			sta WSYNC
   795 2B22 8D 1A D0			sta COLBK
   796 2B25 8D 18 D0			sta COLPF2
   797
   798 2B28 4C 05 2C			jmp SetupAllOnNextLine_DLI ; Load colors for next DLI and end.
   799
   800
   801 				;==============================================================================
   802 				; GAME DLIs
   803 				;==============================================================================
   804
   805 				;==============================================================================
   806 				; SCORE 1 DLI                                                            A 
   807 				;==============================================================================
   808 				; Used on Game displays.  
   809 				; This is called on a blank before the text line. 
   810 				; The VBI should have loaded up the Page zero staged colors. 
   811 				; Only ColorPF1 matters for the playfield as the background and border will 
   812 				; be forced to black. 
   813 				; This also sets Player/Missile parameters for P0,P1,P2, M0 and M1 to show 
   814 				; the "Score" and "Hi" text.
   815 				; Since all of this takes place in the blank space then it does not 
   816 				; matter that there is no WSYNC.  
   817 				; -----------------------------------------------------------------------------
   818
   819 2B2B			Score1_DLI
   820
   821 2B2B				mStart_DLI
Macro: MSTART_DLI [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03TimerAndIO.asm]
     1 2B2B 48				PHA 
     2 2B2C 98				TYA 
     3 2B2D 48				PHA  
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03TimerAndIO.asm
     3 2B2E A4 A9				ldy ThisDLI
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03TimerAndIO.asm
   822
   823 2B30 A5 AC			lda ColorPF1         ; Get text color (luminance)
   824 2B32 8D 17 D0			sta COLPF1           ; write new text color.
   825
   826 2B35 A9 00			lda #COLOR_BLACK     ; Black for background and text background.
   827 2B37 8D 1A D0			sta COLBK            ; Write new border color.
   828 2B3A 8D 18 D0			sta COLPF2           ; Write new background color
   829
   830 2B3D 20 83 2C			jsr LoadPMSpecs0     ; Load the first table entry into PM registers
   831
   832 				; Finish by loading the next DLI's colors.  The second score line preps the Beach.
   833 				; This is redundant (useless) (time-wasting) work when not on the game display, 
   834 				; but this is also not damaging.
   835
   836 2B40 4C 05 2C			jmp SetupAllOnNextLine_DLI ; Load colors for next DLI and end.
   837
   838
   839 				;==============================================================================
   840 				; SCORE 2 DLI                                                            A 
   841 				;==============================================================================
   842 				; Used on Game displays.  
   843 				; This is called on a blank before the text line. 
   844 				; The VBI should have loaded up the Page zero staged colors. 
   845 				; Only ColorPF1 matters for the playfield as the background and border will 
   846 				; be forced to black. 
   847 				; This also sets Player/Missile parameters for P0,P1,P2, M0 and M1 to show 
   848 				; the "Frogs" and "Saved" text.
   849 				; Since all of this takes place in the blank space then it does not 
   850 				; matter that there is no WSYNC.  
   851 				; -----------------------------------------------------------------------------
   852
   853 2B43			Score2_DLI
   854
   855 2B43				mStart_DLI
Macro: MSTART_DLI [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03TimerAndIO.asm]
     1 2B43 48				PHA 
     2 2B44 98				TYA 
     3 2B45 48				PHA  
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03TimerAndIO.asm
     3 2B46 A4 A9				ldy ThisDLI
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03TimerAndIO.asm
   856
   857 2B48 A5 AC			lda ColorPF1         ; Get text color (luminance)
   858 2B4A 8D 17 D0			sta COLPF1           ; write new text color.
   859
   860 2B4D 20 F0 2C			jsr LoadPMSpecs1     ; Load the first table entry into PM registers
   861
   862 					; Load HSCROL for the Title display. It should be non-impacting on other displays.
   863 2B50 A5 B7			lda TitleHSCROL      ; Get Title fine scrolling value.
   864 2B52 8D 04 D4			sta HSCROL           ; Set fine scrolling.
   865
   866 				; Finish by loading the next DLI's colors.  The second score line preps the Beach.
   867 				; This is redundant (useless) (time-wasting) work when not on the game display, 
   868 				; but this is also not damaging.
   869
   870 2B55 4C 05 2C			jmp SetupAllOnNextLine_DLI ; Load colors for next DLI and end.
   871
   872
   873 				;==============================================================================
   874 				; GAME_DLI_BEACH0                                               
   875 				;==============================================================================
   876 				; BEACH 0
   877 				; Sets COLPF0,1,2,3,BK for the first Beach line. 
   878 				; This is a little different from the other transitions to Beaches.  
   879 				; Here, ALL colors must be set. 
   880 				; In the later transitions from Boats to the Beach COLPF0 should 
   881 				; be setup as the same color as in the previous line of boats.
   882 				; COLBAK is temporarily set to the value of COLPF0 to make a full
   883 				; scan line of "sky" color matching the COLPF0 sky color for the 
   884 				; beach line that follows.
   885 				; COLBAK's real land color is set last as it is the color used in the 
   886 				; lower part of the beach characters.
   887 				; -----------------------------------------------------------------------------
   888
   889 2B58			GAME_DLI_BEACH0 
   890
   891 2B58 48				pha   	; custom startup to deal with a possible timing problem.
   892
   893 2B59 20 5D 2D			jsr LoadPmSpecs2 ; Copy all entries from column 2 to PM registers 
   894 					
   895 2B5C 8D 1E D0			sta HITCLR       ; Because this is the one and only time this DLI is called.
   896
   897 2B5F A5 AB			lda ColorPF0 ; from Page 0.
   898 2B61 8D 0A D4			sta WSYNC
   899 					; Top of the line is sky or blue water from row above. 
   900 					; Make background temporarily match the playfield drawn on the next line.
   901 2B64 8D 1A D0			sta COLBK
   902 2B67 8D 16 D0			sta COLPF0
   903
   904 2B6A 98				tya
   905 2B6B 48				pha
   906 2B6C A4 A9			ldy ThisDLI
   907 2B6E 8C 0A D4			sty WSYNC
   908
   909 2B71 4C EE 2B			jmp LoadAlmostAllColors_DLI
   910
   911
   912 				;==============================================================================
   913 				; GAME_DLI_BEACH2BOAT 
   914 				; GAME_DLI_BOAT2BOAT                                                 
   915 				;==============================================================================
   916 				; After much hackery, code gymnastics, and refactoring, these two 
   917 				; routines for boats now work out to the same code.
   918 				;
   919 				; Boats Right 1, 4, 7, 10 . . . .
   920 				; Sets colors for the Boat lines coming from a Beach line.
   921 				; This starts on the Beach line which is followed by one blank scan line 
   922 				; before the Right Boats.
   923 				;
   924 				; Boats Left 2, 5, 8, 11 . . . .
   925 				; Sets colors for the Left Boat lines coming from a Right Boat line.
   926 				; This starts on the ModeC line which is followed by one blank scan line 
   927 				; before the Left Boats.
   928 				; The Mode C line uses only COLPF0 to match the previous water, and the 
   929 				; following "sky".
   930 				; Therefore, the color of the line is automatically matched to both prior and 
   931 				; the next lines without changing COLPF0.  (For the fading purpose COLPF0
   932 				; does need to get reset on the following blank line. 
   933 				; HSCROL is set early for the boats.  Followed by all color registers.
   934 				; -----------------------------------------------------------------------------
   935
   936 2B74			GAME_DLI_BEACH2BOAT ; DLI sets HS, BK, COLPF3,2,1,0 for the Right Boats.
   937 2B74			GAME_DLI_BOAT2BOAT  ; DLI sets HS, BK, COLPF3,2,1,0 for the Left Boats.
   938
   939 2B74				mStart_DLI
Macro: MSTART_DLI [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03TimerAndIO.asm]
     1 2B74 48				PHA 
     2 2B75 98				TYA 
     3 2B76 48				PHA  
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03TimerAndIO.asm
     3 2B77 A4 A9				ldy ThisDLI
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03TimerAndIO.asm
   940
   941 2B79 A5 AF			lda NextHSCROL    ; Get boat fine scroll.
   942 2B7B 48				pha
   943
   944 2B7C A5 AA			lda ColorBak
   945 2B7E 8D 0A D4			sta WSYNC
   946 2B81 8D 1A D0			sta COLBK
   947
   948 2B84 68				pla 
   949 2B85 8D 04 D4			sta HSCROL        ; Ok to set now as this line does not scroll.
   950
   951 2B88 4C 0D 2C			jmp LoadAlmostAllBoatColors_DLI ; set colors.  then setup next row.
   952
   953
   954 				;==============================================================================
   955 				; GAME_DLI_BOAT2BEACH                                                     
   956 				;==============================================================================
   957 				; BEACH 3, 6, 9, 12 . . . .
   958 				; Sets colors for the Beach lines coming from a boat line. 
   959 				; This is different from line 0, because the DLI starts with only one scan 
   960 				; line of Mode C pixels (COLPF0) between the boats, and the Beach.
   961 				; The Mode C line uses COLPF0 to match the previous water, with the 
   962 				; following "sky".
   963 				; Therefore, the color of the line is automatically matched to both prior and 
   964 				; the next lines without changing COLPF0.  (For the fading purpose it does 
   965 				; need to get set. )
   966 				; Since the beam is in the middle of an already matching color this routine 
   967 				; can operate without WSYNC up front to set all the color registers as quickly 
   968 				; as possible. 
   969 				; COLBAK can be re-set to its beach color last as it is the color used in the 
   970 				; lower part of the characters.
   971 				; -----------------------------------------------------------------------------
   972
   973 2B8B			GAME_DLI_BOAT2BEACH ; DLI sets COLPF1,2,3,COLPF0, BK for the Beach.
   974
   975 2B8B				mStart_DLI
Macro: MSTART_DLI [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03TimerAndIO.asm]
     1 2B8B 48				PHA 
     2 2B8C 98				TYA 
     3 2B8D 48				PHA  
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03TimerAndIO.asm
     3 2B8E A4 A9				ldy ThisDLI
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03TimerAndIO.asm
   976
   977 2B90 A5 AB			lda ColorPF0 ; from Page 0.
   978 					; Different from BEACH0, because no WSYNC right here.
   979 					; Top of the line is sky or blue water from row above.   
   980 					; Make background temporarily match the playfield drawn on the next line.
   981 2B92 8D 1A D0			sta COLBK
   982 2B95 8D 16 D0			sta COLPF0
   983
   984 2B98 4C EE 2B			jmp LoadAlmostAllColors_DLI
   985
   986
   987 				;==============================================================================
   988 				; SPLASH DLIs
   989 				;==============================================================================
   990
   991 				;==============================================================================
   992 				; COLPF0_COLBK_DLI                                                     A
   993 				;==============================================================================
   994 				; The three graphics screen (Saved, Dead Frog, and Game Over) have exactly the
   995 				; same display list structure and DLIs.  
   996 				; Sets background color and the COLPF0 pixel color.  
   997 				; Table driven.  
   998 				; Perfectly re-usable for anywhere Map Mode 9 or Blank instructions are 
   999 				; being managed.  In the case of blank lines you just don't see the pixel 
  1000 				; color change, so it does not matter what is in the COLPF0 color table. 
  1001 				; -----------------------------------------------------------------------------
  1002
  1003 2B9B			COLPF0_COLBK_DLI
  1004
  1005 2B9B 4C 43 2C			jmp DO_COLPF0_COLBK_DLI
  1006
  1007
  1008 				;==============================================================================
  1009 				; SPLASH_PMGZERO_DLI                                                     A
  1010 				;==============================================================================
  1011 				; The three graphics screen (Saved, Dead Frog, and Game Over) have exactly the
  1012 				; same display list structure and DLIs.  
  1013 				;
  1014 				; This first DLI on the title screen needs to do extra work on the 
  1015 				; player/missiles to remove all the "text" labels from the screen.
  1016 				; -----------------------------------------------------------------------------
  1017
  1018 2B9E			SPLASH_PMGZERO_DLI
  1019
  1020 2B9E 4C 5C 2C			jmp DO_SPLASH_PMGZERO_DLI
  1021
  1022
  1023 				;==============================================================================
  1024 				; SPLASH PMGSPECS2 DLI                                                  A
  1025 				;==============================================================================
  1026 				; The three graphics screen (Saved, Dead Frog, and Game Over) have exactly the
  1027 				; same display list structure and DLIs.  
  1028 				; Sets background color and the COLPF0 pixel color.
  1029 				;
  1030 				; Table driven.  
  1031 				; Perfectly re-usable for anywhere Map Mode 9 or Blank instructions are 
  1032 				; being managed.  In the case of blank lines you just don't see the pixel 
  1033 				; color change, so it does not matter what is in the COLPF0 color table. 
  1034 				;
  1035 				; The first DLI on the title screen needs to do extra work 
  1036 				; on the player/missile data, so I needed another DLI here.
  1037 				; -----------------------------------------------------------------------------
  1038
  1039 2BA1			SPLASH_PMGSPECS2_DLI
  1040
  1041 2BA1 4C 67 2C			jmp DO_SPLASH_PMGSPECS2_DLI ; DO_COLPF0_COLBK_TITLE_DLI
  1042
  1043
  1044 				;==============================================================================
  1045 				; EXIT DLI.
  1046 				;==============================================================================
  1047 				; Common code called/jumped to by most DLIs.
  1048 				; JMP here is 3 byte instruction to execute 11 bytes of common DLI closure.
  1049 				; Update the interrupt pointer to the address of the next DLI.
  1050 				; Increment the DLI counter used to index the various tables.
  1051 				; Restore registers and exit.
  1052 				; -----------------------------------------------------------------------------
  1053
  1054 2BA4			Exit_DLI
  1055
  1056 2BA4 B1 A7			lda (ThisDLIAddr), y ; update low byte for next chained DLI.
  1057 2BA6 8D 00 02			sta VDSLST
  1058
  1059 2BA9 E6 A9			inc ThisDLI          ; next DLI.
  1060
  1061 2BAB				mRegRestoreAY
Macro: MREGRESTOREAY [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/macros.asm]
     1 2BAB 68				PLA 
     2 2BAC A8				TAY 
     3 2BAD 68				PLA 
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03TimerAndIO.asm
  1062
  1063 2BAE			DoNothing_DLI ; In testing mode jump here to not do anything or to stop the DLI chain.
  1064 2BAE 40				rti
  1065
  1066
  1067 				;==============================================================================
  1068 				; DLI_SPC1                                                            A 
  1069 				;==============================================================================
  1070 				; DLI to set colors for the Prompt line.  
  1071 				; And while we're here do the HSCROLL for the scrolling credits.
  1072 				; Then link to DLI_SPC2 to set colors for the scrolling line.
  1073 				; Since there is no text here (running in blank line), it does not matter 
  1074 				; that COLPF1 is written before WSYNC.
  1075 				; -----------------------------------------------------------------------------
  1076
  1077 2BAF			DLI_SPC1  ; DLI sets COLPF1, COLPF2, COLBK for Prompt text. 
  1078
  1079 2BAF 48				pha                   ; aka pha
  1080
  1081 2BB0 A5 DF			lda PressAButtonText  ; Get text color (luminance)
  1082 2BB2 8D 17 D0			sta COLPF1            ; write new text luminance.
  1083
  1084 2BB5 A5 DE			lda PressAButtonColor ; For background and text background.
  1085 2BB7 8D 0A D4			sta WSYNC             ; sync to end of scan line
  1086 2BBA 8D 1A D0			sta COLBK             ; Write new border color.
  1087 2BBD 8D 18 D0			sta COLPF2            ; Write new background color
  1088
  1089 					; Overriding the table-driven addresses now to go to DLI_SPC2
  1090 2BC0 A9 CC			lda #<DLI_SPC2        ; Update the DLI vector for the last routine for credit color.
  1091 2BC2 8D 00 02			sta VDSLST
  1092 2BC5 A9 2B			lda #>DLI_SPC2        ; Update the DLI vector for the last routine for credit color.
  1093 2BC7 8D 01 02			sta VDSLST+1
  1094
  1095 2BCA 68				pla                   ; aka pla
  1096
  1097 2BCB 40				rti
  1098
  1099
  1100 				;==============================================================================
  1101 				; DLI_SPC2                                                            A  Y
  1102 				;==============================================================================
  1103 				; DLI to set colors for the Scrolling credits.   
  1104 				; ALWAYS the last DLI on screen.
  1105 				; Squeezing screen geometry eliminated a blank line here, so the 
  1106 				; lazy way HSCROL was set no longer works and causes bizarre 
  1107 				; corruption at the bottom of the screen.  The routine needed to be 
  1108 				; optimized to avoid overhead and set HSCROL as soon as possible. 
  1109 				; -----------------------------------------------------------------------------
  1110
  1111 2BCC			DLI_SPC2  ; DLI sets black for background COLBK, COLPF2, and text luminance for scrolling text.
  1112
  1113 2BCC 48				pha
  1114
  1115 2BCD A5 BA			lda CreditHSCROL     ; HScroll for credits.
  1116 2BCF 8D 04 D4			sta HSCROL
  1117
  1118 2BD2 A9 00			lda #COLOR_BLACK     ; color for background.
  1119 2BD4 8D 0A D4			sta WSYNC            ; sync to end of scan line
  1120 2BD7 8D 1A D0			sta COLBK            ; Write new border color.
  1121 2BDA 8D 18 D0			sta COLPF2           ; Write new background color
  1122
  1123 2BDD A9 0C			lda #$0C             ; luminance for text.  Hardcoded.  Always visible on all screens.
  1124 2BDF 8D 17 D0			sta COLPF1           ; Write text luminance for credits.
  1125
  1126 2BE2 A9 AE			lda #<DoNothing_DLI  ; Stop DLI Chain.  VBI will restart the chain.
  1127 2BE4 8D 00 02			sta VDSLST
  1128 2BE7 A9 2B			lda #>DoNothing_DLI
  1129 2BE9 8D 01 02			sta VDSLST+1
  1130
  1131 2BEC 68				pla 
  1132
  1133 2BED 40				rti
  1134
  1135
  1136 				;==============================================================================
  1137 				; LOAD COLORS -- Common targets JMP'd here from other places.
  1138 				;==============================================================================
  1139 				; LOAD ALL COLORS_DLI             - load PF0, then BAK, PF1, PF2, PF3.
  1140 				; LOAD ALMOST ALL COLORS_DLI      - load BAK, PF1, PF2, PF3 (not PF0).
  1141 				; SETUP ALL ON NEXT LINE_DLI      - increment line index, then prep colors for 
  1142 				;                                   the next DLI.
  1143 				; SETUP ALL COLORS_DLI            - prep colors for DLI based on current line 
  1144 				;                                   index.
  1145 				; LOAD ALMOST ALL BOAT COLORS_DLI - load PF0, PF1, PF2, PF3 from Page zero.
  1146 				;
  1147 				; Common code called/jumped to by DLIs.
  1148 				; JMP here is 3 byte instruction to execute 11 bytes of common DLI closure.
  1149 				; Load the staged values, store in the color registers.
  1150 				; -----------------------------------------------------------------------------
  1151
  1152 2BEE			LoadAlmostAllColors_DLI
  1153
  1154 2BEE A5 AA			lda ColorBak   ; Get real background color again. (To repair the color for the Beach background)
  1155 2BF0 8D 0A D4			sta WSYNC
  1156 2BF3 8D 1A D0			sta COLBK
  1157
  1158 2BF6 A5 AC			lda ColorPF1   ; Get color Rocks 2
  1159 2BF8 8D 17 D0			sta COLPF1
  1160 2BFB A5 AD			lda ColorPF2   ; Get color Rocks 3 
  1161 2BFD 8D 18 D0			sta COLPF2
  1162 2C00 A5 AE			lda ColorPF3   ; Get color water (needed for fade-in)
  1163 2C02 8D 19 D0			sta COLPF3
  1164
  1165
  1166 2C05			SetupAllOnNextLine_DLI
  1167
  1168 2C05 C8				iny
  1169
  1170 2C06 20 24 2C			jsr SetupAllColors
  1171
  1172 2C09 88				dey
  1173
  1174 2C0A 4C A4 2B			jmp Exit_DLI
  1175
  1176
  1177 				; Called by Beach 2 Boat
  1178 2C0D			LoadAlmostAllBoatColors_DLI
  1179
  1180 2C0D A5 AC			lda ColorPF1   
  1181 2C0F 8D 17 D0			sta COLPF1
  1182 2C12 A5 AD			lda ColorPF2   
  1183 2C14 8D 18 D0			sta COLPF2
  1184 2C17 A5 AE			lda ColorPF3   
  1185 2C19 8D 19 D0			sta COLPF3
  1186 2C1C A5 AB			lda ColorPF0 
  1187 2C1E 8D 16 D0			sta COLPF0
  1188
  1189 2C21 4C 05 2C			jmp SetupAllOnNextLine_DLI
  1190
  1191
  1192 				;==============================================================================
  1193 				; SET UP ALL COLORS                                                       A  Y
  1194 				;==============================================================================
  1195 				; Given value of Y, pull that entry from the color and scroll tables
  1196 				; and store in the page 0 copies.
  1197 				; This is called at the end of a DLI to prepare for the next DLI in an attempt
  1198 				; to optimize the start of the next DLI's using the values.  
  1199 				; (Because for some reason Altirra is glitching the game screen, but 
  1200 				; Atari800 seems OK.)
  1201 				; -----------------------------------------------------------------------------
  1202
  1203 2C24			SetupAllColors
  1204
  1205 2C24 B9 B5 50			lda COLPF0_TABLE,y   ; Get color Rocks 1   
  1206 2C27 85 AB			sta ColorPF0
  1207 2C29 B9 E6 50			lda COLPF1_TABLE,y   ; Get color Rocks 2
  1208 2C2C 85 AC			sta ColorPF1
  1209 2C2E B9 17 51			lda COLPF2_TABLE,y   ; Get color Rocks 3 
  1210 2C31 85 AD			sta ColorPF2
  1211 2C33 B9 48 51			lda COLPF3_TABLE,y   ; Get color water (needed for fade-in)
  1212 2C36 85 AE			sta ColorPF3
  1213 2C38 B9 79 51			lda HSCROL_TABLE,y   ; Get boat fine scroll.
  1214 2C3B 85 AF			sta NextHSCROL
  1215 2C3D B9 84 50			lda COLBK_TABLE,y    ; Get background color .
  1216 2C40 85 AA			sta ColorBak
  1217
  1218 2C42 60				rts
  1219
  1220
  1221 				;==============================================================================
  1222 				; DO_COLPF0_COLBK_DLI                                                     A
  1223 				;==============================================================================
  1224 				; The three graphics screen (Saved, Dead Frog, and Game Over) have exactly the
  1225 				; same display list structure and DLIs.  
  1226 				; Sets background color and the COLPF0 pixel color.  
  1227 				; Table driven.  
  1228 				; Perfectly re-usable for anywhere Map Mode 9 or Blank instructions are 
  1229 				; being managed.  In the case of blank lines you just don't see the pixel 
  1230 				; color change, so it does not matter what is in the COLPF0 color table. 
  1231 				; -----------------------------------------------------------------------------
  1232
  1233 2C43			DO_COLPF0_COLBK_DLI
  1234
  1235 2C43				mStart_DLI
Macro: MSTART_DLI [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03TimerAndIO.asm]
     1 2C43 48				PHA 
     2 2C44 98				TYA 
     3 2C45 48				PHA  
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03TimerAndIO.asm
     3 2C46 A4 A9				ldy ThisDLI
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03TimerAndIO.asm
  1236
  1237 2C48 B9 B5 50			lda COLPF0_TABLE,y   ; Get pixels color
  1238 2C4B 48				pha
  1239 2C4C B9 84 50			lda COLBK_TABLE,y    ; Get background color
  1240
  1241 2C4F 8D 0A D4			sta WSYNC
  1242 					
  1243 2C52 8D 1A D0			sta COLBK            ; Set background
  1244 2C55 68				pla
  1245 2C56 8D 16 D0			sta COLPF0           ; Set pixels.
  1246
  1247 2C59 4C A4 2B			jmp Exit_DLI
  1248
  1249
  1250 				;==============================================================================
  1251 				; DO_SPLASH_PMGZERO_DLI                                              A
  1252 				;==============================================================================
  1253 				; The three graphics screen (Saved, Dead Frog, and Game Over) have exactly the
  1254 				; same display list structure and DLIs.  
  1255 				; Sets PM HPOS to 0 for all objects.
  1256 				; This is needed early on splash screens because the first group of 
  1257 				; objects extend below the first colored background lines.   This causes
  1258 				; bits of the PMG text labels to appear on the splash screen.
  1259 				; -----------------------------------------------------------------------------
  1260
  1261 2C5C			DO_SPLASH_PMGZERO_DLI
  1262
  1263 2C5C				mStart_DLI
Macro: MSTART_DLI [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03TimerAndIO.asm]
     1 2C5C 48				PHA 
     2 2C5D 98				TYA 
     3 2C5E 48				PHA  
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03TimerAndIO.asm
     3 2C5F A4 A9				ldy ThisDLI
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03TimerAndIO.asm
  1264
  1265 2C61 20 38 3B			jsr libSetPmgHPOSZero 
  1266
  1267 2C64 4C A4 2B			jmp Exit_DLI
  1268
  1269
  1270 				;==============================================================================
  1271 				; DO_SPLASH_PMGSPECS2_DLI                                               A
  1272 				;==============================================================================
  1273 				; The three graphics screen (Saved, Dead Frog, and Game Over) have exactly the
  1274 				; same display list structure and DLIs.  
  1275 				; Sets background color and the COLPF0 pixel color.  
  1276 				; Table driven.  
  1277 				; Perfectly re-usable for anywhere Map Mode 9 or Blank instructions are 
  1278 				; being managed.  In the case of blank lines you just don't see the pixel 
  1279 				; color change, so it does not matter what is in the COLPF0 color table. 
  1280 				; -----------------------------------------------------------------------------
  1281
  1282 2C67			DO_SPLASH_PMGSPECS2_DLI
  1283
  1284 2C67				mStart_DLI
Macro: MSTART_DLI [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03TimerAndIO.asm]
     1 2C67 48				PHA 
     2 2C68 98				TYA 
     3 2C69 48				PHA  
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03TimerAndIO.asm
     3 2C6A A4 A9				ldy ThisDLI
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03TimerAndIO.asm
  1285
  1286 2C6C B9 B5 50			lda COLPF0_TABLE,y   ; Get pixels color
  1287 2C6F 48				pha
  1288 2C70 B9 84 50			lda COLBK_TABLE,y    ; Get background color
  1289 					
  1290 2C73 8D 0A D4			sta WSYNC
  1291 					
  1292 2C76 8D 1A D0			sta COLBK            ; Set background
  1293 2C79 68				pla
  1294 2C7A 8D 16 D0			sta COLPF0           ; Set pixels.
  1295
  1296 2C7D 20 5D 2D			jsr LoadPmSpecs2     ; Load the first table entry into 
  1297
  1298 2C80 4C A4 2B			jmp Exit_DLI
  1299
  1300
  1301 				;==============================================================================
  1302 				; LOAD PM SPECS 0                                                       A 
  1303 				;==============================================================================
  1304 				; Called by Score 1 DLI.
  1305 				; Load the table entry 1 values for P0,P1,P2,P3,M0,M1,M2,M3  
  1306 				; to the P/M registers.
  1307 				; -----------------------------------------------------------------------------
  1308
  1309 2C83			LoadPmSpecs0
  1310
  1311 2C83 AD C1 51			lda PRIOR_TABLE
  1312 2C86 8D 1B D0			sta PRIOR
  1313
  1314 2C89 AD A9 51			lda HPOSP0_TABLE
  1315 2C8C 8D 00 D0			sta HPOSP0
  1316 2C8F AD 8E 51			lda COLPM0_TABLE 
  1317 2C92 8D 12 D0			sta COLPM0
  1318 2C95 AD 9A 51			lda SIZEP0_TABLE
  1319 2C98 8D 08 D0			sta SIZEP0
  1320
  1321 2C9B AD AC 51			lda HPOSP1_TABLE
  1322 2C9E 8D 01 D0			sta HPOSP1
  1323 2CA1 AD 91 51			lda COLPM1_TABLE 
  1324 2CA4 8D 13 D0			sta COLPM1
  1325 2CA7 AD 9D 51			lda SIZEP1_TABLE
  1326 2CAA 8D 09 D0			sta SIZEP1
  1327
  1328 2CAD AD AF 51			lda HPOSP2_TABLE
  1329 2CB0 8D 02 D0			sta HPOSP2
  1330 2CB3 AD 94 51			lda COLPM2_TABLE 
  1331 2CB6 8D 14 D0			sta COLPM2
  1332 2CB9 AD A0 51			lda SIZEP2_TABLE
  1333 2CBC 8D 0A D0			sta SIZEP2
  1334
  1335 2CBF AD B2 51			lda HPOSP3_TABLE
  1336 2CC2 8D 03 D0			sta HPOSP3
  1337 2CC5 AD 97 51			lda COLPM3_TABLE 
  1338 2CC8 8D 15 D0			sta COLPM3
  1339 2CCB AD A3 51			lda SIZEP3_TABLE
  1340 2CCE 8D 0B D0			sta SIZEP3
  1341 					
  1342 2CD1 AD A6 51			lda SIZEM_TABLE
  1343 2CD4 8D 0C D0			sta SIZEM
  1344 2CD7 AD B5 51			lda HPOSM0_TABLE
  1345 2CDA 8D 04 D0			sta HPOSM0
  1346 2CDD AD B8 51			lda HPOSM1_TABLE
  1347 2CE0 8D 05 D0			sta HPOSM1
  1348 2CE3 AD BB 51			lda HPOSM2_TABLE
  1349 2CE6 8D 06 D0			sta HPOSM2
  1350 2CE9 AD BE 51			lda HPOSM3_TABLE
  1351 2CEC 8D 07 D0			sta HPOSM3
  1352
  1353 2CEF 60				rts
  1354
  1355
  1356 				;==============================================================================
  1357 				; LOAD PM SPECS 1                                                       A 
  1358 				;==============================================================================
  1359 				; Called by Score 2 DLI.
  1360 				; Load the table entry 1 values for P0,P1,P2,P3,M0,M1,M2,M3 
  1361 				; to the P/M registers.
  1362 				; -----------------------------------------------------------------------------
  1363
  1364 2CF0			LoadPmSpecs1
  1365
  1366 2CF0 AD C2 51			lda PRIOR_TABLE+1
  1367 2CF3 8D 1B D0			sta PRIOR
  1368
  1369 2CF6 AD AA 51			lda HPOSP0_TABLE+1
  1370 2CF9 8D 00 D0			sta HPOSP0
  1371 2CFC AD 8F 51			lda COLPM0_TABLE+1
  1372 2CFF 8D 12 D0			sta COLPM0
  1373 2D02 AD 9B 51			lda SIZEP0_TABLE+1
  1374 2D05 8D 08 D0			sta SIZEP0
  1375
  1376 2D08 AD AD 51			lda HPOSP1_TABLE+1
  1377 2D0B 8D 01 D0			sta HPOSP1
  1378 2D0E AD 92 51			lda COLPM1_TABLE+1 
  1379 2D11 8D 13 D0			sta COLPM1
  1380 2D14 AD 9E 51			lda SIZEP1_TABLE+1
  1381 2D17 8D 09 D0			sta SIZEP1
  1382
  1383 2D1A AD B0 51			lda HPOSP2_TABLE+1
  1384 2D1D 8D 02 D0			sta HPOSP2
  1385 2D20 AD 95 51			lda COLPM2_TABLE+1 
  1386 2D23 8D 14 D0			sta COLPM2
  1387 2D26 AD A1 51			lda SIZEP2_TABLE+1
  1388 2D29 8D 0A D0			sta SIZEP2
  1389
  1390 2D2C AD B3 51			lda HPOSP3_TABLE+1
  1391 2D2F 8D 03 D0			sta HPOSP3
  1392 2D32 AD 98 51			lda COLPM3_TABLE+1 
  1393 2D35 8D 15 D0			sta COLPM3
  1394 2D38 AD A4 51			lda SIZEP3_TABLE+1
  1395 2D3B 8D 0B D0			sta SIZEP3
  1396
  1397 2D3E AD A7 51			lda SIZEM_TABLE+1
  1398 2D41 8D 0C D0			sta SIZEM
  1399 2D44 AD B6 51			lda HPOSM0_TABLE+1
  1400 2D47 8D 04 D0			sta HPOSM0
  1401 2D4A AD B9 51			lda HPOSM1_TABLE+1
  1402 2D4D 8D 05 D0			sta HPOSM1
  1403 2D50 AD BC 51			lda HPOSM2_TABLE+1
  1404 2D53 8D 06 D0			sta HPOSM2
  1405 2D56 AD BF 51			lda HPOSM3_TABLE+1
  1406 2D59 8D 07 D0			sta HPOSM3
  1407
  1408 2D5C 60				rts
  1409
  1410
  1411 				;==============================================================================
  1412 				; LOAD PM SPECS 2                                                       A 
  1413 				;==============================================================================
  1414 				; Called on Title, Game, and Game Over displays.
  1415 				; Load the table entry 2 values for P0,P1,P2,P3,M0,M1,M2,M3 
  1416 				; to the P/M registers.
  1417 				; -----------------------------------------------------------------------------
  1418
  1419 2D5D			LoadPmSpecs2
  1420
  1421 2D5D AD C3 51			lda PRIOR_TABLE+2
  1422 2D60 8D 1B D0			sta PRIOR
  1423
  1424 2D63 AD AB 51			lda HPOSP0_TABLE+2
  1425 2D66 8D 00 D0			sta HPOSP0
  1426 2D69 AD 90 51			lda COLPM0_TABLE+2
  1427 2D6C 8D 12 D0			sta COLPM0
  1428 2D6F AD 9C 51			lda SIZEP0_TABLE+2
  1429 2D72 8D 08 D0			sta SIZEP0
  1430
  1431 2D75 AD AE 51			lda HPOSP1_TABLE+2
  1432 2D78 8D 01 D0			sta HPOSP1
  1433 2D7B AD 93 51			lda COLPM1_TABLE+2 
  1434 2D7E 8D 13 D0			sta COLPM1
  1435 2D81 AD 9F 51			lda SIZEP1_TABLE+2
  1436 2D84 8D 09 D0			sta SIZEP1
  1437
  1438 2D87 AD B1 51			lda HPOSP2_TABLE+2
  1439 2D8A 8D 02 D0			sta HPOSP2
  1440 2D8D AD 96 51			lda COLPM2_TABLE+2 
  1441 2D90 8D 14 D0			sta COLPM2
  1442 2D93 AD A2 51			lda SIZEP2_TABLE+2
  1443 2D96 8D 0A D0			sta SIZEP2
  1444
  1445 2D99 AD B4 51			lda HPOSP3_TABLE+2
  1446 2D9C 8D 03 D0			sta HPOSP3
  1447 2D9F AD 99 51			lda COLPM3_TABLE+2 
  1448 2DA2 8D 15 D0			sta COLPM3
  1449 2DA5 AD A5 51			lda SIZEP3_TABLE+2
  1450 2DA8 8D 0B D0			sta SIZEP3
  1451
  1452 2DAB AD A8 51			lda SIZEM_TABLE+2
  1453 2DAE 8D 0C D0			sta SIZEM
  1454 2DB1 AD B7 51			lda HPOSM0_TABLE+2
  1455 2DB4 8D 04 D0			sta HPOSM0
  1456 2DB7 AD BA 51			lda HPOSM1_TABLE+2
  1457 2DBA 8D 05 D0			sta HPOSM1
  1458 2DBD AD BD 51			lda HPOSM2_TABLE+2
  1459 2DC0 8D 06 D0			sta HPOSM2
  1460 2DC3 AD C0 51			lda HPOSM3_TABLE+2
  1461 2DC6 8D 07 D0			sta HPOSM3
  1462
  1463 2DC9 60				rts
  1464
   713 2DCA				icl "Frogger03Audio.asm"        ; Pathetic audio sequencer.
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03Audio.asm
     1 				; ==========================================================================
     2 				; Pet Frogger
     3 				; (c) November 1983 by John C. Dale, aka Dalesoft
     4 				; for the Commodore Pet 4032
     5 				; ==========================================================================
     6 				; Ported (parodied) to Atari 8-bit computers
     7 				; by Ken Jennings (if this were 1983, aka FTR Enterprises)
     8 				; ==========================================================================
     9 				; Version 00, November 2018
    10 				; Version 01, December 2018
    11 				; Version 02, February 2019
    12 				; Version 03, August 2019
    13 				; ==========================================================================
    14
    15
    16 				; ==========================================================================
    17 				; Frogger AUDIO
    18 				;
    19 				; All the routines to run "The world's cheapest sequencer." 
    20 				;
    21 				; It is a truly sad thing.
    22 				;
    23 				; Game sound allocation:
    24 				;             Title           Game                 Win/Dead/Over       Other
    25 				;----------   ------------    -----------------    -------------       -----------
    26 				; Channel 0 - slide, hum A    
    27 				; Channel 1 - downs ,hum B    engines
    28 				; Channel 2 - lefts           jump, 100pt ding     OdeToJoy            button tink
    29 				; Channel 3 - Rezz slide      water                OdeToJoy, Funeral
    30 				; --------------------------------------------------------------------------
    31
    32 = 0000			SOUND_OFF     = 0
    33 = 0001			SOUND_TINK    = 1
    34 = 0002			SOUND_SLIDE   = 2
    35 = 0003			SOUND_HUM_A   = 3
    36 = 0004			SOUND_HUM_B   = 4
    37 = 0005			SOUND_DIRGE   = 5
    38 = 0006			SOUND_THUMP   = 6
    39 = 0007			SOUND_JOY     = 7
    40 = 0008			SOUND_WATER   = 8
    41 = 0009			SOUND_ENGINES = 9
    42 = 000A			SOUND_BLING   = 10 
    43 = 000B			SOUND_DOWNS   = 11
    44 = 000C			SOUND_LEFTS   = 12
    45
    46 = 000C			SOUND_MAX     = 12
    47
    48 				; ======== The world's most inept sound system. ========
    49 				;
    50 				; The world's cheapest sequencer. For each audio channel play one sound 
    51 				; value from a table at each call. Assuming this is done synchronized to 
    52 				; the frame it performs a sound change every 16.6ms (at NTSC 60fps)
    53 				;
    54 				; Sequencer control values for each voice are in Page 0.... (18 bytes total)
    55 				;
    56 				;; Pointer used by the VBI service routine for the current sequence under work:
    57 				; SOUND_POINTER .word $0000
    58 				;
    59 				;; Pointers to the sound entry in use for each voice.
    60 				; SOUND_FX_LO
    61 				; SOUND_FX_LO0 .byte 0
    62 				; SOUND_FX_LO1 .byte 0
    63 				; SOUND_FX_LO2 .byte 0
    64 				; SOUND_FX_LO3 .byte 0 
    65
    66 				; SOUND_FX_HI
    67 				; SOUND_FX_HI0 .byte 0
    68 				; SOUND_FX_HI1 .byte 0
    69 				; SOUND_FX_HI2 .byte 0
    70 				; SOUND_FX_HI3 .byte 0 
    71
    72 				; Sound Control values coordinate between the main process and the VBI 
    73 				; service routine to turn on/off/play sounds. Control Values:
    74 				; 0   = Set by Main to direct VBI to stop managing sound pending an 
    75 				;       update from MAIN. This does not stop the POKEY's currently 
    76 				;       playing sound.  It is set by the VBI when a sequence is complete 
    77 				;       to indicate the channel is idle/unmanaged. 
    78 				; 1   = MAIN sets to direct VBI to start playing a new sound FX.
    79 				; 2   = VBI sets when it is playing to inform MAIN that it has taken 
    80 				;       direction and is now busy.
    81 				; 255 = Direct VBI to silence the channel immediately.
    82 				;
    83 				; So, the procedure for playing sound.
    84 				; 1) MAIN sets the channel's SOUND_CONTROL to 0.
    85 				; 2) MAIN sets the channel's SOUND_FX_LO/HI pointer to the sound effects 
    86 				;    sequence to play.
    87 				; 3) MAIN sets the channel's SOUND_CONTROL to 1 to tell VBI to start.
    88 				; 4) VBI sets the channel's SOUND_CONTROL value to 2 when playing, then 
    89 				;    when the sequence is complete, back to value 0.
    90
    91 				; SOUND_CONTROL
    92 				; SOUND_CONTROL0  .byte $00
    93 				; SOUND_CONTROL1  .byte $00
    94 				; SOUND_CONTROL2  .byte $00
    95 				; SOUND_CONTROL3  .byte $00
    96
    97 				; When these are non-zero, the current settings continue for the next frame.
    98 				; SOUND_DURATION
    99 				; SOUND_DURATION0 .byte $00
   100 				; SOUND_DURATION1 .byte $00
   101 				; SOUND_DURATION2 .byte $00
   102 				; SOUND_DURATION3 .byte $00
   103
   104 				; ======================================================
   105
   106
   107 2DCA				.align 4
   108
   109
   110 				; A sound Entry is 4 bytes...
   111 				; byte 0, AUDC (distortion/volume) value
   112 				; byte 1, AUDF (frequency) value
   113 				; byte 2, Duration, number of frames to count. 0 counts as 1 frame.
   114 				; byte 3, 0 == End of sequence. Stop playing sound. (Set AUDF and AUDC to 0)
   115 				;         1 == Continue normal playing.
   116 				;       255 == End of sequence. Do not stop POKEY playing current sound.
   117 				;       Eventually some other magic to be determined goes here.
   118 				; Like this:
   119 				;	.byte Distortion/volume, Frequency, Frame/Duration, Control
   120
   121
   122 2DCC			SOUND_ENTRY_OFF   ; A formality, so that 0 has consistent meaning.
   123 2DCC-3E8A> 00 00 00 00		.byte 0,0,0,0
   124
   125
   126 2DD0			SOUND_ENTRY_TINK ; Press A Button.
   127 2DD0 A6 78 02 01			.byte $A6,120,2,1
   128 2DD4 A5 78 01 01			.byte $A5,120,1,1
   129 2DD8 A4 78 01 01			.byte $A4,120,1,1
   130 2DDC A3 78 00 01			.byte $A3,120,0,1
   131 2DE0 A2 78 00 01			.byte $A2,120,0,1
   132 2DE4 A1 78 00 01			.byte $A1,120,0,1
   133
   134 2DE8 A0 00 00 00			.byte $A0,0,0,0
   135
   136
   137 2DEC			SOUND_ENTRY_BLING ; Press A Button.
   138 2DEC AA 19 01 01			.byte $Aa,25,1,1
   139 2DF0 A8 19 01 01			.byte $A8,25,1,1
   140 2DF4 A6 19 01 01			.byte $A6,25,1,1
   141 2DF8 A4 19 01 01			.byte $A4,25,1,1
   142 2DFC A1 19 01 01			.byte $A1,25,1,1
   143 2E00 A0 00 03 01			.byte $A0,0,3,1
   144
   145 2E04 A0 00 00 00			.byte $A0,0,0,0
   146
   147
   148 					; Maybe if I thought about it for a while I could do a 
   149 					; ramp/counting feature in the sound entry control byte 
   150 					; in less than 100-ish bytes of code which is about how 
   151 					; much space this table occupies. 
   152 2E08			SOUND_ENTRY_SLIDE    ; Title logo lines slide right to left
   153 2E08 02 32 01 01			.byte $02,50,1,1 ; 1 == 2 frames per wait.
   154 2E0C 03 31 01 01			.byte $03,49,1,1
   155 2E10 03 30 01 01			.byte $03,48,1,1
   156 2E14 04 2F 01 01			.byte $04,47,1,1
   157 2E18 04 2E 01 01			.byte $04,46,1,1
   158 2E1C 05 2D 01 01			.byte $05,45,1,1
   159 2E20 05 2C 01 01			.byte $05,44,1,1
   160 2E24 06 2B 01 01			.byte $06,43,1,1
   161 2E28 06 2A 01 01			.byte $06,42,1,1
   162 2E2C 07 29 01 01			.byte $07,41,1,1
   163 2E30 07 28 01 01			.byte $07,40,1,1
   164 2E34 08 27 01 01			.byte $08,39,1,1
   165 2E38 08 26 01 01			.byte $08,38,1,1
   166 2E3C 09 25 01 01			.byte $09,37,1,1
   167 2E40 09 24 01 01			.byte $09,36,1,1
   168 2E44 0A 23 01 01			.byte $0a,35,1,1
   169 2E48 0A 22 01 01			.byte $0a,34,1,1
   170 2E4C 0B 21 01 01			.byte $0b,33,1,1
   171 2E50 0B 20 01 01			.byte $0b,32,1,1
   172 2E54 0C 1F 01 01			.byte $0c,31,1,1
   173 2E58 0C 1E 01 01			.byte $0c,30,1,1
   174 2E5C 0D 1D 01 01			.byte $0d,29,1,1
   175 2E60 0D 1C 01 01			.byte $0d,28,1,1
   176 2E64 0D 1B 01 01			.byte $0d,27,1,1
   177 2E68 0D 1A 01 01			.byte $0d,26,1,1
   178 2E6C 0D 19 01 01			.byte $0d,25,1,1
   179 2E70 0E 18 01 01			.byte $0e,24,1,1
   180 2E74 0E 17 01 01			.byte $0e,23,1,1
   181 2E78 0E 16 01 01			.byte $0e,22,1,1
   182 2E7C 0E 15 01 01			.byte $0e,21,1,1
   183 2E80 0E 14 01 01			.byte $0e,20,1,1
   184 2E84 0E 13 01 01			.byte $0e,19,1,1
   185 2E88 0E 12 01 01			.byte $0e,18,1,1
   186 2E8C 0E 11 01 01			.byte $0e,17,1,1
   187 2E90 0E 10 01 01			.byte $0e,16,1,1
   188 2E94 0E 0F 01 01			.byte $0e,15,1,1
   189 2E98 0E 0E 01 01			.byte $0e,14,1,1
   190 2E9C 0E 0D 01 01			.byte $0e,13,1,1
   191
   192 2EA0 00 00 00 00			.byte $00,$00,0,0
   193
   194
   195 2EA4			SOUND_ENTRY_HUMMER_A ; one-half of Atari light saber
   196 2EA4 A9 FF 1E 01			.byte $A9,$FF,30,1
   197 2EA8 A8 FF 07 01			.byte $A8,$FF,7,1
   198 2EAC A7 FF 07 01			.byte $A7,$FF,7,1
   199 2EB0 A6 FF 07 01			.byte $A6,$FF,7,1
   200 2EB4 A5 FF 07 01			.byte $A5,$FF,7,1
   201 2EB8 A3 FF 07 01			.byte $A3,$FF,7,1
   202 2EBC A1 FF 07 01			.byte $A1,$FF,7,1
   203
   204 2EC0 A0 00 00 00			.byte $A0,0,0,0
   205
   206
   207 2EC4			SOUND_ENTRY_HUMMER_B ; other-half of Atari light saber
   208 2EC4 A8 FE 1E 01			.byte $A8,$FE,30,1
   209 2EC8 A8 FE 07 01			.byte $A8,$FE,7,1
   210 2ECC A7 FE 07 01			.byte $A7,$FE,7,1
   211 2ED0 A6 FE 07 01			.byte $A6,$FE,7,1
   212 2ED4 A5 FE 07 01			.byte $A5,$FE,7,1
   213 2ED8 A3 FE 07 01			.byte $A3,$FE,7,1
   214 2EDC A1 FE 07 01			.byte $A1,$FE,7,1
   215
   216 2EE0 A0 00 00 00			.byte $A0,0,0,0
   217
   218
   219 2EE4			SOUND_ENTRY_DIRGE     ; Chopin's Funeral for a frog (or a gunslinger in Outlaw) 
   220 				;	.byte $A4,182,0,1 ; F, 1/4, 16 steps
   221 				;	.byte $A6,182,13,1 
   222 				;	.byte $A4,182,0,1 
   223 				;	.byte $A2,182,0,1 
   224 				;	.byte $A4,182,0,1 ; F, 1/8 ., 12 steps
   225 				;	.byte $A6,182,9,1 
   226 				;	.byte $A4,182,0,1 
   227 				;	.byte $A2,182,0,1 
   228 				;	.byte $A4,182,0,1 ; F, 1/16,  4 steps
   229 				;	.byte $A6,182,0,1 
   230 				;	.byte $A4,182,0,1 
   231 				;	.byte $A2,182,0,1 
   232 				;	.byte $A4,182,0,1 ; F, 1/2, 32 steps
   233 				;	.byte $A6,182,29,1 
   234 				;	.byte $A4,182,0,1 
   235 				;	.byte $A2,182,0,1 
   236
   237 				;	.byte $A4,182,0,1 ; F, 1/4, 16 steps
   238 				;	.byte $A6,182,13,1 
   239 				;	.byte $A4,182,0,1 
   240 				;	.byte $A2,182,0,1 
   241 				;	.byte $A4,182,0,1 ; F, 1/8 ., 12 steps
   242 				;	.byte $A6,182,9,1 
   243 				;	.byte $A4,182,0,1 
   244 				;	.byte $A2,182,0,1 
   245 				;	.byte $A4,182,0,1 ; F, 1/16,  4 steps
   246 				;	.byte $A6,182,0,1 
   247 				;	.byte $A4,182,0,1 
   248 				;	.byte $A2,182,0,1 
   249 				;	.byte $A4,182,0,1 ; F, 1/2, 32 steps
   250 				;	.byte $A6,182,29,1 
   251 				;	.byte $A4,182,0,1 
   252 				;	.byte $A2,182,0,1 
   253
   254 2EE4 A4 B6 00 01			.byte $A4,182,0,1 ; F, 1/4, 16 steps
   255 2EE8 A6 B6 0D 01			.byte $A6,182,13,1 
   256 2EEC A4 B6 00 01			.byte $A4,182,0,1 
   257 2EF0 A2 B6 00 01			.byte $A2,182,0,1 
   258 2EF4 A4 B6 00 01			.byte $A4,182,0,1 ; F, 1/8 ., 12 steps
   259 2EF8 A6 B6 09 01			.byte $A6,182,9,1 
   260 2EFC A4 B6 00 01			.byte $A4,182,0,1 
   261 2F00 A2 B6 00 01			.byte $A2,182,0,1 
   262 2F04 A4 B6 00 01			.byte $A4,182,0,1 ; F, 1/16,  4 steps
   263 2F08 A6 B6 00 01			.byte $A6,182,0,1 
   264 2F0C A4 B6 00 01			.byte $A4,182,0,1 
   265 2F10 A2 B6 00 01			.byte $A2,182,0,1 
   266 2F14 A4 B6 00 01			.byte $A4,182,0,1 ; F, 1/4, 16 steps
   267 2F18 A6 B6 0D 01			.byte $A6,182,13,1 
   268 2F1C A4 B6 00 01			.byte $A4,182,0,1 
   269 2F20 A2 B6 00 01			.byte $A2,182,0,1 
   270 2F24 A4 90 00 01			.byte $A4,144,0,1 ; A, 1/8 ., 12 steps
   271 2F28 A6 90 09 01			.byte $A6,144,9,1 
   272 2F2C A4 90 00 01			.byte $A4,144,0,1 
   273 2F30 A2 90 00 01			.byte $A2,144,0,1 
   274 2F34 A4 A2 00 01			.byte $A4,162,0,1 ; G, 1/16,  4 steps
   275 2F38 A6 A2 00 01			.byte $A6,162,0,1 
   276 2F3C A4 A2 00 01			.byte $A4,162,0,1 
   277 2F40 A2 A2 00 01			.byte $A2,162,0,1 
   278
   279 2F44 A4 A2 00 01			.byte $A4,162,0,1 ; G, 1/8 ., 12 steps
   280 2F48 A6 A2 09 01			.byte $A6,162,9,1 
   281 2F4C A4 A2 00 01			.byte $A4,162,0,1 
   282 2F50 A2 A2 00 01			.byte $A2,162,0,1 
   283 2F54 A4 B6 00 01			.byte $A4,182,0,1 ; F, 1/16,  4 steps
   284 2F58 A6 B6 00 01			.byte $A6,182,0,1 
   285 2F5C A4 B6 00 01			.byte $A4,182,0,1 
   286 2F60 A2 B6 00 01			.byte $A2,182,0,1 
   287 2F64 A4 B6 00 01			.byte $A4,182,0,1 ; F, 1/8 ., 12 steps
   288 2F68 A6 B6 09 01			.byte $A6,182,9,1 
   289 2F6C A4 B6 00 01			.byte $A4,182,0,1 
   290 2F70 A2 B6 00 01			.byte $A2,182,0,1 
   291 2F74 A4 B6 00 01			.byte $A4,182,0,1 ; F, 1/16,  4 steps
   292 2F78 A6 B6 00 01			.byte $A6,182,0,1 
   293 2F7C A4 B6 00 01			.byte $A4,182,0,1 
   294 2F80 A2 B6 00 01			.byte $A2,182,0,1 
   295 2F84 A4 B6 00 01			.byte $A4,182,0,1 ; F, 1/2,  32 steps
   296 2F88 A6 B6 1D 01			.byte $A6,182,29,1 
   297 2F8C A4 B6 00 01			.byte $A4,182,0,1 
   298 2F90 A2 B6 00 01			.byte $A2,182,0,1 
   299
   300 2F94 A0 00 00 00			.byte $A0,$00,0,0
   301
   302
   303 2F98			SOUND_ENTRY_THUMP     ; When a frog moves
   304 2F98 A2 F0 00 01			.byte $A2,240,0,1 
   305 2F9C A5 F0 00 01			.byte $A5,240,0,1 
   306 2FA0 A8 F0 02 01			.byte $A8,240,2,1 
   307 2FA4 A4 F0 00 01			.byte $A4,240,0,1 
   308 2FA8 A1 F0 00 01			.byte $A1,240,0,1 
   309
   310 2FAC A0 00 00 00			.byte $A0,$00,0,0
   311
   312
   313 2FB0			SOUND_ENTRY_ODE2JOY ; Beethoven's Ode To Joy when a frog is saved 
   314 2FB0 AA 79 00 01			.byte $Aa,121,0,1 ; C, 1/4, 10 steps
   315 2FB4 A8 79 06 01			.byte $A8,121,6,1 
   316 2FB8 A5 79 00 01			.byte $A5,121,0,1 
   317 2FBC A3 79 00 01			.byte $A3,121,0,1 
   318 2FC0 A1 79 00 01			.byte $A1,121,0,1 
   319 2FC4 AA 79 00 01			.byte $Aa,121,0,1 ; C, 1/4, 10 steps
   320 2FC8 A8 79 06 01			.byte $A8,121,6,1 
   321 2FCC A5 79 00 01			.byte $A5,121,0,1 
   322 2FD0 A3 79 00 01			.byte $A3,121,0,1 
   323 2FD4 A1 79 00 01			.byte $A1,121,0,1 
   324 2FD8 AA 6C 00 01			.byte $Aa,108,0,1 ; D, 1/4, 10 steps
   325 2FDC A8 6C 06 01			.byte $A8,108,6,1 
   326 2FE0 A5 6C 00 01			.byte $A5,108,0,1 
   327 2FE4 A3 6C 00 01			.byte $A3,108,0,1 
   328 2FE8 A2 6C 00 01			.byte $A2,108,0,1 
   329 2FEC AA 60 00 01			.byte $Aa,96,0,1 ; E, 1/4, 10 steps
   330 2FF0 A8 60 06 01			.byte $A8,96,6,1 
   331 2FF4 A5 60 00 01			.byte $A5,96,0,1 
   332 2FF8 A3 60 00 01			.byte $A3,96,0,1 
   333 2FFC A1 60 00 01			.byte $A1,96,0,1 
   334
   335 3000 AA 60 00 01			.byte $Aa,96,0,1 ; E, 1/4, 10 steps
   336 3004 A8 60 06 01			.byte $A8,96,6,1 
   337 3008 A5 60 00 01			.byte $A5,96,0,1 
   338 300C A3 60 00 01			.byte $A3,96,0,1 
   339 3010 A1 60 00 01			.byte $A1,96,0,1 
   340 3014 AA 6C 00 01			.byte $Aa,108,0,1 ; D, 1/4, 10 steps
   341 3018 A8 6C 06 01			.byte $A8,108,6,1 
   342 301C A5 6C 00 01			.byte $A5,108,0,1 
   343 3020 A3 6C 00 01			.byte $A3,108,0,1 
   344 3024 A1 6C 00 01			.byte $A1,108,0,1 
   345 3028 AA 79 00 01			.byte $Aa,121,0,1 ; C, 1/4, 10 steps
   346 302C A8 79 06 01			.byte $A8,121,6,1 
   347 3030 A5 79 00 01			.byte $A5,121,0,1 
   348 3034 A3 79 00 01			.byte $A3,121,0,1 
   349 3038 A1 79 00 01			.byte $A1,121,0,1 
   350 303C AA 80 00 01			.byte $Aa,128,0,1 ; B, 1/4, 10 steps
   351 3040 A8 80 06 01			.byte $A8,128,6,1 
   352 3044 A5 80 00 01			.byte $A5,128,0,1 
   353 3048 A3 80 00 01			.byte $A3,128,0,1 
   354 304C A1 80 00 01			.byte $A1,128,0,1 
   355
   356 3050 AA 90 00 01			.byte $Aa,144,0,1 ; A, 1/4, 10 steps
   357 3054 A8 90 06 01			.byte $A8,144,6,1 
   358 3058 A5 90 00 01			.byte $A5,144,0,1 
   359 305C A3 90 00 01			.byte $A3,144,0,1 
   360 3060 A1 90 00 01			.byte $A1,144,0,1 
   361 3064 AA 90 00 01			.byte $Aa,144,0,1 ; A, 1/4, 10 steps
   362 3068 A8 90 06 01			.byte $A8,144,6,1 
   363 306C A5 90 00 01			.byte $A5,144,0,1 
   364 3070 A3 90 00 01			.byte $A3,144,0,1 
   365 3074 A1 90 00 01			.byte $A1,144,0,1 
   366 3078 AA 80 00 01			.byte $Aa,128,0,1 ; B, 1/4, 10 steps
   367 307C A8 80 06 01			.byte $A8,128,6,1 
   368 3080 A5 80 00 01			.byte $A5,128,0,1 
   369 3084 A3 80 00 01			.byte $A3,128,0,1 
   370 3088 A1 80 00 01			.byte $A1,128,0,1 
   371 308C AA 79 00 01			.byte $Aa,121,0,1 ; C, 1/4, 10 steps
   372 3090 A8 79 06 01			.byte $A8,121,6,1 
   373 3094 A5 79 00 01			.byte $A5,121,0,1 
   374 3098 A3 79 00 01			.byte $A3,121,0,1 
   375 309C A1 79 00 01			.byte $A1,121,0,1 
   376
   377 30A0 AA 79 00 01			.byte $Aa,121,0,1 ; C, 1/4 ., 15 steps
   378 30A4 A8 79 0B 01			.byte $A8,121,11,1 
   379 30A8 A5 79 00 01			.byte $A5,121,0,1 
   380 30AC A3 79 00 01			.byte $A3,121,0,1 
   381 30B0 A1 79 00 01			.byte $A1,121,0,1 
   382 30B4 AA 80 00 01			.byte $Aa,128,0,1 ; B, 1/8, 5 steps
   383 30B8 A8 80 00 01			.byte $A8,128,0,1 
   384 30BC A5 80 00 01			.byte $A5,128,0,1 
   385 30C0 A3 80 00 01			.byte $A3,128,0,1 
   386 30C4 A1 80 00 01			.byte $A1,128,0,1 
   387 30C8 AA 80 00 01			.byte $Aa,128,0,1 ; B, 1/4, 20 steps
   388 30CC A8 80 10 01			.byte $A8,128,16,1 
   389 30D0 A5 80 00 01			.byte $A5,128,0,1 
   390 30D4 A3 80 00 01			.byte $A3,128,0,1 
   391 30D8 A1 80 00 01			.byte $A1,128,0,1 
   392
   393 30DC A0 00 00 00			.byte $A0,$00,0,0
   394
   395
   396 30E0			SOUND_ENTRY_WATER    ; Water sloshing noises
   397 30E0 81 01 4B 01			.byte $81,1,75,1 ; several full seconds 
   398 30E4 81 02 4B 01			.byte $81,2,75,1 ; of different sounds 
   399 30E8 81 03 4B 01			.byte $81,3,75,1 ; at different volumes.
   400 30EC 81 04 4B 01			.byte $81,4,75,1
   401 30F0 81 05 4B 01			.byte $81,5,75,1
   402
   403 30F4 81 02 4B FF			.byte $81,2,75,255 ; End.  Do not stop sound.
   404
   405
   406 30F8			SOUND_ENTRY_ENGINES    ; Engine sounds noises
   407 30F8 C5 E7 4B 01			.byte $C5,231,75,1 ; several full seconds 
   408 30FC C4 DC 4B 01			.byte $C4,220,75,1 ; of different sounds 
   409 3100 C5 FF 4B 01			.byte $C5,255,75,1 ; at different volumes.
   410 3104 C4 F3 4B 01			.byte $C4,243,75,1
   411 3108 C5 C6 4B 01			.byte $C5,198,75,1
   412
   413 310C C4 D3 4B FF			.byte $C4,211,75,255 ; End.  Do not stop sound.
   414
   415
   416 3110			SOUND_ENTRY_DOWNS   ; title graphics shift down.
   417 3110 04 04 04 01			.byte $04,4,4,1 
   418 3114 04 03 04 01			.byte $04,3,4,1 
   419 3118 03 02 04 01			.byte $03,2,4,1 
   420 311C 03 01 04 01			.byte $03,1,4,1 
   421 3120 02 00 04 01			.byte $02,0,4,1 
   422
   423 3124 00 00 00 00			.byte $00,$00,0,0
   424
   425
   426 3128			SOUND_ENTRY_LEFTS
   427 3128 A1 15 02 01			.byte $a1,21,2,1 
   428 312C A1 14 02 01			.byte $a1,20,2,1 
   429 3130 A1 13 02 01			.byte $a1,19,2,1 
   430 3134 A1 12 02 01			.byte $a1,18,2,1 
   431 3138 A1 11 02 01			.byte $a1,17,2,1 
   432 313C A1 10 02 01			.byte $a1,16,2,1 
   433 3140 A1 0F 02 01			.byte $a1,15,2,1 
   434 3144 A1 0E 02 01			.byte $a1,14,2,1 
   435 3148 A1 0D 02 01			.byte $a1,13,2,1 
   436 314C A1 0C 02 01			.byte $a1,12,2,1 
   437 3150 A1 0B 02 01			.byte $a1,11,2,1 
   438 3154 A1 0A 02 01			.byte $a1,10,2,1 
   439 3158 A1 09 02 01			.byte $a1,9,2,1 
   440 315C A1 08 02 01			.byte $a1,8,2,1 
   441 3160 A1 07 02 01			.byte $a1,7,2,1 
   442 3164 A1 06 02 01			.byte $a1,6,2,1 
   443 3168 A1 05 02 01			.byte $a1,5,2,1 
   444 316C A1 04 02 01			.byte $a1,4,2,1 
   445 3170 A1 03 02 01			.byte $a1,3,2,1 
   446 3174 A1 02 02 01			.byte $a1,2,2,1 
   447 3178 A1 01 02 01			.byte $a1,1,2,1 
   448 317C A1 00 02 01			.byte $a1,0,2,1 
   449
   450 3180 00 00 00 00			.byte $00,$00,0,0
   451
   452
   453 				; Pointers to starting sound entry in a sequence.
   454 3184			SOUND_FX_LO_TABLE
   455 3184 CC				.byte <SOUND_ENTRY_OFF
   456 3185 D0				.byte <SOUND_ENTRY_TINK
   457 3186 08				.byte <SOUND_ENTRY_SLIDE
   458 3187 A4				.byte <SOUND_ENTRY_HUMMER_A
   459 3188 C4				.byte <SOUND_ENTRY_HUMMER_B
   460 3189 E4				.byte <SOUND_ENTRY_DIRGE
   461 318A 98				.byte <SOUND_ENTRY_THUMP
   462 318B B0				.byte <SOUND_ENTRY_ODE2JOY
   463 318C E0				.byte <SOUND_ENTRY_WATER
   464 318D F8				.byte <SOUND_ENTRY_ENGINES
   465 318E EC				.byte <SOUND_ENTRY_BLING
   466 318F 10				.byte <SOUND_ENTRY_DOWNS
   467 3190 28				.byte <SOUND_ENTRY_LEFTS
   468
   469
   470 3191			SOUND_FX_HI_TABLE
   471 3191 2D				.byte >SOUND_ENTRY_OFF
   472 3192 2D				.byte >SOUND_ENTRY_TINK
   473 3193 2E				.byte >SOUND_ENTRY_SLIDE
   474 3194 2E				.byte >SOUND_ENTRY_HUMMER_A
   475 3195 2E				.byte >SOUND_ENTRY_HUMMER_B
   476 3196 2E				.byte >SOUND_ENTRY_DIRGE
   477 3197 2F				.byte >SOUND_ENTRY_THUMP
   478 3198 2F				.byte >SOUND_ENTRY_ODE2JOY
   479 3199 30				.byte >SOUND_ENTRY_WATER
   480 319A 30				.byte >SOUND_ENTRY_ENGINES
   481 319B 2D				.byte >SOUND_ENTRY_BLING
   482 319C 31				.byte >SOUND_ENTRY_DOWNS
   483 319D 31				.byte >SOUND_ENTRY_LEFTS
   484
   485
   486 				; ==========================================================================
   487 				; ToPlayFXScrollOrNot                                             A  X  Y
   488 				; -------------------------------------------------------------------------- 
   489 				; Decide to start playing the slide sound or not.
   490 				; 
   491 				; The duration of the slide on screen should be the same(ish) as the 
   492 				; length of the sound playing.  Therefore the sound should run out at the
   493 				; same time the slide finishes (more or less)    
   494 				; 
   495 				; Uses all the registers. 
   496 				; X = sound channel to assign.
   497 				; Y = sound number to use. (values declared at beginning of Audio.asm.) 
   498 				; --------------------------------------------------------------------------
   499
   500 319E			ToPlayFXScrollOrNot
   501
   502 319E A5 ED			lda SOUND_CONTROL3      ; Is channel 3 busy?
   503 31A0 D0 07			bne ExitToPlayFXScroll  ; Yes.  Don't do anything.
   504
   505 31A2 A2 03			ldx #3                  ; Setup channel 3 to play slide sound.
   506 31A4 A0 02			ldy #SOUND_SLIDE
   507 31A6 20 7D 32			jsr SetSound 
   508
   509 31A9			ExitToPlayFXScroll
   510 31A9 60				rts
   511
   512
   513 				; ==========================================================================
   514 				; ToReplayFXWaterOrNot                                             A  X  Y
   515 				; -------------------------------------------------------------------------- 
   516 				; To Replay water effects or not
   517 				; 
   518 				; Main routine to play the Water sounds during the game. 
   519 				; This checks the channel 3 control to see if it is idle.  
   520 				; If the channel is idle then the water effects sound sequence is restarted.
   521 				;
   522 				; Water is a series of long duration white noise/hissing sounds. 
   523 				; 
   524 				; Uses all the registers. 
   525 				; X = sound channel to assign.
   526 				; Y = sound number to use. (values declared at beginning of Audio.asm.) 
   527 				; --------------------------------------------------------------------------
   528
   529 31AA			ToReplayFXWaterOrNot
   530
   531 31AA A5 ED			lda SOUND_CONTROL3      ; Is channel 3 busy?
   532 31AC D0 07			bne ExitPlayWaterFX     ; Yes.  Don't do anything.
   533
   534 31AE			PlayWaterFX
   535 31AE A2 03			ldx #3                  ; Setup channel 3 to play water noises
   536 31B0 A0 08			ldy #SOUND_WATER
   537 31B2 20 7D 32			jsr SetSound
   538
   539 31B5			ExitPlayWaterFX
   540 31B5 60				rts
   541
   542
   543 				; ==========================================================================
   544 				; ToReplayFXEnginesOrNot                                           A  X  Y
   545 				; -------------------------------------------------------------------------- 
   546 				; To Replay engine noise effects or not
   547 				; 
   548 				; Main routine to play the Engine sounds during the game. 
   549 				; This checks the channel 1 control to see if it is idle.  
   550 				; If the channel is idle then the engines sound sequence is restarted.
   551 				;
   552 				; Engines are a series of long duration buzzing sounds. 
   553 				; 
   554 				; Uses all the registers. 
   555 				; X = sound channel to assign.
   556 				; Y = sound number to use. (values declared at beginning of Audio.asm.) 
   557 				; --------------------------------------------------------------------------
   558
   559 31B6			ToReplayFXEnginesOrNot
   560
   561 31B6 A5 EB			lda SOUND_CONTROL1      ; Is channel 1 busy?
   562 31B8 D0 07			bne ExitPlayEnginesFX   ; Yes.  Don't do anything.
   563
   564 31BA			PlayEnginesFX
   565 31BA A2 01			ldx #1                  ; Setup channel 1 to play water noises
   566 31BC A0 09			ldy #SOUND_ENGINES
   567 31BE 20 7D 32			jsr SetSound
   568
   569 31C1			ExitPlayEnginesFX
   570 31C1 60				rts
   571
   572
   573 				; ==========================================================================
   574 				; PlayThump                                                      *  *  *
   575 				; -------------------------------------------------------------------------- 
   576 				; Play Thump for jumping frog
   577 				;
   578 				; Main routine uses this to play the frog movement sound. 
   579 				; This needs to be introduced where the main code is dependent on 
   580 				; the CPU flags for determining outcomes. Therefore, to prevent disrupting 
   581 				; the logic flow due to flag changes this routine is wrapped in the macros 
   582 				; to preserve/protect all registers to insure calling this routine has no 
   583 				; discernible effect on the Main code.
   584 				; 
   585 				; Uses A, X, Y, but preserves all registers on entry/exit.
   586 				; --------------------------------------------------------------------------
   587
   588 31C2			PlayThump
   589
   590 31C2				mRegSave                   ; Macro: save CPU flags, and A, X, Y
Macro: MREGSAVE [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/macros.asm]
     1 31C2 08				PHP 
     1 31C3 48				PHA 
     2 31C4 98				TYA 
     3 31C5 48				PHA 
     4 31C6 8A				TXA 
     5 31C7 48				PHA 
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03Audio.asm
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03Audio.asm
   591
   592 31C8 A2 02			ldx #2                     ; Setup channel 2 to play frog bump.
   593 31CA A0 06			ldy #SOUND_THUMP
   594 31CC 20 7D 32			jsr SetSound 
   595
   596 31CF				mRegRestore                ; Macro: Restore Y, X, A, and CPU flags
Macro: MREGRESTORE [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/macros.asm]
     1 31CF 68				PLA 
     2 31D0 AA				TAX 
     3 31D1 68				PLA 
     4 31D2 A8				TAY 
     5 31D3 68				PLA 
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03Audio.asm
     3 31D4 28				PLP 
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03Audio.asm
   597
   598 31D5 60				rts
   599
   600
   601 				; ==========================================================================
   602 				; PlayTink                                                       *  *  *
   603 				; -------------------------------------------------------------------------- 
   604 				; Play tink for button input
   605 				;
   606 				; Main routine uses this to play the feedback sound for button input.
   607 				; 
   608 				; Uses A, X, Y, but preserves all registers on entry/exit.
   609 				; --------------------------------------------------------------------------
   610
   611 31D6			PlayTink
   612
   613 31D6				mRegSave                 ; Macro: save CPU flags, and A, X, Y
Macro: MREGSAVE [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/macros.asm]
     1 31D6 08				PHP 
     1 31D7 48				PHA 
     2 31D8 98				TYA 
     3 31D9 48				PHA 
     4 31DA 8A				TXA 
     5 31DB 48				PHA 
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03Audio.asm
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03Audio.asm
   614
   615 31DC A2 02			ldx #2                   ; Button pressed. Set Pokey channel 2 to tink sound.
   616 31DE A0 01			ldy #SOUND_TINK
   617 31E0 20 7D 32			jsr SetSound 
   618
   619 31E3				mRegRestore              ; Macro: Restore Y, X, A, and CPU flags
Macro: MREGRESTORE [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/macros.asm]
     1 31E3 68				PLA 
     2 31E4 AA				TAX 
     3 31E5 68				PLA 
     4 31E6 A8				TAY 
     5 31E7 68				PLA 
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03Audio.asm
     3 31E8 28				PLP 
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03Audio.asm
   620
   621 31E9 60				rts
   622
   623
   624 				; ==========================================================================
   625 				; PlayBling                                                      *  *  *
   626 				; -------------------------------------------------------------------------- 
   627 				; Play Bling for each 100 points awarded for saved frog
   628 				;
   629 				; Main routine uses this to play the bling sound for every 
   630 				; 100 points added to the score when a frog is saved. 
   631 				; 
   632 				; Uses A, X, Y, but preserves all registers on entry/exit.
   633 				; --------------------------------------------------------------------------
   634
   635 31EA			PlayBling
   636
   637 31EA				mRegSave                   ; Macro: save CPU flags, and A, X, Y
Macro: MREGSAVE [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/macros.asm]
     1 31EA 08				PHP 
     1 31EB 48				PHA 
     2 31EC 98				TYA 
     3 31ED 48				PHA 
     4 31EE 8A				TXA 
     5 31EF 48				PHA 
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03Audio.asm
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03Audio.asm
   638
   639 31F0 A2 01			ldx #1                     ; Setup channel 1 to play ding a ling.
   640 31F2 A0 0A			ldy #SOUND_BLING
   641 31F4 20 7D 32			jsr SetSound 
   642
   643 31F7				mRegRestore                ; Macro: Restore Y, X, A, and CPU flags
Macro: MREGRESTORE [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/macros.asm]
     1 31F7 68				PLA 
     2 31F8 AA				TAX 
     3 31F9 68				PLA 
     4 31FA A8				TAY 
     5 31FB 68				PLA 
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03Audio.asm
     3 31FC 28				PLP 
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03Audio.asm
   644
   645 31FD 60				rts
   646
   647
   648 				; ==========================================================================
   649 				; PlayLefts                                                      *  *  *
   650 				; -------------------------------------------------------------------------- 
   651 				; Play Left movement sound for title graphics on OPTION and SELECT
   652 				; 
   653 				; Uses A, X, Y, but preserves all registers on entry/exit.
   654 				; --------------------------------------------------------------------------
   655
   656 31FE			PlayLefts
   657
   658 31FE				mRegSave                   ; Macro: save CPU flags, and A, X, Y
Macro: MREGSAVE [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/macros.asm]
     1 31FE 08				PHP 
     1 31FF 48				PHA 
     2 3200 98				TYA 
     3 3201 48				PHA 
     4 3202 8A				TXA 
     5 3203 48				PHA 
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03Audio.asm
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03Audio.asm
   659
   660 3204 A2 02			ldx #2                     ; Setup channel 2 to play.
   661 3206 A0 0C			ldy #SOUND_LEFTS
   662 3208 20 7D 32			jsr SetSound 
   663
   664 320B				mRegRestore                ; Macro: Restore Y, X, A, and CPU flags
Macro: MREGRESTORE [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/macros.asm]
     1 320B 68				PLA 
     2 320C AA				TAX 
     3 320D 68				PLA 
     4 320E A8				TAY 
     5 320F 68				PLA 
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03Audio.asm
     3 3210 28				PLP 
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03Audio.asm
   665
   666 3211 60				rts
   667
   668
   669 				; ==========================================================================
   670 				; PlayDowns                                                      *  *  *
   671 				; -------------------------------------------------------------------------- 
   672 				; Play down movement sound for title graphics on OPTION and SELECT
   673 				; 
   674 				; Uses A, X, Y, but preserves all registers on entry/exit.
   675 				; --------------------------------------------------------------------------
   676
   677 3212			PlayDowns
   678
   679 3212				mRegSave                   ; Macro: save CPU flags, and A, X, Y
Macro: MREGSAVE [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/macros.asm]
     1 3212 08				PHP 
     1 3213 48				PHA 
     2 3214 98				TYA 
     3 3215 48				PHA 
     4 3216 8A				TXA 
     5 3217 48				PHA 
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03Audio.asm
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03Audio.asm
   680
   681 3218 A2 01			ldx #1                     ; Setup channel 2 to play.
   682 321A A0 0B			ldy #SOUND_DOWNS
   683 321C 20 7D 32			jsr SetSound 
   684
   685 321F				mRegRestore                ; Macro: Restore Y, X, A, and CPU flags
Macro: MREGRESTORE [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/macros.asm]
     1 321F 68				PLA 
     2 3220 AA				TAX 
     3 3221 68				PLA 
     4 3222 A8				TAY 
     5 3223 68				PLA 
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03Audio.asm
     3 3224 28				PLP 
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03Audio.asm
   686
   687 3225 60				rts
   688
   689
   690 				; ==========================================================================
   691 				; PlaySaberHum                                                    *  *  *
   692 				; -------------------------------------------------------------------------- 
   693 				; Play light saber hum using two channels.
   694 				; 
   695 				; Uses A, X, Y, but preserves all registers on entry/exit.
   696 				; --------------------------------------------------------------------------
   697
   698 3226			PlaySaberHum
   699
   700 3226				mRegSave                   ; Macro: save CPU flags, and A, X, Y
Macro: MREGSAVE [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/macros.asm]
     1 3226 08				PHP 
     1 3227 48				PHA 
     2 3228 98				TYA 
     3 3229 48				PHA 
     4 322A 8A				TXA 
     5 322B 48				PHA 
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03Audio.asm
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03Audio.asm
   701
   702 322C A2 00			ldx #0                     ; Setup channel 0 to play light saber A sound.
   703 322E A0 03			ldy #SOUND_HUM_A
   704 3230 20 7D 32			jsr SetSound
   705
   706 3233 A2 01			ldx #1                     ; Setup channel 1 to play light saber B sound.
   707 3235 A0 04			ldy #SOUND_HUM_B
   708 3237 20 7D 32			jsr SetSound 
   709
   710 323A				mRegRestore                ; Macro: Restore Y, X, A, and CPU flags
Macro: MREGRESTORE [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/macros.asm]
     1 323A 68				PLA 
     2 323B AA				TAX 
     3 323C 68				PLA 
     4 323D A8				TAY 
     5 323E 68				PLA 
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03Audio.asm
     3 323F 28				PLP 
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03Audio.asm
   711
   712 3240 60				rts
   713
   714
   715 				; ==========================================================================
   716 				; PlayOdeToJoy                                                    *  *  *
   717 				; -------------------------------------------------------------------------- 
   718 				; Play Ode To Joy for saving the frog.  Uses two channels, 2 and 3.
   719 				; The playback is offset by a frame for each voice to produce a 
   720 				; slight ringing, electric echo effect.
   721 				; 
   722 				; Uses A, X, Y, but preserves all registers on entry/exit.
   723 				; --------------------------------------------------------------------------
   724
   725 3241			PlayOdeToJoy
   726
   727 3241				mRegSave                   ; Macro: save CPU flags, and A, X, Y
Macro: MREGSAVE [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/macros.asm]
     1 3241 08				PHP 
     1 3242 48				PHA 
     2 3243 98				TYA 
     3 3244 48				PHA 
     4 3245 8A				TXA 
     5 3246 48				PHA 
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03Audio.asm
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03Audio.asm
   728
   729 3247 A2 03			ldx #3                  ; Setup channel 3 to play Ode To Joy for saving the frog.
   730 3249 A0 07			ldy #SOUND_JOY
   731 324B 20 7D 32			jsr SetSound 
   732
   733 324E 20 17 29			jsr libScreenWaitFrame  ; Wait for a frame.
   734
   735 3251 A2 02			ldx #2                  ; Setup channel 2 to play Ode To Joy for saving the frog.
   736 3253 A0 07			ldy #SOUND_JOY
   737 3255 20 7D 32			jsr SetSound 
   738
   739 3258				mRegRestore                ; Macro: Restore Y, X, A, and CPU flags
Macro: MREGRESTORE [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/macros.asm]
     1 3258 68				PLA 
     2 3259 AA				TAX 
     3 325A 68				PLA 
     4 325B A8				TAY 
     5 325C 68				PLA 
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03Audio.asm
     3 325D 28				PLP 
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03Audio.asm
   740
   741 325E 60				rts
   742
   743
   744 				; ==========================================================================
   745 				; PlayFuneral                                                    *  *  *
   746 				; -------------------------------------------------------------------------- 
   747 				; Play Funeral dirge when a frog dies. 
   748 				; 
   749 				; Uses A, X, Y, but preserves all registers on entry/exit.
   750 				; --------------------------------------------------------------------------
   751
   752 325F			PlayFuneral
   753
   754 325F				mRegSave                   ; Macro: save CPU flags, and A, X, Y
Macro: MREGSAVE [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/macros.asm]
     1 325F 08				PHP 
     1 3260 48				PHA 
     2 3261 98				TYA 
     3 3262 48				PHA 
     4 3263 8A				TXA 
     5 3264 48				PHA 
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03Audio.asm
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03Audio.asm
   755
   756 3265 A2 03			ldx #3                     ; Setup channel 3 to play funeral dirge for the dead frog.
   757 3267 A0 05			ldy #SOUND_DIRGE
   758 3269 20 7D 32			jsr SetSound 
   759
   760 326C				mRegRestore                ; Macro: Restore Y, X, A, and CPU flags
Macro: MREGRESTORE [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/macros.asm]
     1 326C 68				PLA 
     2 326D AA				TAX 
     3 326E 68				PLA 
     4 326F A8				TAY 
     5 3270 68				PLA 
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03Audio.asm
     3 3271 28				PLP 
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03Audio.asm
   761
   762 3272 60				rts
   763
   764
   765 				; ==========================================================================
   766 				; StopAllSound                                                      A  X 
   767 				; -------------------------------------------------------------------------- 
   768 				; Stop All Sound
   769 				;
   770 				; Main routine to stop all playing for all channels.
   771 				;
   772 				; Set the control for each channel to 255 to stop everything now.
   773 				; 
   774 				; Uses A, X
   775 				; X = sound channel to assign.
   776 				; --------------------------------------------------------------------------
   777
   778 3273			StopAllSound
   779
   780 3273 A2 03			ldx #3               ; Channel 3, 2, 1, 0
   781 3275 A9 FF			lda #255             ; Tell VBI to silence channel.
   782
   783 3277			LoopStopSound
   784 3277 95 EA			sta SOUND_CONTROL,x  ; Set channel control to silence.
   785 3279 CA				dex
   786 327A 10 FB			bpl LoopStopSound    ; Channel 3, 2, 1, 0
   787
   788 327C 60				rts
   789
   790
   791 				; ==========================================================================
   792 				; SetSound                                                        A  X  Y
   793 				; -------------------------------------------------------------------------- 
   794 				; Set Sound
   795 				;
   796 				; Main routine to set sound playing for a channel.
   797 				;
   798 				; The procedure for playing sound.
   799 				; 1) MAIN sets the channel's SOUND_CONTROL to 0.
   800 				; 2) MAIN sets the channel's SOUND_FX_LO/HI pointer to the sound effects 
   801 				;    sequence to play.
   802 				; 3) MAIN sets the channel's SOUND_CONTROL to 1 to tell VBI to start.
   803 				; 4) VBI when playing sets the channel's SOUND_CONTROL value to 2, then 
   804 				;    to 0 when done.
   805 				;
   806 				; Uses A, X, Y
   807 				; X = sound channel to assign. (0 to 3, not 1 to 4)
   808 				; Y = sound number to use. (values declared at beginning of Audio.asm.) 
   809 				; --------------------------------------------------------------------------
   810
   811 327D			SetSound
   812
   813 327D A9 00			lda #0
   814 327F 95 EA			sta SOUND_CONTROL,X     ; Tell VBI to stop working POKEY channel X
   815
   816 3281 B9 84 31			lda SOUND_FX_LO_TABLE,Y ; Assign pointer of sound effect
   817 3284 95 E2			sta SOUND_FX_LO,X       ; to the channel controller.
   818 3286 B9 91 31			lda SOUND_FX_HI_TABLE,Y
   819 3289 95 E6			sta SOUND_FX_HI,X
   820
   821 328B A9 01			lda #1
   822 328D 95 EA			sta SOUND_CONTROL,X     ; Tell VBI it can start running POKEY channel X
   823
   824 328F 60				rts
   825
   826
   827 				; ==========================================================================
   828 				; SoundService                                                    A  X  Y
   829 				; --------------------------------------------------------------------------
   830 				; Sound service called by Deferred Vertical Blank Interrupt.
   831 				;
   832 				; The world's cheapest sequencer. Play one sound value from a table at each 
   833 				; call. Assuming this is done synchronized to the frame it performs a sound 
   834 				; change every 16.6ms (approximately)
   835 				; 
   836 				; Sound control between main process and VBI to turn on/off/play sounds.
   837 				; 0   = Set by Main to direct stop managing sound pending an update from 
   838 				;       MAIN. This does not stop the POKEY's currently playing sound. 
   839 				;       It is set by the VBI to indicate the channel is idle/unmanaged. 
   840 				; 1   = Main sets to direct VBI to start playing a new sound FX.
   841 				; 2   = VBI sets when it is playing to inform Main that it has taken 
   842 				;       direction and is now busy.
   843 				; 255 = Direct VBI to silence the channel.
   844 				;
   845 				; So, the procedure for playing sound.
   846 				; 1) MAIN sets the channel's SOUND_CONTROL to 0.
   847 				; 2) MAIN sets the channel's SOUND_FX_LO/HI pointer to the sound effects 
   848 				;    sequence to play.
   849 				; 3) MAIN sets the channel's SOUND_CONTROL to 1 to tell VBI to start.
   850 				; 4) VBI when playing sets the channel's SOUND_CONTROL value to 2, then 
   851 				;    to 0 when done.
   852 				;
   853 				; A sound Entry is 4 bytes...
   854 				; byte 0, AUDC (distortion/volume) value
   855 				; byte 1, AUDF (frequency) value
   856 				; byte 2, Duration, number of frames to count. 0 counts as 1 frame.
   857 				; byte 3, 0 == End of sequence. Stop playing sound. (Set AUDF and AUDC to 0)
   858 				;         1 == Continue normal playing.
   859 				;       255 == End of sequence. Do not stop playing sound.
   860 				;       Eventually some other magic to be determined goes here.
   861 				; --------------------------------------------------------------------------
   862
   863 3290			SoundService
   864
   865 3290 A2 03			ldx #3
   866 3292			LoopSoundServiceControl
   867 3292 B5 EA			lda SOUND_CONTROL,x
   868 3294 F0 3F			beq DoNextSoundChannel       ; SOUND_CONTROL == 0 means do nothing
   869
   870 3296 C9 FF			cmp #255                     ; Is it 255 (-1)?
   871 3298 D0 06			bne CheckMainSoundDirections ; No, then go follow channel FX directions.
   872 329A 20 05 33			jsr EndFXAndStopSound        ; SOUND_CONTROL == 255 Direction from main to stop sound.
   873 329D 4C D5 32			jmp DoNextSoundChannel
   874
   875 32A0			CheckMainSoundDirections
   876 32A0 C9 01			cmp #1                   ; SOUND_CONTROL == 1 New direction from main?
   877 32A2 D0 12			bne DoNormalSoundService ; No, continue normally.
   878
   879 				; SOUND_CONTROL == 1  is new direction from Main.  Setup new request.
   880 32A4 A9 02			lda #2
   881 32A6 95 EA			sta SOUND_CONTROL,x      ; Tell Main we're on the clock
   882
   883 32A8 20 D9 32			jsr LoadSoundPointerFromX ; Get the pointer to the current entry.
   884
   885 					; This is the first time in this Entry.  
   886 32AB 20 FA 32			jsr EvaluateEntryControlToStop  ; test if this is the end now.
   887 32AE F0 25			beq DoNextSoundChannel          ; If so, then we're done.
   888
   889 32B0 20 E2 32			jsr LoadTheCurrentSoundEntry    ; If not, then load sound up the first time,
   890 32B3 4C D5 32			jmp DoNextSoundChannel          ; and then we're done without evaluation duration.
   891
   892 32B6			DoNormalSoundService                ; SOUND_CONTROL == 2.  VBI is running normally.
   893 32B6 B5 EE			lda SOUND_DURATION,x            ; If sound currently running has a duration, then decrement and loop.
   894 32B8 F0 05			beq ContinueNextSound           ; 0 means end of duration.  Load sound for the currently queued entry.
   895 32BA D6 EE			dec SOUND_DURATION,x            ; Otherwise, Decrement duration.
   896 32BC 4C D5 32			jmp DoNextSoundChannel          ; Maybe on the next frame there will be something to do.
   897
   898 32BF			ContinueNextSound
   899 32BF 20 D9 32			jsr LoadSoundPointerFromX       ; Get the pointer to the current entry.
   900 32C2 20 FA 32			jsr EvaluateEntryControlToStop 
   901 					; If the Entry Control set CONTROL to stop the sound, then do no more work.
   902 32C5 F0 0E			beq DoNextSoundChannel          ; SOUND_CONTROL == 0 means do nothing
   903
   904 32C7			DoTheCurrentSound                   ; Duration is 0. Just do current parameters.
   905 32C7 20 E2 32			jsr LoadTheCurrentSoundEntry
   906
   907 32CA			GoToNextSoundEntry                  ; Add 4 to the current pointer address to get the next entry.
   908 32CA 18				clc
   909 32CB B5 E2			lda SOUND_FX_LO,X
   910 32CD 69 04			adc #4
   911 32CF 95 E2			sta SOUND_FX_LO,X
   912 32D1 90 02			bcc DoNextSoundChannel
   913 32D3 F6 E6			inc SOUND_FX_HI,X
   914
   915 32D5			DoNextSoundChannel
   916 32D5 CA				dex                            ; 3,2,1,0....
   917 32D6 10 BA			bpl LoopSoundServiceControl
   918
   919 32D8			ExitSoundService
   920 32D8 60				rts
   921
   922
   923 				; Given X, load the current Entry pointer into SOUND_POINTER
   924 32D9			LoadSoundPointerFromX
   925 32D9 B5 E2			lda SOUND_FX_LO,X       ; Get Pointer to specified sound effect.
   926 32DB 85 E0			sta SOUND_POINTER
   927 32DD B5 E6			lda SOUND_FX_HI,X
   928 32DF 85 E1			sta SOUND_POINTER+1
   929
   930 32E1 60				rts
   931
   932
   933 				; Given X and SOUND_POINTER pointing to the entry, then set
   934 				; audio controls.
   935 32E2			LoadTheCurrentSoundEntry
   936 32E2 20 19 33			jsr SaveXTimes2          ;  X = X * 2  (but save original value)
   937
   938 32E5 A0 00			ldy #0                   ; Pull AUDC
   939 32E7 B1 E0			lda (SOUND_POINTER),y
   940 32E9 9D 01 D2			sta AUDC1,X
   941 32EC C8				iny
   942 32ED B1 E0			lda (SOUND_POINTER),y    ; Pull AUDF
   943 32EF 9D 00 D2			sta AUDF1,X
   944 32F2 C8				iny
   945 32F3 B1 E0			lda (SOUND_POINTER),y    ; Pull Duration
   946 32F5 A6 FE			ldx SAVEX                ; Get original X * 1 value.
   947 32F7 95 EE			sta SOUND_DURATION,X
   948
   949 32F9 60				rts
   950
   951
   952 				; Does the Entry control says to stop sound? 
   953 32FA			EvaluateEntryControlToStop
   954 32FA A0 03			ldy #3
   955 32FC B1 E0			lda (SOUND_POINTER),y    ; What does entry control say?
   956 32FE F0 05			beq EndFXAndStopSound    ; 0 means the end.
   957 3300 30 10			bmi EndFX                ; 255 means end, without stopping sound.
   958
   959 3302 B1 E0			lda (SOUND_POINTER),y    ; What does entry control say? (return to caller)
   960
   961 3304 60				rts
   962
   963
   964 				; Entry control says the sound is over, and stop the sound...
   965 3305			EndFXAndStopSound
   966 3305 20 19 33			jsr SaveXTimes2          ;  X = X * 2  (but save original value)
   967
   968 3308 A9 00			lda #0                   
   969 330A 9D 01 D2			sta AUDC1,X              ; Stop POKEY playing.
   970 330D 9D 00 D2			sta AUDF1,X
   971 3310 A6 FE			ldx SAVEX                ; Get original X * 1 value.
   972
   973 				; Entry control says the sound is over. (but don't actually stop POKEY).
   974 3312			EndFX
   975 3312 A9 00			lda #0
   976 3314 95 EE			sta SOUND_DURATION,X     ; Make duration 0.
   977 3316 95 EA			sta SOUND_CONTROL,X      ; And inform MAIN and VBI this channel is unused.
   978
   979 3318 60				rts
   980
   981 				; In order to index the reference to AUDC and AUDF we need the channel 
   982 				; number in X temporarily multiplied by 2.
   983 3319			SaveXTimes2
   984 3319 86 FE			stx SAVEX                ; Save the current X
   985 331B 8A				txa                      ; A = X
   986 331C 0A				asl                      ; A = A << 1  ; (or A = A *2)
   987 331D AA				tax                      ; X = A  (0, 1, 2, 3 is now 0, 2, 4, 6).
   988
   989 331E 60				rts
   714
   715 331F				icl "Frogger03ScreenGfx.asm"    ; Support drawing frog in screen memory.
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03ScreenGfx.asm
     1 				; ==========================================================================
     2 				; Pet Frogger
     3 				; (c) November 1983 by John C. Dale, aka Dalesoft
     4 				; for the Commodore Pet 4032
     5 				; ==========================================================================
     6 				; Ported (parodied) to Atari 8-bit computers
     7 				; by Ken Jennings (if this were 1983, aka FTR Enterprises)
     8 				; ==========================================================================
     9 				; Version 00, November 2018
    10 				; Version 01, December 2018
    11 				; Version 02, February 2019
    12 				; Version 03, August 2019
    13 				; ==========================================================================
    14
    15 				; ==========================================================================
    16 				; SCREEN GRAPHICS
    17 				; ==========================================================================
    18 				; This should contain everything that pertains to changes in visible screen 
    19 				; components.  
    20 				; Managing the score/status lines.
    21 				; Managing scrolling boats/display lists.
    22 				; Maintaining the Player/missile objects, and moving the objects around. 
    23 				; Updating color table contents for each of the displays.
    24
    25 				; The original Pet version mixed printing to the screen with direct
    26 				; writes to screen memory.  The printing required adjustments, because
    27 				; the Atari full screen editor works differently from the Pet terminal.
    28
    29 				; Most of the ASCII/PETASCII/ATASCII is now removed.  No more "printing"
    30 				; to the screen.  Everything is directly written to the screen memory.
    31 				; All the data to write to the screen is declared, then the addresses to
    32 				; the data is listed in a table. Rather than several different screen
    33 				; printing routines there is now one display routine that accepts an index
    34 				; into the table driving the data movement to screen memory.  Since the
    35 				; data also has a declared length the end of text sentinel byte is no
    36 				; longer needed.
    37 				; --------------------------------------------------------------------------
    38
    39 				; Display layouts and associated text blocks:
    40
    41 				; Original V00 Title Screen and Instructions:
    42 				;    +----------------------------------------+
    43 				; 1  |              PET FROGGER               | INSTXT_1
    44 				; 2  |              --- -------               | INSTXT_1
    45 				; 3  |     (c) November 1983 by DalesOft      | INSTXT_1
    46 				; 4  |                                        |
    47 				; 5  |All you have to do is to get as many of | INSTXT_2
    48 				; 6  |the frogs across the river without      | INSTXT_2
    49 				; 7  |drowning them. You have to leap onto a  | INSTXT_2
    50 				; 8  |boat like this :- <QQQ] and land on the | INSTXT_2
    51 				; 9  |seats ('Q'). You get 10 points for every| INSTXT_2
    52 				; 10 |jump forward and 500 points every time  | INSTXT_2
    53 				; 11 |you get a frog across the river.        | INSTXT_2
    54 				; 12 |                                        |
    55 				; 13 |                                        |
    56 				; 14 |                                        |
    57 				; 15 |The controls are :-                     | INSTXT_3
    58 				; 16 |                 S = Up                 | INSTXT_3
    59 				; 17 |  4 = left                   6 = right  | INSTXT_3
    60 				; 18 |                                        |
    61 				; 19 |                                        |
    62 				; 20 |     Hit any key to start the game.     | INSTXT_4
    63 				; 21 |                                        |
    64 				; 22 |                                        |
    65 				; 23 |                                        |
    66 				; 24 |                                        |
    67 				; 25 |Atari V00 port by Ken Jennings, Nov 2018| PORTBYTEXT
    68 				;    +----------------------------------------+
    69
    70 				;  Original V00 Main Game Play Screen:
    71 				;    +----------------------------------------+
    72 				; 1  |Successful Crossings =                  | SCORE_TXT
    73 				; 2  |Score = 00000000     Hi = 00000000  Lv:3| SCORE_TXT
    74 				; 3  |BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB| TEXT1_1
    75 				; 4  | [QQQQ>        [QQQQ>       [QQQQ>      | TEXT1_1
    76 				; 5  |      <QQQQ]        <QQQQ]    <QQQQ]    | TEXT1_1
    77 				; 6  |BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB| TEXT1_2
    78 				; 7  | [QQQQ>        [QQQQ>       [QQQQ>      | TEXT1_2
    79 				; 8  |      <QQQQ]        <QQQQ]    <QQQQ]    | TEXT1_2
    80 				; 9  |BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB| TEXT1_3
    81 				; 10 | [QQQQ>        [QQQQ>       [QQQQ>      | TEXT1_3
    82 				; 11 |      <QQQQ]        <QQQQ]    <QQQQ]    | TEXT1_3
    83 				; 12 |BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB| TEXT1_4
    84 				; 13 | [QQQQ>        [QQQQ>       [QQQQ>      | TEXT1_4
    85 				; 14 |      <QQQQ]        <QQQQ]    <QQQQ]    | TEXT1_4
    86 				; 15 |BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB| TEXT1_5
    87 				; 16 | [QQQQ>        [QQQQ>       [QQQQ>      | TEXT1_5
    88 				; 17 |      <QQQQ]        <QQQQ]    <QQQQ]    | TEXT1_5
    89 				; 18 |BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB| TEXT1_6
    90 				; 29 | [QQQQ>        [QQQQ>       [QQQQ>      | TEXT1_6
    91 				; 20 |      <QQQQ]        <QQQQ]    <QQQQ]    | TEXT1_6
    92 				; 21 |BBBBBBBBBBBBBBBBBBBOBBBBBBBBBBBBBBBBBBBB| TEXT2
    93 				; 22 |     (c) November 1983 by DalesOft      | TEXT2
    94 				; 23 |        Written by John C Dale          | TEXT2
    95 				; 24 |                                        |
    96 				; 25 |Atari V00 port by Ken Jennings, Nov 2018| PORTBYTEXT
    97 				;    +----------------------------------------+
    98
    99
   100
   101 				; Revised V01 Title Screen and Instructions:
   102 				;    +----------------------------------------+
   103 				; 1  |              PET FROGGER               | TITLE
   104 				; 2  |              --- -------               | TITLE
   105 				; 3  |     (c) November 1983 by DalesOft      | CREDIT
   106 				; 4  |        Written by John C Dale          | CREDIT
   107 				; 5  |Atari V01 port by Ken Jennings, Dec 2018| CREDIT
   108 				; 6  |                                        |
   109 				; 7  |Help the frogs escape from Doc Hopper's | INSTXT_1
   110 				; 8  |frog legs fast food franchise! But, the | INSTXT_1
   111 				; 9  |frogs must cross piranha-infested rivers| INSTXT_1
   112 				; 10 |to reach freedom. You have three chances| INSTXT_1
   113 				; 11 |to prove your frog management skills by | INSTXT_1
   114 				; 12 |directing frogs to jump on boats in the | INSTXT_1
   115 				; 13 |rivers like this:  <QQQQ]  Land only on | INSTXT_1
   116 				; 14 |the seats in the boats ('Q').           | INSTXT_1
   117 				; 15 |                                        |
   118 				; 16 |Scoring:                                | INSTXT_2
   119 				; 17 |    10 points for each jump forward.    | INSTXT_2
   120 				; 18 |   500 points for each rescued frog.    | INSTXT_2
   121 				; 19 |                                        |
   122 				; 20 |Game controls:                          | INSTXT_3
   123 				; 21 |                 S = Up                 | INSTXT_3
   124 				; 22 |      left = 4           6 = right      | INSTXT_3
   125 				; 23 |                                        |
   126 				; 24 |     Hit any key to start the game.     | INSTXT_4
   127 				; 25 |                                        |
   128 				;    +----------------------------------------+
   129
   130 				; Transition Title screen to Game Screen.
   131 				; Animate Credit lines down from Line 3 to Line 23.
   132
   133 				; Revised V01 Main Game Play Screen:
   134 				;    +----------------------------------------+
   135 				; 1  |Score:00000000               00000000:Hi| SCORE_TXT
   136 				; 2  |Frogs:0    Frogs Saved:OOOOOOOOOOOOOOOOO| SCORE_TXT
   137 				; 3  |BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB| TEXT1_1
   138 				; 4  | [QQQQ>        [QQQQ>       [QQQQ>      | TEXT1_1
   139 				; 5  |      <QQQQ]        <QQQQ]    <QQQQ]    | TEXT1_1
   140 				; 6  |BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB| TEXT1_2
   141 				; 7  | [QQQQ>        [QQQQ>       [QQQQ>      | TEXT1_2
   142 				; 8  |      <QQQQ]        <QQQQ]    <QQQQ]    | TEXT1_2
   143 				; 9  |BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB| TEXT1_3
   144 				; 10 | [QQQQ>        [QQQQ>       [QQQQ>      | TEXT1_3
   145 				; 11 |      <QQQQ]        <QQQQ]    <QQQQ]    | TEXT1_3
   146 				; 12 |BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB| TEXT1_4
   147 				; 13 | [QQQQ>        [QQQQ>       [QQQQ>      | TEXT1_4
   148 				; 14 |      <QQQQ]        <QQQQ]    <QQQQ]    | TEXT1_4
   149 				; 15 |BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB| TEXT1_5
   150 				; 16 | [QQQQ>        [QQQQ>       [QQQQ>      | TEXT1_5
   151 				; 17 |      <QQQQ]        <QQQQ]    <QQQQ]    | TEXT1_5
   152 				; 18 |BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB| TEXT1_6
   153 				; 19 | [QQQQ>        [QQQQ>       [QQQQ>      | TEXT1_6
   154 				; 20 |      <QQQQ]        <QQQQ]    <QQQQ]    | TEXT1_6
   155 				; 21 |BBBBBBBBBBBBBBBBBBBOBBBBBBBBBBBBBBBBBBBB| TEXT2
   156 				; 22 |                                        |
   157 				; 23 |     (c) November 1983 by DalesOft      | CREDIT
   158 				; 24 |        Written by John C Dale          | CREDIT
   159 				; 25 |Atari V01 port by Ken Jennings, Dec 2018| CREDIT
   160 				;    +----------------------------------------+
   161
   162
   163
   164 				; Revised V02 Title Screen and Instructions:
   165 				;    +----------------------------------------+
   166 				; 1  |Score:00000000               00000000:Hi| SCORE_TXT
   167 				; 2  |                                        |
   168 				; 3  |              PET FROGGER               | TITLE
   169 				; 4  |              PET FROGGER               | TITLE
   170 				; 5  |              PET FROGGER               | TITLE
   171 				; 6  |              --- -------               | TITLE
   172 				; 7  |                                        |
   173 				; 8  |Help the frogs escape from Doc Hopper's | INSTXT_1
   174 				; 9  |frog legs fast food franchise! But, the | INSTXT_1
   175 				; 10 |frogs must cross piranha-infested rivers| INSTXT_1
   176 				; 11 |to reach freedom. You have three chances| INSTXT_1
   177 				; 12 |to prove your frog management skills by | INSTXT_1
   178 				; 13 |directing frogs to jump on boats in the | INSTXT_1
   179 				; 14 |rivers like this:  <QQQQ]  Land only on | INSTXT_1
   180 				; 15 |the seats in the boats ('Q').           | INSTXT_1
   181 				; 16 |                                        |
   182 				; 17 |Scoring:                                | INSTXT_2
   183 				; 18 |    10 points for each jump forward.    | INSTXT_2
   184 				; 19 |   500 points for each rescued frog.    | INSTXT_2
   185 				; 20 |                                        |
   186 				; 21 |Use joystick control to jump forward,   | INSTXT_3
   187 				; 22 |left, and right.                        | INSTXT_3
   188 				; 23 |                                        |
   189 				; 24 |   Press joystick button to continue.   | ANYBUTTON_MEM
   190 				; 25 |(c) November 1983 by DalesOft  Written b| SCROLLING CREDIT
   191 				;    +----------------------------------------+
   192
   193 				; Revised V02 Main Game Play Screen:
   194 				;    +----------------------------------------+
   195 				; 1  |Score:00000000               00000000:Hi| SCORE_TXT
   196 				; 2  |Frogs:0    Frogs Saved:OOOOOOOOOOOOOOOOO| SCORE_TXT
   197 				; 3  |                                        |
   198 				; 4  |BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB| TEXT1_1
   199 				; 5  | [QQQQ>        [QQQQ>       [QQQQ>      | TEXT1_1
   200 				; 6  |      <QQQQ]        <QQQQ]    <QQQQ]    | TEXT1_1
   201 				; 7  |BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB| TEXT1_2
   202 				; 8  | [QQQQ>        [QQQQ>       [QQQQ>      | TEXT1_2
   203 				; 9  |      <QQQQ]        <QQQQ]    <QQQQ]    | TEXT1_2
   204 				; 10 |BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB| TEXT1_3
   205 				; 11 | [QQQQ>        [QQQQ>       [QQQQ>      | TEXT1_3
   206 				; 12 |      <QQQQ]        <QQQQ]    <QQQQ]    | TEXT1_3
   207 				; 13 |BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB| TEXT1_4
   208 				; 14 | [QQQQ>        [QQQQ>       [QQQQ>      | TEXT1_4
   209 				; 15 |      <QQQQ]        <QQQQ]    <QQQQ]    | TEXT1_4
   210 				; 16 |BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB| TEXT1_5
   211 				; 17 | [QQQQ>        [QQQQ>       [QQQQ>      | TEXT1_5
   212 				; 18 |      <QQQQ]        <QQQQ]    <QQQQ]    | TEXT1_5
   213 				; 19 |BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB| TEXT1_6
   214 				; 20 | [QQQQ>        [QQQQ>       [QQQQ>      | TEXT1_6
   215 				; 21 |      <QQQQ]        <QQQQ]    <QQQQ]    | TEXT1_6
   216 				; 22 |BBBBBBBBBBBBBBBBBBBOBBBBBBBBBBBBBBBBBBBB| TEXT2
   217 				; 23 |                                        |
   218 				; 24 |                                        |
   219 				; 25 |(c) November 1983 by DalesOft  Written b| SCROLLING CREDIT
   220 				;    +----------------------------------------+
   221
   222
   223
   224 				; Revised V03 Title Screen and Instructions:
   225 				;    +----------------------------------------+
   226 				; 1  |Score:00000000               00000000:Hi| SCORE_TXT
   227 				; 2  |Frogs:0       00000000000000000000:Saved| SCORE_TXT
   228 				; 3  |              PET FROGGER               | TITLE
   229 				; 4  |              PET FROGGER               | TITLE
   230 				; 5  |              PET FROGGER               | TITLE
   231 				; 6  |              --- -------               | TITLE
   232 				; 7  |                                        |
   233 				; 8  |Help the frogs escape evil Doc Hopper's | INSTXT_1
   234 				; 9  |Frog Legs Fast Food Franchise! But, the | INSTXT_1
   235 				; 10 |frogs must cross piranha-infested rivers| INSTXT_1
   236 				; 11 |to reach freedom. You have three chances| INSTXT_1
   237 				; 12 |to prove your frog management skills by | INSTXT_1
   238 				; 13 |directing frogs to jump on boats in the | INSTXT_1
   239 				; 14 |rivers. Land in the middle of the boats.| INSTXT_1
   240 				; 15 |Do not fall off or jump in the river.   | INSTXT_1
   241 				; 16 |                                        |
   242 				; 17 |Scoring:                                | INSTXT_2
   243 				; 18 |    10 points for each jump forward.    | INSTXT_2
   244 				; 19 |   500 points for each saved frog.      | INSTXT_2
   245 				; 20 |                                        |
   246 				; 21 |Use the joystick control to jump        | INSTXT_3
   247 				; 22 |forward, left, and right.               | INSTXT_3
   248 				; 23 |                                        |
   249 				; 24 | Press the joystick button to continue. | ANYBUTTON_MEM
   250 				; 25 |(c) November 1983 by DalesOft  Written b| SCROLLING CREDIT
   251 				;    +----------------------------------------+
   252
   253 				; Revised V03 Main Game Play Screen:
   254 				; FYI: Old boats.
   255 				; 8  | [QQQQ1        [QQQQ1       [QQQQ1      | TEXT1_2
   256 				; 9  |      <QQQQ0        <QQQQ0    <QQQQ0    | TEXT1_2
   257 				; New boats are larger to provide more safe surface for the larger 
   258 				; frog and to provide some additional graphics enhancement for 
   259 				; the boats.  Illustration below shows the entire memory needed 
   260 				; for scrolling.  Since boats on each row are identical, and 
   261 				; they are spaced equally, then scrolling only need move the 
   262 				; distance between two boats (16 chars), and then reset
   263 				; to the starting position. 
   264 				;    +----------------------------------------+
   265 				; 1  |Score:00000000               00000000:Hi| SCORE_TXT
   266 				; 2  |Frogs:0       00000000000000000000:Saved| SCORE_TXT
   267 				; 3  |                                        | 
   268 				; 4  |BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB| TEXT1_1
   269 				; 5  |[[QQQQQ>        [[QQQQQ>        [[QQQQQ>        [[QQQQQ>        | ; Boats Right
   270 				; 6  |<QQQQQ]]        <QQQQQ]]        <QQQQQ]]        <QQQQQ]]        | ; Boats Left
   271 				; 7  |BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB| TEXT1_2
   272 				; 8  |[[QQQQQ>        [[QQQQQ>        [[QQQQQ>        [[QQQQQ>        |
   273 				; 9  |<QQQQQ]]        <QQQQQ]]        <QQQQQ]]        <QQQQQ]]        |
   274 				; 10 |BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB| TEXT1_3
   275 				; 11 |[[QQQQQ>        [[QQQQQ>        [[QQQQQ>        [[QQQQQ>        |
   276 				; 12 |<QQQQQ]]        <QQQQQ]]        <QQQQQ]]        <QQQQQ]]        |
   277 				; 13 |BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB| TEXT1_4
   278 				; 14 |[[QQQQQ>        [[QQQQQ>        [[QQQQQ>        [[QQQQQ>        |
   279 				; 15 |<QQQQQ]]        <QQQQQ]]        <QQQQQ]]        <QQQQQ]]        |
   280 				; 16 |BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB| TEXT1_5
   281 				; 17 |[[QQQQQ>        [[QQQQQ>        [[QQQQQ>        [[QQQQQ>        |
   282 				; 18 |<QQQQQ]]        <QQQQQ]]        <QQQQQ]]        <QQQQQ]]        |
   283 				; 19 |BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB| TEXT1_6
   284 				; 20 |[[QQQQQ>        [[QQQQQ>        [[QQQQQ>        [[QQQQQ>        |
   285 				; 21 |<QQQQQ]]        <QQQQQ]]        <QQQQQ]]        <QQQQQ]]        |
   286 				; 22 |BBBBBBBBBBBBBBBBBBBOBBBBBBBBBBBBBBBBBBBB| TEXT2
   287 				; 23 |                                        |
   288 				; 24 |                                        |
   289 				; 25 |(c) November 1983 by DalesOft  Written b| SCROLLING CREDIT
   290 				;    +----------------------------------------+
   291
   292
   293 = 0006			STATUS_LUMA = 6 ; Base luminance for the status text.
   294
   295
   296 				; ==========================================================================
   297 				; D I S P L A Y S   A N D   P L A Y F I E L D 
   298 				; ==========================================================================
   299
   300
   301 				; ==========================================================================
   302 				; FLASH TITLE LABELS
   303 				; ==========================================================================
   304 				; Based on timer set high luminance colors for different screen labels.
   305 				; The VBI will reduce the brightness back to normal over time.
   306 				;
   307 				; AnimateFrames4 == timer to set the next label color
   308 				; EventCounter2  == number of label to change, 0, 1, 2, 3, 0, 1, 2, 3...
   309 				; --------------------------------------------------------------------------
   310
   311 331F			FlashTitleLabels
   312
   313 331F A5 B3			lda AnimateFrames4       ; Did the timer expire?
   314 3321 D0 28			bne EndFlashTitleLabels  ; No, nothing else to do.
   315
   316 3323 A9 1E			lda #30                  ; Reset the timer.
   317 3325 85 B3			sta AnimateFrames4          
   318
   319 3327 E6 9D			inc EventCounter2        ; Iterate the EventCounter 0, 1, 2, 3, 0, 1, 2....
   320 3329 A5 9D			lda EventCounter2
   321 332B 29 03			and #$03
   322 332D 85 9D			sta EventCounter2
   323 332F D0 05			bne DoFlashHi            ; On 1, 2, 3 go to next nest.
   324
   325 3331 20 99 34			jsr StrobeScoreLabel     ; 0 is flash Score label.
   326 3334 D0 15			bne EndFlashTitleLabels
   327
   328 3336			DoFlashHi                    ; 1 is flash the hi score label
   329 3336 C9 01			cmp #1
   330 3338 D0 05			bne DoFlashSaved 
   331 333A 20 B4 34			jsr StrobeHiScoreLabel   ; Flash Hi score label.
   332 333D D0 0C			bne EndFlashTitleLabels
   333
   334 333F			DoFlashSaved                 ; 2 is flash the Saved frogs label
   335 333F C9 02			cmp #2
   336 3341 D0 05			bne DoFlashLives
   337 3343 20 AB 34			jsr StrobeSavedLabel     ; Flash Saved frogs label.
   338 3346 D0 03			bne EndFlashTitleLabels
   339
   340 3348			DoFlashLives
   341 3348 20 A2 34			jsr StrobeLivesLabel     ; 3 is flash Frog lives label.
   342
   343 334B			EndFlashTitleLabels
   344 334B 60				rts
   345
   346
   347 				; ==========================================================================
   348 				; TITLE RENDER                                                        A
   349 				; ==========================================================================
   350 				; Copy the title image to the screen memory. 
   351 				; Accumulator determines behavior.
   352 				;
   353 				; Since screen memory has been restructured to perform horizontal scrolling,
   354 				; the coping and loading the displayed title is more complicated.
   355 				; 
   356 				; The defined/declared Title graphics are a block of 60 bytes. 
   357 				; The screen memory representation is a block of 120 bytes.  10 bytes on
   358 				; the left (default visible) and 10 bytes on the right (scroll-in buffer)
   359 				; 
   360 				;
   361 				; A == 0  Clear the Title.
   362 				; A == 1  Copy Title as is.
   363 				; A == -1 Use random value, mask with Title Image.
   364 				; ==========================================================================
   365 				; TITLE_START=TITLE_MEM1-1 ; Cheating. To show all color clocks from 
   366 				;                          ; TITLE_MEM1 the LMS is at * -1, and HSCROLL 0
   367 				; TITLE_END   = TITLE_START+10
   368 				;
   369 				; Values for manipulating screen memory.
   370 				; TITLE_LEFT  = TITLE_MEM1
   371 				; TITLE_RIGHT = TITLE_MEM1+10
   372 				;
   373 				; Start Scroll position = TITLE_START (Increment), HSCROL 0  (Decrement)
   374 				; End   Scroll position = TITLE_START + 9,         HSCROL 0
   375 				; --------------------------------------------------------------------------
   376
   377 334C			TitleRender
   378
   379 334C A2 09			ldx #9                   ; 10 iterations/bytes instead of 60.
   380
   381 334E C9 00			cmp #0                   ; Is is to clear?
   382 3350 F0 2A			beq bTR_LoopClearTitle   ; Yes.  Go clear.
   383 3352 30 3E			bmi bTR_LoopRandomTitle  ; No.  Next choice is the random rezz in.
   384
   385 3354			bTR_loopCopyTitle
   386 3354 BD C2 48			lda TITLE_GFX,x          ; Read from Title Image
   387 3357 9D 40 48			sta TITLE_LEFT,x         ; Copy to screen memory.
   388 335A BD CC 48			lda TITLE_GFX+10,x       ; And so on.
   389 335D 9D 54 48			sta TITLE_LEFT+20,x
   390 3360 BD D6 48			lda TITLE_GFX+20,x
   391 3363 9D 68 48			sta TITLE_LEFT+40,x
   392 3366 BD E0 48			lda TITLE_GFX+30,x
   393 3369 9D 7C 48			sta TITLE_LEFT+60,x
   394 336C BD EA 48			lda TITLE_GFX+40,x
   395 336F 9D 90 48			sta TITLE_LEFT+80,x
   396 3372 BD F4 48			lda TITLE_GFX+50,x
   397 3375 9D A4 48			sta TITLE_LEFT+100,x
   398 3378 CA				dex
   399 3379 10 D9			bpl bTR_loopCopyTitle
   400
   401 337B 60				rts
   402
   403 337C			bTR_LoopClearTitle
   404 337C 9D 40 48			sta TITLE_LEFT,x
   405 337F 9D 54 48			sta TITLE_LEFT+20,x
   406 3382 9D 68 48			sta TITLE_LEFT+40,x
   407 3385 9D 7C 48			sta TITLE_LEFT+60,x
   408 3388 9D 90 48			sta TITLE_LEFT+80,x
   409 338B 9D A4 48			sta TITLE_LEFT+100,x
   410 338E CA				dex
   411 338F 10 EB			bpl bTR_LoopClearTitle
   412
   413 3391 60				rts
   414
   415 3392			bTR_LoopRandomTitle
   416 3392 AD 0A D2			lda RANDOM
   417 3395 3D C2 48			and TITLE_GFX,x
   418 3398 9D 40 48			sta TITLE_LEFT,x
   419 339B AD 0A D2			lda RANDOM
   420 339E 3D CC 48			and TITLE_GFX+10,x
   421 33A1 9D 54 48			sta TITLE_LEFT+20,x
   422 33A4 AD 0A D2			lda RANDOM
   423 33A7 3D D6 48			and TITLE_GFX+20,x
   424 33AA 9D 68 48			sta TITLE_LEFT+40,x
   425 33AD AD 0A D2			lda RANDOM
   426 33B0 3D E0 48			and TITLE_GFX+30,x
   427 33B3 9D 7C 48			sta TITLE_LEFT+60,x
   428 33B6 AD 0A D2			lda RANDOM
   429 33B9 3D EA 48			and TITLE_GFX+40,x
   430 33BC 9D 90 48			sta TITLE_LEFT+80,x
   431 33BF AD 0A D2			lda RANDOM
   432 33C2 3D F4 48			and TITLE_GFX+50,x
   433 33C5 9D A4 48			sta TITLE_LEFT+100,x
   434 33C8 CA				dex
   435 33C9 10 C7			bpl bTR_LoopRandomTitle
   436
   437 33CB 60				rts
   438
   439
   440 				; ==========================================================================
   441 				; FADE TITLE UNDERLINES
   442 				; ==========================================================================
   443 				; Table lookup from a list of colors and assign to the underline pixels 
   444 				; on the title screen.  This is used to transition from the PET FROGGER 
   445 				; title to the OPTION/SELECT text as the text produced for feedback will 
   446 				; NOT line up with the regular title's underlines.
   447 				;
   448 				; We got here in one of 2 ways:
   449 				; 1) From Title Logo being displayed (with green underlines)
   450 				; 2) From a SELECT/OPTION choice where the underlines are 
   451 				;    already faded to match the yellow background.
   452 				; Therefore, fade the green underlines to yellow only when 
   453 				; they are not already faded out.  (Extra comparison up front.)
   454 				;
   455 				; X is the counter to use for fetching a new color from the table.
   456 				; --------------------------------------------------------------------------
   457
   458 33CC			FadeTitleUnderlines
   459
   460 33CC AD BE 50			lda COLPF0_TABLE+9          ; Get current underline color.
   461 33CF CD 34 4E			cmp TITLE_UNDERLINE_FADE    ; Is it already the target color (from the fading table)?
   462 33D2 F0 06			beq bFTU_End                ; Already faded to yellow, do nothing.
   463
   464 33D4 BD 34 4E			lda TITLE_UNDERLINE_FADE,x  ; Get the new color based on the counter (6, 5, 4, 3, 2, 1 0.)
   465 33D7 8D BE 50			sta COLPF0_TABLE+9          ; Update underlines color.
   466
   467 33DA			bFTU_End
   468 33DA 60				rts
   469
   470
   471 				; ==========================================================================
   472 				; COPY SCORE TO SCREEN                                                 A  X
   473 				; ==========================================================================
   474 				; Copy the score from memory to screen positions.
   475 				; --------------------------------------------------------------------------
   476 				; 1  |Score:00000000               00000000:Hi| SCORE_TXT
   477 				; 2  |Frogs:0    Frogs Saved:OOOOOOOOOOOOOOOOO| SCORE_TXT
   478 				; --------------------------------------------------------------------------
   479 				; Game Score and High Score.
   480 				; This stays here and is copied to screen memory, because the math could
   481 				; temporarily generate a non-numeric character when there is carry, and I
   482 				; don't want that (possibly) visible on the screen however short it may be.
   483 				; Also, we have run out of adequate page 0 space, so these need to be 
   484 				; declared here, or wherever else, doesn't matter... unless someone decides
   485 				; to put this in a ROM card and then this is a problem.  In that case 
   486 				; there are a lot of things that have to change about screen memory and 
   487 				; other lists. 
   488 				; --------------------------------------------------------------------------
   489
   490 33DB 10 10 10 10 10 10 + MyScore .sb "00000000"
   491 33E3 10 10 10 10 10 10 + HiScore .sb "00000000"
   492
   493 33EB			CopyScoreToScreen
   494
   495 33EB A2 07			ldx #7
   496 33ED			DoUpdateScreenScore
   497 33ED BD DB 33			lda MyScore,x           ; Read from Score buffer
   498 33F0 9D 06 4C			sta SCREEN_MYSCORE,x
   499 33F3 BD E3 33			lda HiScore,x           ; Read from Hi Score buffer
   500 33F6 9D 1A 4C			sta SCREEN_HISCORE,x
   501 33F9 CA				dex                     ; Loop 8 bytes - 7 to 0.
   502 33FA 10 F1			bpl DoUpdateScreenScore
   503
   504 33FC 60				rts
   505
   506
   507 				; ==========================================================================
   508 				; CLEAR SAVED FROGS
   509 				; ==========================================================================
   510 				; Remove the number of saved frogs from the screen, for start of game.
   511 				; And...
   512 				; Clears Number of frogs crossed the rivers.
   513 				; Determine new starting level.
   514 				; Set the speed/level difficulty.
   515 				;
   516 				; 1  |0000000:Score                 Hi:0000000| SCORE_TXT
   517 				; 2  |Frogs:0    Frogs Saved:OOOOOOOOOOOOOOOOO| SCORE_TXT
   518 				; --------------------------------------------------------------------------
   519
   520 33FD			ClearSavedFrogs
   521
   522 33FD A9 00			lda #INTERNAL_SPACE       ; Blank space. which also happens to be 0.
   523
   524 33FF A2 14			ldx #20
   525 3401			RemoveFroggies
   526 3401 9D 35 4C			sta SCREEN_SAVED-1,x      ; Write to screen 
   527 3404 CA				dex                       ; Erase county-counter frog character
   528 3405 D0 FA			bne RemoveFroggies        ; then go back and remove the next frog counter.
   529
   530 3407 85 8A			sta FrogsCrossed          ; reset count to 0.  (Remember A == space == 0 ?)
   531
   532 3409 20 50 24			jsr MultiplyFrogsCrossed ; Multiply by 18, make index base, set difficulty address pointers.
   533
   534 340C 20 AB 34			jsr StrobeSavedLabel     ; Glow the Saved label.  VBI will decrement it.
   535
   536 340F 60				rts
   537
   538
   539 				; ==========================================================================
   540 				; PRINT FROGS AND LIVES
   541 				; ==========================================================================
   542 				; Display the number of frogs that crossed the river and lives.
   543 				; There are two different character patterns that represent a frog 
   544 				; head used to indicate number of saved frogs. del/$7e and tab/$7f.
   545 				; These are alternated in the line, to make the 8-bit wide image 
   546 				; patterns discernible.  (The same image repeated looks a mess.)
   547 				; ==========================================================================
   548 				; 1  |0000000:Score                 Hi:0000000| SCORE_TXT
   549 				; 2  |Frogs:0    Frogs Saved:OOOOOOOOOOOOOOOOO| SCORE_TXT
   550 				; --------------------------------------------------------------------------
   551 				; New:
   552 				; 1  |Score:0000000                 0000000:Hi| SCORE_TXT
   553 				; 2  |Frogs:ooo     OOOOOOOOOOOOOOOOOOOO:Saved| SCORE_TXT
   554 				; --------------------------------------------------------------------------
   555
   556 3410			PrintFrogsAndLives
   557
   558 3410 A6 8A			ldx FrogsCrossed     ; Number of times successfully crossed the rivers.
   559 3412 F0 1A			beq WriteLives       ; then nothing to display. Skip to do lives. 
   560
   561 3414 A0 14			ldy #20              ; Start printing right to left from end of field.
   562
   563 3416 E0 15			cpx #21              ; Limit saved frogs to the remaining width of screen
   564 3418 90 02			bcc SavedFroggies
   565
   566 341A A2 14			ldx #20
   567
   568 341C			SavedFroggies            ; Write an alternating pattern of Frog1, Frog2 characters.
   569 341C A9 7E			lda #I_FROG1         ; On Atari we're using tab/$7f as a frog shape.
   570 341E 99 35 4C			sta SCREEN_SAVED-1,y ; Write to screen. 
   571 3421 88				dey
   572 3422 CA				dex                  ; Decrement number of frogs.
   573 3423 F0 09			beq WriteLives       ; Reached 0, stop adding frogs.
   574 3425 A9 7F			lda #I_FROG2         ; On Atari we're using del/$7e as a frog shape.
   575 3427 99 35 4C			sta SCREEN_SAVED-1,y ; Write to screen. 
   576 342A 88				dey
   577 342B CA				dex                  ; Decrement number of frogs.
   578 342C D0 EE			bne SavedFroggies    ; then go back and display the next frog counter.
   579
   580 				; Erase Frog Life icons from screen.
   581 				; Redraw the number of Frog icons per the value of NumberOfLives.
   582 342E			WriteLives
   583 342E 20 39 34			jsr EraseFrogLives
   584
   585 3431 A6 8E			ldx NumberOfLives         ; Get number of lives in X
   586 3433 F0 03			beq EndPrintFrogsAndLives ; No lives.  End here.
   587
   588 3435 20 44 34			jsr RedrawFrogLives
   589
   590 3438			EndPrintFrogsAndLives
   591 3438 60				rts
   592
   593
   594 				; ==========================================================================
   595 				; ERASE FROG LIVES
   596 				; ==========================================================================
   597 				; Support function.  
   598 				; Remove current list of frog lives from screen.
   599 				; Subroutine, because it could be called from multiple places.
   600 				; --------------------------------------------------------------------------
   601
   602 3439			EraseFrogLives
   603
   604 3439 A9 00			lda #INTERNAL_SPACE
   605
   606 343B A0 07			ldy #7
   607 343D			bPFAL_EraseFrogs          ; Remove 7 frogs from screen
   608 343D 99 2D 4C			sta SCREEN_LIVES-1,y 
   609 3440 88				dey
   610 3441 D0 FA			bne bPFAL_EraseFrogs
   611
   612 3443 60				rts
   613
   614
   615 				; ==========================================================================
   616 				; REDRAW FROG LIVES                                                    X
   617 				; ==========================================================================
   618 				; Support function.  
   619 				; Remove current list of frog lives from screen.
   620 				; Subroutine, because it could be called from multiple places.
   621 				; The value of the X register gives the number of Frog Life 
   622 				; characters to draw. 
   623 				; The caller should not use this routine if the value is 0.
   624 				; This expects that EraseFrogLives was called before this.
   625 				; --------------------------------------------------------------------------
   626
   627 3444			RedrawFrogLives
   628
   629 3444 A0 00			ldy #0
   630
   631 3446			bRFL_WriteLives
   632 3446 A9 7E			lda #I_FROG1        ; On Atari we're using tab/$7f as a frog shape.
   633 3448 99 2E 4C			sta SCREEN_LIVES,y  ; Write to screen. 
   634 344B C8				iny
   635 344C CA				dex                 ; Decrement number of frogs.
   636 344D F0 E9			beq EndPrintFrogsAndLives ; Reached 0, stop adding frogs.
   637
   638 344F A9 7F			lda #I_FROG2        ; On Atari we're using del/$7e as a frog shape.
   639 3451 99 2E 4C			sta SCREEN_LIVES,y  ; Write to screen. 
   640 3454 C8				iny
   641 3455 CA				dex                 ; Decrement number of frogs.
   642 3456 D0 EE			bne bRFL_WriteLives  ; then go back and display the next number of frogs.
   643
   644 3458			EndRedrawFrogLives
   645 3458 60				rts
   646
   647
   648 				; ==========================================================================
   649 				; WRITE NEW LIVES 
   650 				; ==========================================================================
   651 				; Support function.  
   652 				; When SELECT is pressed it updates NewNumberOfLives.
   653 				; Erase Frog Life icons from screen.
   654 				; Redraw the number of Frog icons per the value of NewNumberOfLives.
   655 				; --------------------------------------------------------------------------
   656
   657 3459			WriteNewLives
   658
   659 3459 20 39 34			jsr EraseFrogLives
   660
   661 345C A6 8F			ldx NewNumberOfLives   ; Get new number of lives in X
   662 345E F0 03			beq EndWriteNewLives
   663
   664 3460 20 44 34			jsr RedrawFrogLives
   665
   666 3463			EndWriteNewLives
   667 3463 60				rts
   668
   669
   670 				; ==========================================================================
   671 				; CHANGE SCREEN                                                     A (Y)
   672 				; ==========================================================================
   673 				; Set a new display.
   674 				;
   675 				; 1. The Press Any Key Prompt is always disabled on the start of any screen.
   676 				; 2. Tell the VBI the screen ID.
   677 				; 3. Wait for the VBI to change the current display and update the
   678 				; 4. other pointers to the color tables.
   679 				; 5. Copy the color tables to the current lookups.
   680 				;
   681 				; A  is the DISPLAY_* value (defined elsewhere) for the desired display.
   682 				; Y  is used to turn off the Press A Button Prompt, and loop through 
   683 				;    the color tables.
   684 				; --------------------------------------------------------------------------
   685
   686 3464			ChangeScreen
   687
   688 3464 85 FD			sta SAVEA
   689 3466 85 B4			sta VBICurrentDL                  ; Tell VBI to change to new display mode.
   690
   691 3468				mRegSaveAYX                       ; Save A, X, and Y.
Macro: MREGSAVEAYX [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/macros.asm]
     1 3468 48				PHA 
     2 3469 98				TYA 
     3 346A 48				PHA 
     4 346B 8A				TXA 
     5 346C 48				PHA 
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03ScreenGfx.asm
   692
   693 346D 20 AE 3A			jsr HideButtonPrompt              ; Always tell the VBI to stop the prompt.
   694
   695 					; While waiting for the VBI to do its part, lets do something useful.
   696 					; Display Win, Display Dead and Display Game Over are the same display lists.  
   697 					; The only difference is the LMS to point to the big text.
   698 					; So, reassign that here.
   699
   700 3470 A4 FD			ldy SAVEA                         ; Get the desired display number back.
   701 3472 B9 0A 50			lda DISPLAYLIST_GFXLMS_TABLE,y    ; Get the new address.
   702 3475 8D CD 46			sta GFX_LMS                       ; Save in the Win/Dead/Over display list.
   703
   704 					; ALSO, the Game screen needs the mask borders on the left and right sides
   705 					; of the screen.   Determine if we need to do it or not do it and then
   706 					; draw or erase the borders accordingly.
   707
   708 3478 B9 1E 50			lda DISPLAY_NEEDS_BORDERS_TABLE,y ; Does this display need the P/M graphics borders? 
   709 347B F0 06			beq bCSNoBorders                  ; If it is 0 it is not needed.  Erase it this.
   710 347D 20 55 3D			jsr DrawGameBorder                ; Game screen needs left and right sides masked.
   711 3480 4C 86 34			jmp bCSContinueUpdate
   712
   713 3483			bCSNoBorders
   714 3483 20 C7 3C			jsr EraseGameBorder
   715
   716 					; Back to checking on what the VBI has accomplished...
   717 3486			bCSContinueUpdate
   718 3486 A5 FD			lda SAVEA                         ; Get the desired display number back.
   719
   720 3488			LoopChangeScreenWaitForVBI            ; Wait for VBI to signal the values changed.
   721 3488 C5 B4			cmp VBICurrentDL                  ; Is the DISPLAY value the same?
   722 348A F0 FC			beq LoopChangeScreenWaitForVBI    ; Yes. Keep looping.
   723
   724 					; The VBI has changed the display and loaded page zero pointers.
   725 348C A8				tay
   726 348D 20 64 36			jsr CopyBaseColors    ; Now update the DLI color tables.
   727
   728 3490 20 FE 3B			jsr CopyPMGBase       ; And update the base player/missile data.
   729
   730 3493				mRegRestoreAYX       ; Restore Y, X, and A
Macro: MREGRESTOREAYX [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/macros.asm]
     1 3493 68				PLA 
     2 3494 AA				TAX 
     3 3495 68				PLA 
     4 3496 A8				TAY 
     5 3497 68				PLA 
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03ScreenGfx.asm
   731
   732 3498 60				rts
   733
   734
   735 				; ==========================================================================
   736 				; C O L O R   T A B L E S
   737 				; ==========================================================================
   738
   739 				; ==========================================================================
   740 				; STROBE SCORE LABEL                                                
   741 				; ==========================================================================
   742 				; Set the P/M graphics colors for the Score label to the brightest value.
   743 				; The VBI will decrement this until it is back to normal.
   744 				; --------------------------------------------------------------------------
   745
   746 3499			StrobeScoreLabel
   747
   748 3499 A9 8F			lda #COLOR_BLUE2+$F
   749 349B 8D 8E 51			sta COLPM0_TABLE
   750 349E 8D 91 51			sta COLPM1_TABLE
   751
   752 34A1 60				rts
   753
   754
   755 				; ==========================================================================
   756 				; STROBE LIVES LABEL                                                
   757 				; ==========================================================================
   758 				; Set the P/M graphics colors for the Lives label to the brightest value.
   759 				; The VBI will decrement this until it is back to normal.
   760 				; --------------------------------------------------------------------------
   761
   762 34A2			StrobeLivesLabel
   763
   764 34A2 A9 5F			lda #COLOR_PURPLE+$F
   765 34A4 8D 8F 51			sta COLPM0_TABLE+1
   766 34A7 8D 92 51			sta COLPM1_TABLE+1
   767
   768 34AA 60				rts
   769
   770
   771 				; ==========================================================================
   772 				; STROBE SAVED LABEL                                                
   773 				; ==========================================================================
   774 				; Set the P/M graphics colors for the Saved frogs label to the brightest 
   775 				; value. The VBI will decrement this until it is back to normal.
   776 				; --------------------------------------------------------------------------
   777
   778 34AB			StrobeSavedLabel
   779
   780 34AB A9 CF			lda #COLOR_GREEN+$F
   781 34AD 8D 95 51			sta COLPM2_TABLE+1      ; S a - - d
   782 34B0 8D 98 51			sta COLPM3_TABLE+1      ; - - v e d
   783
   784 34B3 60				rts
   785
   786
   787 				; ==========================================================================
   788 				; STROBE HI SCORE LABEL                                                
   789 				; ==========================================================================
   790 				; Set the P/M graphics colors for the Hi Score label to the brightest value.
   791 				; The VBI will decrement this until it is back to normal.
   792 				; --------------------------------------------------------------------------
   793
   794 34B4			StrobeHiScoreLabel
   795
   796 34B4 A9 4F			lda #COLOR_PINK+$F
   797 34B6 8D 94 51			sta COLPM2_TABLE
   798
   799 34B9 60				rts
   800
   801
   802 				; ==========================================================================
   803 				; ZERO CURRENT COLORS                                                 A  Y
   804 				; ==========================================================================
   805 				; Force all the colors in the current tables to black.
   806 				; Used to insure black screen BEFORE  fading up the Game screen.
   807 				; Note that we do not want to zero colors for the status lines 
   808 				; on the Game screen.
   809 				; --------------------------------------------------------------------------
   810
   811 34BA			ZeroCurrentColors
   812
   813 34BA A0 15			ldy #21  
   814
   815 34BC			LoopZeroColors
   816 34BC A9 00			lda #0
   817 34BE 20 1E 35			jsr NukeAllColorsFromOrbitToBeSure ; Sets all colors.  Decrements Y.
   818
   819 34C1 A5 B5			lda CurrentDL
   820 34C3 C9 01			cmp #DISPLAY_GAME
   821 34C5 D0 06			bne bZCC_CheckZero
   822 34C7 C0 02			cpy #2
   823 34C9 F0 08			beq ExitZeroCurrentColors
   824 34CB D0 EF			bne LoopZeroColors
   825
   826 34CD			bZCC_CheckZero
   827 34CD C0 FF			cpy #$FF
   828 34CF F0 02			beq ExitZeroCurrentColors
   829 34D1 D0 E9			bne LoopZeroColors
   830
   831 34D3			ExitZeroCurrentColors
   832 34D3 20 AE 3A			jsr HideButtonPrompt
   833
   834 34D6 60				rts
   835
   836
   837 				; ==========================================================================
   838 				; FLIP OFF EVERYTHING (MATCHING)                                   A  Y  X
   839 				; ==========================================================================
   840 				; Turn off a bit in the value keeping track of multiple bits 
   841 				; indicating which values match or do not match.
   842 				;
   843 				; Exit with 0 flag.
   844 				;
   845 				; Uses Page 0 value: EverythingMatches
   846 				;
   847 				; A  is the mask to apply to the tracking bits.
   848 				; --------------------------------------------------------------------------
   849
   850 34D7			FlipOffEverything
   851
   852 34D7 25 A2			and EverythingMatches
   853 34D9 85 A2			sta EverythingMatches    ; Save the finished flag.  
   854 34DB A9 00			lda #0                   ; So the caller can BEQ
   855 34DD 60				rts
   856
   857
   858 				; ==========================================================================
   859 				; DEAD FROG RAIN                                                A  Y  X
   860 				; ==========================================================================
   861 				; Dark to light color scroller, moving down the screen.  
   862 				; Apply to only the background lines above and below the text.
   863 				;
   864 				; Uses EventCounter as the current base color.
   865 				; 
   866 				; Stopping this is under the caller's control (button pressed, then 
   867 				; move on to a different animation stage.)
   868 				; --------------------------------------------------------------------------
   869
   870 34DE			DeadFrogRain
   871
   872 34DE C6 9C			dec EventCounter            ; Increment base color 
   873 34E0 C6 9C			dec EventCounter            ; Twice.  (need to use even numbers.)
   874 34E2 A5 9C			lda EventCounter            ; Get value 
   875 34E4 29 0F			and #$0F                    ; Keep this truncated to grey (black) $0 to $F
   876 34E6 85 9C			sta EventCounter            ; Save it for next time.
   877
   878 34E8 A0 02			ldy #2 ; Top 20 lines of screen...
   879 34EA			DeadLoopTopOverGrey
   880 34EA 20 98 36			jsr DeadFrogGreyScroll      ; Increments and color stuffing.
   881 34ED C0 15			cpy #21                     ; Reached the big text lines?
   882 34EF D0 F9			bne DeadLoopTopOverGrey     ; No, continue looping.
   883
   884 34F1 A0 1D			ldy #29 ; Bottom 20 lines of screen (above prompt and credits.)
   885 34F3			DeadLoopBottomOverGrey
   886 34F3 20 98 36			jsr DeadFrogGreyScroll      ; Increments and color stuffing.
   887 34F6 C0 30			cpy #48                     ; Reached the last line?
   888 34F8 D0 F9			bne DeadLoopBottomOverGrey  ; No, continue looping.
   889
   890 34FA 60				rts
   891
   892
   893 				; ==========================================================================
   894 				; BLACK SPLASH BACKGROUND                                           A  Y  
   895 				; ==========================================================================
   896 				; For the Splash screens, set the background above the big splash text 
   897 				; and below the text to black.  No gradual fading.
   898 				;
   899 				; On switching to the game screen from a splash screen there is 
   900 				; sometimes flashing of the score line.  This was because splash 
   901 				; screens were not using COLPF1, but the values were still present 
   902 				; from the game and were visible for a moment when the display changes
   903 				; back to the game.  So, for the sake of mental cleanliness the program 
   904 				; nukes the entire set of colors from orbit. Its the only way to be sure.
   905 				;
   906 				; Only on the game over screen also do lines 21 to 26 for the text.
   907 				; --------------------------------------------------------------------------
   908
   909 34FB			BlackSplashBackground
   910
   911 34FB A9 00			lda #COLOR_BLACK
   912
   913 34FD A0 15			ldy #21 ; Top 20 lines of screen...
   914 34FF			SplashLoopTopToBlack                   ; Filling the top
   915 34FF 20 1E 35			jsr NukeAllColorsFromOrbitToBeSure ; Also decrements Y
   916 3502 D0 FB			bne SplashLoopTopToBlack           ; Continue looping.  Ends at 0.
   917
   918 3504 A6 B5			ldx CurrentDL                      ; Only the Game Over display clears the middle.
   919 3506 E0 04			cpx #DISPLAY_OVER                  ; Is it game over?
   920 3508 D0 0A			bne ContinueSplashBottomToBlack    ; Nope.  Skip to the bottom
   921
   922 350A A0 1B			ldy #27 ; Middle six lines of the text background. 
   923 350C			SplashLoopMidToBlack
   924 350C 99 84 50			sta COLBK_TABLE,y ; only background, because we need to fade text later.
   925 350F 88				dey
   926 3510 C0 15			cpy #21                            ; Filling the middle
   927 3512 D0 F8			bne SplashLoopMidToBlack           ; No, continue looping.
   928
   929 3514			ContinueSplashBottomToBlack
   930 3514 A0 2F			ldy #47 ; Bottom 20 lines of screen (above prompt and credits.
   931 3516			SplashLoopBottomToBlack
   932 3516 20 1E 35			jsr NukeAllColorsFromOrbitToBeSure ; Also decrements Y
   933
   934 3519 C0 1B			cpy #27                            ; Reached the last line?
   935 351B D0 F9			bne SplashLoopBottomToBlack        ; No, continue looping.
   936
   937 351D 60				rts
   938
   939
   940 				; ==========================================================================
   941 				; NUKE ALL COLORS FROM ORBIT TO BE SURE                               A  Y  
   942 				; ==========================================================================
   943 				; Support function for setting colors.
   944 				; Write the same value to a specific entry in all color tables.
   945 				; Typically, this will be black.
   946 				; The Game Over display needs to use white for COLPF3 instead of Black.
   947 				; Then decrement the Y index.
   948 				;
   949 				; A = the color value to use.
   950 				; Y = the index into the color tables.
   951 				; --------------------------------------------------------------------------
   952
   953 351E			NukeAllColorsFromOrbitToBeSure
   954
   955 351E 99 84 50			sta COLBK_TABLE,y     ; Zero Background
   956 3521 99 B5 50			sta COLPF0_TABLE,y    ; Zero pixel (or text)
   957 3524 99 E6 50			sta COLPF1_TABLE,y    ; Zero text
   958 3527 99 17 51			sta COLPF2_TABLE,y    ; Zero something else
   959
   960 352A 48				pha                   ; Save the color we're using. (originally Black).
   961
   962 352B A6 B5			ldx CurrentDL
   963 352D E0 04			cpx #DISPLAY_OVER
   964 352F D0 02			bne DoNotUseWhite     ; Not the Game Over display. Use original (Black).
   965 3531 A9 0E			lda #COLOR_BLACK+$0e  ; Over display uses White instead.
   966
   967 3533			DoNotUseWhite
   968 3533 99 48 51			sta COLPF3_TABLE,y    ; Zero this too
   969
   970 3536 68				pla                   ; Get the color we're using.
   971
   972 3537 88				dey                   ; Decrement row counter.
   973
   974 3538 60				rts
   975
   976
   977 				; ==========================================================================
   978 				; FADE SPLASH TEXT BACKGROUND                                      A  X
   979 				; ==========================================================================
   980 				; For the Splash screens, fade the background of the text to black. 
   981 				; If the current line's luminance matches the reference value, then 
   982 				; decrement it.
   983 				; At the end, decrement the reference value. 
   984 				; When the reference value is 0, then set all to black. 
   985 				; Gradual fade on each pass.
   986 				;
   987 				; Uses EventCounter for the reference luminance.  must start at $0E
   988 				;
   989 				; Returns flags based on Event counter.  BMI means fade finished.
   990 				; --------------------------------------------------------------------------
   991
   992 3539			FadeSplashTextBackground
   993
   994 3539 A2 16			ldx #22                         ; Text lines 22 to 27 ...
   995 353B			bFSTB_LoopTextBackFade
   996 353B BD 84 50			lda COLBK_TABLE,x               ; Get the color
   997 353E 29 0F			and #$0F                        ; Mask out color. Keep only the luminance.
   998 3540 C5 9C			cmp EventCounter                ; Compare to target luminance
   999 3542 D0 06			bne bFSTB_LoopTextBackInc       ; not the same, so skip it.
  1000 3544 DE 84 50			dec COLBK_TABLE,x               ; The same.  Decrement luminance
  1001 3547 DE 84 50			dec COLBK_TABLE,x               ; Decrement luminance again.
  1002
  1003 354A			bFSTB_LoopTextBackInc
  1004 354A E8				inx                             ; Go to the next line
  1005 354B E0 1C			cpx #28                         ; There yet?
  1006 354D D0 EC			bne bFSTB_LoopTextBackFade      ; No, continue looping.
  1007
  1008 354F C6 9C			dec EventCounter                ; Reduce target luminance,
  1009 3551 C6 9C			dec EventCounter                ; and again.
  1010 3553 10 0E			bpl EndFadeSplashTextBackground ; 0 is legit.  Only finish here on negative something.
  1011
  1012 					; Now that luminance for all is 0, force all to black.
  1013 3555 A9 00			lda #COLOR_BLACK
  1014 3557 A2 16			ldx #22                         ; Text lines 22 to 27 ...
  1015 3559			bFSTB_LoopTextBackToBlack
  1016 3559 9D 84 50			sta COLBK_TABLE,x               ; Zero/black it.
  1017 355C E8				inx
  1018 355D E0 1C			cpx #28  
  1019 355F D0 F8			bne bFSTB_LoopTextBackToBlack   ; do while more rows to black out.
  1020
  1021 3561 A9 FF			lda #$FF                        ; Let the caller know - Really, really done.
  1022
  1023 3563			EndFadeSplashTextBackground
  1024
  1025 3563 60				rts
  1026
  1027
  1028 				; ==========================================================================
  1029 				; FADE SPLASH TEXT                                                  A  X
  1030 				; ==========================================================================
  1031 				; For the Splash screens, fade the text to black. 
  1032 				; The same basic operations as FadeSplashTextBackground above, but this is
  1033 				; for COLPF0 instead of COLBK.
  1034 				; If the current line's luminance matches the reference value, then 
  1035 				; decrement it.
  1036 				; At the end, decrement the reference value. 
  1037 				; when the reference value is 0, then set all to black. 
  1038 				; Gradual fade on each pass.
  1039 				;
  1040 				; Uses EventCounter for the reference luminance.  must start at $0E
  1041 				;
  1042 				; Returns flags based on Event counter.  BMI means fade finished.
  1043 				; --------------------------------------------------------------------------
  1044
  1045 3564			FadeSplashText
  1046
  1047 3564 A2 16			ldx #22                         ; Text lines 22 to 27 ...
  1048 3566			bFST_LoopTextFade
  1049 3566 BD B5 50			lda COLPF0_TABLE,x              ; Get the color
  1050 3569 29 0F			and #$0F                        ; Mask out color.  Keep the luminance.
  1051 356B C5 9C			cmp EventCounter                ; Compare to target luminance
  1052 356D D0 06			bne bFST_LoopTextInc            ; Not the same, so skip it.
  1053 356F DE B5 50			dec COLPF0_TABLE,x              ; The same luma, so decrement it.
  1054 3572 DE B5 50			dec COLPF0_TABLE,x              ; Decrement again.
  1055
  1056 3575			bFST_LoopTextInc
  1057 3575 E8				inx                             ; Go to the next line.
  1058 3576 E0 1C			cpx #28                         ; Reached the end?
  1059 3578 D0 EC			bne bFST_LoopTextFade           ; No, continue looping.
  1060
  1061 357A C6 9C			dec EventCounter                ; Reduce target luminance,
  1062 357C C6 9C			dec EventCounter                ; and again.
  1063 357E 10 0E			bpl EndFadeSplashText
  1064
  1065 					; Now that luminance are 0, then force all to black.
  1066 3580 A9 00			lda #COLOR_BLACK
  1067 3582 A2 16			ldx #22                         ; Text lines 22 to 27 ...
  1068 3584			bFST_LoopTextToBlack
  1069 3584 9D B5 50			sta COLPF0_TABLE,x              ; Zero/black it.
  1070 3587 E8				inx
  1071 3588 E0 1C			cpx #28  
  1072 358A D0 F8			bne bFST_LoopTextToBlack        ; Do while more rows to black out.
  1073
  1074 358C A9 FF			lda #$FF                        ; Let the caller know - Really, really done.
  1075
  1076 358E			EndFadeSplashText
  1077 358E 60				rts
  1078
  1079
  1080 				; ==========================================================================
  1081 				; COMMON SPLASH FADE 123                                           
  1082 				; ==========================================================================
  1083 				; One set of code to run Stage 1, 2, 3, screen fade results.
  1084 				; 1) Black background for scrolling colors in one pass.
  1085 				; 2) Fade background colors behind text until it reaches 0.
  1086 				; 3) Fade text colors to black.
  1087 				;
  1088 				; Expectations:
  1089 				;;; EventCounter is initialized to $E0 before calling this.
  1090 				; EventStage is initialized to 1 to start the first stage.
  1091 				; The caller is expected to have a use for EventStage = 4 
  1092 				; (i.e to stop calling this part.) 
  1093 				;
  1094 				; The Game Over screen bypasses stage 2 as it finishes blacking its 
  1095 				; background during Stage 1.
  1096 				; --------------------------------------------------------------------------
  1097
  1098 358F			CommonSplashFade
  1099
  1100 358F A5 9B			lda EventStage
  1101
  1102 				;SplashStageOne                    ; Stage 1 is set background black.             
  1103 3591 C9 01			cmp #1
  1104 3593 D0 13			bne SplashStageTwo
  1105
  1106 3595 20 FB 34			jsr BlackSplashBackground     ; Set non-text background to black.
  1107
  1108 3598 A9 0E			lda #$0e
  1109 359A 85 9C			sta EventCounter              ; Luminance matching for fade
  1110 359C E6 9B			inc EventStage                ; Set Stage = 2
  1111
  1112 359E A6 B5			ldx CurrentDL                 ; The Game Over Display already cleared the entire background
  1113 35A0 E0 04			cpx #DISPLAY_OVER             ; Is it Game Over? (and stage 2 is not needed?)
  1114 35A2 D0 20			bne EndCommonSplashFade       ; No. End with Stage 2 as current stage
  1115 35A4 E6 9B			inc EventStage                ; Set Stage = 3
  1116
  1117 35A6 D0 1C			bne EndCommonSplashFade
  1118
  1119
  1120 35A8			SplashStageTwo                    ; Stage 2 is fading the text background
  1121 35A8 C9 02			cmp #2
  1122 35AA D0 0D			bne SplashStageThree          ; Not Stage 2.
  1123
  1124 35AC 20 39 35			jsr FadeSplashTextBackground  ; Like it says, Fade Splash Text Background
  1125 35AF 10 13			bpl EndCommonSplashFade       ; Not negative return means we're done for this pass.
  1126
  1127 35B1 A9 0E			lda #$0e                      ; Negative return.
  1128 35B3 85 9C			sta EventCounter              ; Luminance matching for fade
  1129 35B5 E6 9B			inc EventStage                ; Set Stage = 3
  1130
  1131 35B7 D0 0B			bne EndCommonSplashFade
  1132
  1133
  1134 35B9			SplashStageThree                  ; Stage 3 is fading the text 
  1135 35B9 C9 03			cmp #3
  1136 35BB D0 07			bne EndCommonSplashFade       ; Not stage 3.  So why did the caller call this?
  1137
  1138 35BD 20 64 35			jsr FadeSplashText            ; Like it says, Fade Splash Text 
  1139 35C0 10 02			bpl EndCommonSplashFade       ; Not negative return means we're done for this pass.
  1140
  1141 35C2 E6 9B			inc EventStage                ; Negative return.  Set Stage = 4
  1142
  1143
  1144 35C4			EndCommonSplashFade
  1145 35C4 A5 9B			lda EventStage                ; Make sure A = EventStage on exit.
  1146
  1147 35C6 60				rts
  1148
  1149
  1150 				; ==========================================================================
  1151 				; INCREMENT GAME COLOR                                            A  Y  X
  1152 				; ==========================================================================
  1153 				; Merge the current luminance to the target color.
  1154 				; Increment the current luminance.
  1155 				;
  1156 				; Inputs:
  1157 				; A = target color
  1158 				; Y = current color.
  1159 				;
  1160 				; Uses Page 0 locations: TempSaveColor, TempTargetColor
  1161 				;
  1162 				; Output:
  1163 				; A = New current color.
  1164 				; --------------------------------------------------------------------------
  1165
  1166 				; Such sloppiness....  gah!
  1167 35C7			IncrementGameColor      ; Y = current color.   A = target color
  1168
  1169 35C7 85 A1			sta TempTargetColor
  1170 35C9 29 F0			and #$F0            ; Extract target color part (to be joined to current luminance)
  1171 35CB 85 A0			sta TempSaveColor   ; Keep color
  1172 35CD 98				tya                 ; A = Current color from Y.
  1173 35CE 29 0F			and #$0F            ; Extract current luminance.
  1174 35D0 05 A0			ora TempSaveColor   ; Join current luminance to target color for new current base color.
  1175 35D2 C5 A1			cmp TempTargetColor ; Is the new save color already the same as the target?
  1176 35D4 F0 04			beq SkipIncCurrent  ; Do not change the value. 
  1177 35D6 A8				tay                 ; Current color back to Y for increments
  1178 35D7 C8				iny
  1179 35D8 C8				iny
  1180 35D9 98				tya                 ; A = new current color.
  1181
  1182 35DA			SkipIncCurrent
  1183 35DA 60				rts
  1184
  1185
  1186 				; ==========================================================================
  1187 				; INCREMENT TABLE COLORS                                          A  Y  X
  1188 				; ==========================================================================
  1189 				; Increment color table luminance values until they reach target values.
  1190 				; Exit with 0 flag when all values are matching.
  1191 				;
  1192 				; I'm sure there's a smarter way to drive this off a list of data
  1193 				; and make this smaller code.
  1194 				;
  1195 				; Uses Page 0 value: EverythingMatches
  1196 				;
  1197 				; X  is the index into the tables. 
  1198 				; --------------------------------------------------------------------------
  1199
  1200 35DB			IncrementTableColors
  1201
  1202 35DB A9 1F			lda #%00011111       ; Flags indicate nothing matches yet.
  1203 35DD 85 A2			sta EverythingMatches
  1204
  1205 35DF			bDoTestCOLBK
  1206 35DF BD 84 50			lda COLBK_TABLE,x        ; Get the current color. 
  1207 35E2 DD 3B 4E			cmp GAME_BACK_COLORS,x   ; Is it the same as the Target color?
  1208 35E5 D0 07			bne bDoIncCOLBK          ; No.  Go inc the luminance.
  1209 35E7 A9 0F			lda #%00001111           ; Yes, turn off $10 .
  1210 35E9 20 D7 34			jsr FlipOffEverything    
  1211 35EC F0 0A			beq bDoTestCOLPF0        ; Do the next color.
  1212
  1213 35EE			bDoIncCOLBK
  1214 35EE A8				tay                      ; Y = current color
  1215 35EF BD 3B 4E			lda GAME_BACK_COLORS,x   ; A = target color
  1216 35F2 20 C7 35			jsr IncrementGameColor   ; Merge and increment color.
  1217 35F5 9D 84 50			sta COLBK_TABLE,x        ; Save the result.
  1218
  1219 35F8			bDoTestCOLPF0
  1220 35F8 BD B5 50			lda COLPF0_TABLE,x       ; Get the current color. 
  1221 35FB DD 51 4E			cmp GAME_COLPF0_COLORS,x ; Is it the same as the Target color?
  1222 35FE D0 07			bne bDoIncCOLPF0         ; No.  Go inc the luminance.
  1223 3600 A9 17			lda #%00010111           ; Yes, turn off $08 .
  1224 3602 20 D7 34			jsr FlipOffEverything    
  1225 3605 F0 0A			beq bDoTestCOLPF1        ; Do the next color.
  1226
  1227 3607			bDoIncCOLPF0
  1228 3607 A8				tay                      ; Y = current color
  1229 3608 BD 51 4E			lda GAME_COLPF0_COLORS,x ; A = target color
  1230 360B 20 C7 35			jsr IncrementGameColor   ; Merge and increment color.
  1231 360E 9D B5 50			sta COLPF0_TABLE,x       ; Save the result.
  1232
  1233 3611			bDoTestCOLPF1
  1234 3611 BD E6 50			lda COLPF1_TABLE,x       ; Get the current color. 
  1235 3614 DD 67 4E			cmp GAME_COLPF1_COLORS,x ; Is it the same as the Target color?
  1236 3617 D0 07			bne bDoIncCOLPF1         ; No.  Go inc the luminance.
  1237 3619 A9 1B			lda #%00011011           ; Yes, turn off $04.
  1238 361B 20 D7 34			jsr FlipOffEverything    
  1239 361E F0 0A			beq bDoTestCOLPF2        ; Do the next color.
  1240
  1241 3620			bDoIncCOLPF1
  1242 3620 A8				tay                      ; Y = current color
  1243 3621 BD 67 4E			lda GAME_COLPF1_COLORS,x ; A = target color
  1244 3624 20 C7 35			jsr IncrementGameColor   ; Merge and increment color.
  1245 3627 9D E6 50			sta COLPF1_TABLE,x       ; Save the result.
  1246
  1247 362A			bDoTestCOLPF2
  1248 362A BD 17 51			lda COLPF2_TABLE,x       ; Get the current color. 
  1249 362D DD 7D 4E			cmp GAME_COLPF2_COLORS,x ; Is it the same as the Target color?
  1250 3630 D0 07			bne bDoIncCOLPF2         ; No.  Go inc the luminance.
  1251 3632 A9 1D			lda #%00011101           ; Yes, turn off $02.
  1252 3634 20 D7 34			jsr FlipOffEverything    
  1253 3637 F0 0A			beq bDoTestCOLPF3  ; Done With Everything.
  1254
  1255 3639			bDoIncCOLPF2
  1256 3639 A8				tay                      ; Y = current color
  1257 363A BD 7D 4E			lda GAME_COLPF2_COLORS,x ; A = target color
  1258 363D 20 C7 35			jsr IncrementGameColor   ; Merge and increment color.
  1259 3640 9D 17 51			sta COLPF2_TABLE,x       ; Save the result.
  1260
  1261 3643			bDoTestCOLPF3
  1262 3643 BD 48 51			lda COLPF3_TABLE,x       ; Get the current color. 
  1263 3646 DD 93 4E			cmp GAME_COLPF3_COLORS,x ; Is it the same as the Target color?
  1264 3649 D0 07			bne bDoIncCOLPF3         ; No.  Go inc the luminance.
  1265 364B A9 1E			lda #%00011110           ; Yes, turn off $01.
  1266 364D 20 D7 34			jsr FlipOffEverything    
  1267 3650 F0 0A			beq bDoneWithEverything  ; Done With Everything.
  1268
  1269 3652			bDoIncCOLPF3
  1270 3652 A8				tay                      ; Y = current color
  1271 3653 BD 93 4E			lda GAME_COLPF3_COLORS,x ; A = target color
  1272 3656 20 C7 35			jsr IncrementGameColor   ; Merge and increment color.
  1273 3659 9D 48 51			sta COLPF3_TABLE,x       ; Save the result.
  1274
  1275 365C			bDoneWithEverything
  1276 365C A5 A2			lda EverythingMatches    ; If all flags are turned off the caller knows this row is done.
  1277
  1278 365E 60				rts
  1279
  1280
  1281 				; ==========================================================================
  1282 				; COPY BASE COLORS                                                    A Y
  1283 				; ==========================================================================
  1284 				; Copy the base colors for the current display.
  1285 				;
  1286 				; Base colors means the background, COLPF0 for pixels for Mode 9 graphics, 
  1287 				; and COLPF1 for text on Mode 2 text lines.
  1288 				;
  1289 				; Game screen uses all color registers and its setup is custom, so here
  1290 				; the colors are simply left black for the game screen.
  1291 				;
  1292 				; Y  =  is the DISPLAY_* value (defined elsewhere) for the desired display.
  1293 				; --------------------------------------------------------------------------
  1294
  1295 365F			COPY_BASE_SIZE_TABLE ; Starting point at end of table to copy. (Game screen is 0, for custom)
  1296 365F 19 00 2F 2F 2F		.by 25 0 47 47 47
  1297
  1298
  1299 3664			CopyBaseColors
  1300
  1301 3664 C0 05			cpy #MAX_DISPLAYS         ; 5.
  1302 3666 B0 2F			bcs EndCopyBaseColors     ; 5 or more is invalid display number. Exit.
  1303
  1304 3668 C0 01			cpy #DISPLAY_GAME         ; Is it the Game screen?
  1305 366A D0 03			bne bCBC_SkipGameScreen   ; Nope, do the usual (below).
  1306 366C 4C BA 34			jmp ZeroCurrentColors     ; Jmp instead of Jsr will return to the original caller
  1307
  1308 366F			bCBC_SkipGameScreen
  1309 366F B9 E6 52			lda COLOR_BACK_LO_TABLE,y ; Get Pointer to background colors
  1310 3672 85 A3			sta MainPointer1
  1311 3674 B9 EB 52			lda COLOR_BACK_HI_TABLE,y
  1312 3677 85 A4			sta MainPointer1+1
  1313 					
  1314 3679 B9 F0 52			lda COLOR_TEXT_LO_TABLE,y ; Get Pointer to "text"/foreground colors.
  1315 367C 85 A5			sta MainPointer2
  1316 367E B9 F5 52			lda COLOR_TEXT_HI_TABLE,y
  1317 3681 85 A6			sta MainPointer2+1
  1318
  1319 3683 B9 5F 36			lda COPY_BASE_SIZE_TABLE,y ; How many times to loop? 
  1320 3686 A8				tay                        ; Looping this many times...
  1321 				 
  1322 3687			bCBC_LoopCopyColors
  1323 3687 B1 A3			lda (MainPointer1),y       ; TITLE_BACK_COLORS,x
  1324 3689 99 84 50			sta COLBK_TABLE,y
  1325
  1326 368C B1 A5			lda (MainPointer2),y       ; TITLE_TEXT_COLORS,x
  1327 368E 99 E6 50			sta COLPF1_TABLE,y         ; Title screen has "text" using ANTIC Mode 2
  1328 3691 99 B5 50			sta COLPF0_TABLE,y         ; All displays use COLPF0 for pixel graphics colors.
  1329
  1330 3694 88				dey
  1331 3695 D0 F0			bne bCBC_LoopCopyColors   ; Do while more colors. (Note 0 entry is actually not needed, so not used.)
  1332
  1333 3697			EndCopyBaseColors
  1334 3697 60				rts                  
  1335
  1336
  1337 				; ==========================================================================
  1338 				; DEAD FROG GREY SCROLL
  1339 				; ==========================================================================
  1340 				; Redundant code section used for two separate loops in the Dead Frog event.
  1341 				;
  1342 				; Y = position in color table.
  1343 				; A = color to use and update
  1344 				; --------------------------------------------------------------------------
  1345
  1346 3698			DeadFrogGreyScroll
  1347
  1348 3698 99 84 50			sta COLBK_TABLE,y          ; Set line on screen
  1349 369B AA				tax                         ; X = A
  1350 369C E8				inx                         ; X = X + 1
  1351 369D E8				inx                         ; X = X + 1
  1352 369E 8A				txa                         ; A = X
  1353 369F 29 0F			and #$0F                    ; Keep this truncated to grey (black) $0 to $F
  1354 36A1 C8				iny                         ; Next line on screen.
  1355
  1356 36A2 60				rts
  1357
  1358
  1359 				; ==========================================================================
  1360 				; GAME OVER RED SINE
  1361 				; ==========================================================================
  1362 				; Game Over background color scroll.
  1363 				;
  1364 				; --------------------------------------------------------------------------
  1365
  1366 36A3			GameOverRedSine
  1367
  1368 36A3 A6 9C			ldx EventCounter         ; Get starting color index.
  1369 36A5 E8				inx                      ; Next index. 
  1370 36A6 E0 14			cpx #20                  ; Did index reach the repeat?
  1371 36A8 D0 02			bne SkipZeroOverCycle    ; Nope.
  1372 36AA A2 00			ldx #0                   ; Yes, restart at 0.
  1373 36AC			SkipZeroOverCycle
  1374 36AC 86 9C			stx EventCounter         ; And save for next time.
  1375
  1376 36AE A0 02			ldy #2 ; All the background lines on the screen
  1377 36B0			LoopTopOverSine
  1378 36B0 20 BE 36			jsr OverRedScroll        ; Increments and color stuffing.
  1379 36B3 E0 14			cpx #20
  1380 36B5 D0 02			bne SkipZeroOverCycle2
  1381 36B7 A2 00			ldx #0
  1382 36B9			SkipZeroOverCycle2
  1383 36B9 C0 30			cpy #48 ;                ; Reached the last line?
  1384 36BB D0 F3			bne LoopTopOverSine      ; No, continue looping.
  1385
  1386 36BD 60				rts
  1387
  1388
  1389 				; ==========================================================================
  1390 				; OVER RED SCROLL
  1391 				; ==========================================================================
  1392 				; Redundant code section used for two separate loops in the Dead Frog event.
  1393 				;
  1394 				; X == caller's current position in red sine table.
  1395 				; Y == caller's current line/row in the display's color table.
  1396 				; --------------------------------------------------------------------------
  1397
  1398 36BE			OverRedScroll
  1399
  1400 36BE BD C7 36			lda DEAD_COLOR_SINE_TABLE,x ; Get another color
  1401 36C1 99 84 50			sta COLBK_TABLE,y           ; Set line on screen
  1402 36C4 E8				inx                         ; Next color entry
  1403 36C5 C8				iny                         ; Next line on screen.
  1404
  1405 36C6 60				rts
  1406
  1407 36C7			DEAD_COLOR_SINE_TABLE ; 20 entries.
  1408 36C7 36 38 3A 3C			.byte COLOR_RED_ORANGE+6, COLOR_RED_ORANGE+8, COLOR_RED_ORANGE+10,COLOR_RED_ORANGE+12
  1409 36CB 3E 3E 3E 3C			.byte COLOR_RED_ORANGE+14,COLOR_RED_ORANGE+14,COLOR_RED_ORANGE+14,COLOR_RED_ORANGE+12
  1410 36CF 3A 38 36 34			.byte COLOR_RED_ORANGE+10,COLOR_RED_ORANGE+8, COLOR_RED_ORANGE+6, COLOR_RED_ORANGE+4
  1411 36D3 32 30 30 30			.byte COLOR_RED_ORANGE+2, COLOR_RED_ORANGE+0, COLOR_RED_ORANGE+0, COLOR_RED_ORANGE+0
  1412 36D7 30 30 32 34			.byte COLOR_RED_ORANGE+0, COLOR_RED_ORANGE+0, COLOR_RED_ORANGE+2, COLOR_RED_ORANGE+4
  1413
  1414
  1415 				; ==========================================================================
  1416 				; WIN COLOR SCROLL UP                                                   A
  1417 				; ==========================================================================
  1418 				; Support function.
  1419 				; Redundant code section used for two separate places in the Win event.
  1420 				; Subtract 4 from the current color.
  1421 				; Reset to 238 if the limit 14 (== 18-4) is reached.
  1422 				;
  1423 				; A  is the current color.   
  1424 				; --------------------------------------------------------------------------
  1425
  1426 36DB			WinColorScrollUp
  1427
  1428 36DB 38				sec
  1429 36DC E9 04			sbc #4                      ; Subtract 4
  1430 36DE C9 0E		 	cmp #14                     ; Did it pass the limit (minimum 18, minus 4 == 14)
  1431 36E0 D0 02			bne ExitWinColorScrollUp    ; No. We're done here.
  1432 36E2 A9 EE			lda #238                    ; Yes.  Reset back to start.
  1433
  1434 36E4			ExitWinColorScrollUp
  1435 36E4 60				rts
  1436
  1437
  1438 				; ==========================================================================
  1439 				; WIN COLOR SCROLL DOWN                                                 A
  1440 				; ==========================================================================
  1441 				; Support function.
  1442 				; Redundant code section used for two separate places in the Win event.
  1443 				; Add 4 to the current color.
  1444 				; Reset to 18 if the limit 242 (== 238 + 4) is reached.
  1445 				;
  1446 				; A  is the current color.   
  1447 				; --------------------------------------------------------------------------
  1448
  1449 36E5			WinColorScrollDown
  1450
  1451 36E5 18				clc
  1452 36E6 69 04			adc #4                      ; Add 4
  1453 36E8 C9 F2		 	cmp #242                    ; Did it pass the limit (max 238, plus 4 == 242)
  1454 36EA D0 02			bne ExitWinColorScrollDown  ; No. We're done here.
  1455 36EC A9 12			lda #18                     ; Yes.  Reset back to start.
  1456
  1457 36EE			ExitWinColorScrollDown
  1458 36EE 60				rts
  1459
  1460
  1461 				; ==========================================================================
  1462 				; WIN RANINBOW
  1463 				; ==========================================================================
  1464 				; Scroll Rainbow colors on screen while waiting for a button press.
  1465 				; Scroll up at top. light to dark.  
  1466 				; Scroll down at bottom.  Dark to light.
  1467 				; Do not use $0x or $Fx  (Min 16, max 238)
  1468 				; 
  1469 				; Setup for next transition in EventCounter.
  1470 				; --------------------------------------------------------------------------
  1471
  1472 36EF			WinRainbow
  1473
  1474 				; ======================== T O P ========================  
  1475 				; Color scrolling skips the black/grey/white values.  
  1476 				; The scrolling uses values 238 to 18 step -4
  1477 36EF A5 9C			lda EventCounter        ; Get starting value from last frame
  1478 36F1 20 DB 36			jsr WinColorScrollUp    ; Subtract 4 and reset to start if needed.
  1479 36F4 85 9C			sta EventCounter        ; Save it for next time.
  1480
  1481 36F6 A0 02			ldy #2 ; Color the Top 20 lines of screen...
  1482 36F8			LoopTopWinScroll
  1483 36F8 99 84 50			sta COLBK_TABLE,y       ; Set color for line on screen
  1484 36FB 20 DB 36			jsr WinColorScrollUp    ; Subtract 4 and reset to start if needed.
  1485
  1486 36FE C8				iny                     ; Next line on screen.
  1487 36FF C0 14			cpy #20                 ; Reached the 19th (20th table entry) line?
  1488 3701 D0 F5			bne LoopTopWinScroll    ; No, continue looping.
  1489
  1490 3703 48				pha                     ; Save current color to use as start value later.
  1491
  1492 				; ======================== M I D D L E ========================  
  1493 				; Background/COLBK in the text section is static in the color tables.
  1494 				; Manipulate current color to make it the "inverse" color for the Text.
  1495 3704 49 F0			eor #$F0                ; Invert color bits for the middle SAVED text.
  1496 3706 29 F0			and #$F0                ; Truncate luminance bits.
  1497 3708 09 02			ora #$02                ; Start at +2.
  1498
  1499 370A A0 1B			ldy #27                 ; Start at bottom of text going backwards.
  1500 370C			bews_LoopTextColors
  1501 370C 99 B5 50			sta COLPF0_TABLE,Y      ; Use as manipulated color for 
  1502 370F 18				clc                     ; the six lines of giant label "text."
  1503 3710 69 02			adc #2                  ; brightness:  2, 4, 6, 8, A, C
  1504 3712 88				dey
  1505 3713 C0 15			cpy #21
  1506 3715 D0 F5			bne bews_LoopTextColors
  1507
  1508 				; ======================== B O T T O M ========================  
  1509 3717 68				pla                         ; Get the color back for scrolling the bottom. 
  1510
  1511 				; Color scrolling skips the black/grey/white values.  
  1512 				; The scrolling uses values 18 to 238 step +4
  1513 3718 A0 1D			ldy #29                 ; Bottom 20 lines of screen (above prompt and credits.)
  1514 371A			LoopBottomWinScroll         ; Scroll colors in opposite direction
  1515 371A 20 E5 36			jsr WinColorScrollDown  ; Add 4, and reset to start if needed.
  1516 371D 99 84 50			sta COLBK_TABLE,y       ; Set color for line on screen
  1517 3720 C8				iny                     ; Next line on screen.
  1518 3721 C0 30			cpy #48                 ; Reached the end, 20th line after text? 
  1519 3723 D0 F5			bne LoopBottomWinScroll ; No, continue looping.
  1520
  1521 				;EndWinRainbow
  1522
  1523 3725 60				rts
  1524
  1525
  1526 				; ==========================================================================
  1527 				; SLICE COLOR AND LUMA                                              A  Y
  1528 				; ==========================================================================
  1529 				; Supporting the support function. Decrement Title text colors.
  1530 				;
  1531 				; Separate luminance from color. 
  1532 				; If luminance is already 0, then return color as 0.
  1533 				; Decrement the luminance.
  1534 				; Recombine with original color.
  1535 				; 
  1536 				; A = color value to adjust
  1537 				; --------------------------------------------------------------------------
  1538
  1539 3726			SliceColorAndLuma
  1540
  1541 3726 85 A0			sta SavePF                ; Save the incoming value
  1542 3728 29 F0			and #$F0                  ; Mask out the luminance.
  1543 372A 85 A1			sta SavePFC               ; Save just the color part.
  1544
  1545 372C A5 A0			lda SavePF                ; Get the original value again.
  1546 372E 29 0F			and #$0F                  ; Now check keep the luminance.
  1547 3730 F0 08			beq ExitSliceColorAndLuma ; If it is 0, we can exit with A as color/lum 0.
  1548
  1549 3732 A8				tay                       ; Y = A = Luminance
  1550 3733 88				dey                       ; Dec
  1551 3734 F0 01			beq Reassemble_PF         ; If 0, then we're done.
  1552 3736 88				dey                       ; Dec twice to speed the transition.
  1553
  1554 3737			Reassemble_PF
  1555 3737 98				tya                       ; A = Y = Luminance
  1556 3738 05 A1			ora SavePFC               ; join the color.
  1557
  1558 373A			ExitSliceColorAndLuma
  1559 373A 60				rts
  1560
  1561
  1562 				; ==========================================================================
  1563 				; FADE COLPF TO BLACK
  1564 				; ==========================================================================
  1565 				; Support function. Decrement Title text colors.
  1566 				; 
  1567 				; This is cut out of the EventTransitionToGame to make that code shorter 
  1568 				; and more readable, but most importantly it allows that routines start to 
  1569 				; branch instead of jmp to the end/exit point.
  1570 				;
  1571 				; BEQ state is exit immediate exit. (Text value has reached 0)
  1572 				; --------------------------------------------------------------------------
  1573 				; === STAGE 1 ===
  1574 				; ; Fade out text lines  from bottom to top.
  1575 				; Fade out COLPF0 and COLPF1 at the same time.
  1576 				; When luminance reaches 0, set color to 0. 
  1577 				; Return flags the OR value of the COLPF0 and COLPF1.
  1578 				; --------------------------------------------------------------------------
  1579
  1580 373B			FadeColPfToBlack
  1581
  1582 373B A6 9D			ldx EventCounter2         ; Row counter decrementing.
  1583
  1584 373D BD E6 50			lda COLPF1_TABLE,x
  1585 3740 F0 06			beq TryCOLPF0             ; It is already 0, so skip this.
  1586 3742 20 26 37			jsr SliceColorAndLuma
  1587 3745 9D E6 50			sta COLPF1_TABLE,x
  1588
  1589 3748			TryCOLPF0
  1590 3748 BD B5 50			lda COLPF0_TABLE,x
  1591 374B F0 06			beq ExitFadeColPfToBlack  ; It is already 0, so skip this.
  1592 374D 20 26 37			jsr SliceColorAndLuma
  1593 3750 9D B5 50			sta COLPF0_TABLE,x
  1594
  1595 3753			ExitFadeColPfToBlack          ; Insure we're leaving with 0 for both colors 0.  Or !0 otherwise.
  1596 3753 BD B5 50			lda COLPF0_TABLE,x        ; Get current color 0
  1597 3756 1D E6 50			ora COLPF1_TABLE,x        ; ORA the value of color 0
  1598
  1599 3759 60				rts
  1600
  1601
  1602 				; ==========================================================================
  1603 				; GREY EACH COLOR TABLE
  1604 				; ==========================================================================
  1605 				; Support function. Turn color table entries to grey. 
  1606 				; 
  1607 				; Replace all the color components of the current row with the 
  1608 				; chosen color. 
  1609 				;
  1610 				; Grey doesn't necessarily mean grey. It would be whatever the chosen 
  1611 				; base color is which is passed in the A register. 
  1612 				;
  1613 				; Uses TempWipeColor in page 0.
  1614 				; X = current Row
  1615 				; A = color to use, expected to be color component (i.e. $F0 with luminance
  1616 				;     bits 0) 
  1617 				; --------------------------------------------------------------------------
  1618
  1619 375A			GreyEachColorTable
  1620
  1621 375A 85 A0			sta TempWipeColor     ; Save it to reuse
  1622
  1623 375C BD B8 50			lda COLPF0_TABLE+3,x  ; Pull the row's color from the color table
  1624 375F 29 0F			and #$0F              ; Zero the table color, keep the luminance.
  1625 3761 05 A0			ora TempWipeColor     ; Add the caller's input color to the luminance.
  1626 3763 9D B8 50			sta COLPF0_TABLE+3,x  ; Resave the new value in the color table.
  1627
  1628 3766 BD E9 50			lda COLPF1_TABLE+3,x  ; Rinse for COLPF1
  1629 3769 29 0F			and #$0F
  1630 376B 05 A0			ora TempWipeColor
  1631 376D 9D E9 50			sta COLPF1_TABLE+3,x
  1632
  1633 3770 BD 1A 51			lda COLPF2_TABLE+3,x ; Repeat for COLPF2
  1634 3773 29 0F			and #$0F
  1635 3775 05 A0			ora TempWipeColor
  1636 3777 9D 1A 51			sta COLPF2_TABLE+3,x
  1637
  1638 377A BD 4B 51			lda COLPF3_TABLE+3,x ; And So On...
  1639 377D 29 0F			and #$0F
  1640 377F 05 A0			ora TempWipeColor
  1641 3781 9D 4B 51			sta COLPF3_TABLE+3,x
  1642
  1643 3784 BD 87 50			lda COLBK_TABLE+3,x  ; and more.
  1644 3787 29 0F			and #$0F
  1645 3789 05 A0			ora TempWipeColor
  1646 378B 9D 87 50			sta COLBK_TABLE+3,x
  1647
  1648 378E 60				rts
  1649
  1650
  1651 				;==============================================================================
  1652 				; RANDOMIZE TITLE COLORS 
  1653 				;==============================================================================
  1654 				; Support function. Set a random gradient for the title pixels.
  1655 				; -----------------------------------------------------------------------------
  1656
  1657 378F			RandomizeTitleColors
  1658
  1659 378F AD 0A D2			lda RANDOM               ; Get a random value
  1660 3792 4D B8 50			eor COLPF0_TABLE+3       ; Flip bits through the previous color.
  1661 3795 29 F0			and #$F0                 ; Keep color component
  1662 3797 09 04			ora #$04                 ; Start at 4, so we get 4, 6, 8, 10, 12, 14.
  1663 3799 AA				tax                      ; X = A  ; for the increments below.
  1664
  1665 379A A0 05			ldy #5
  1666 379C			bRTC_RecolorText             ; Fill the six bytes of color entries.
  1667 379C 99 B8 50			sta COLPF0_TABLE+3,y
  1668 379F E8				inx                      ; ++X ; color + luminance
  1669 37A0 E8				inx                      ; ++X ; color + luminance
  1670 37A1 8A				txa                      ; A = X in order to save
  1671 37A2 88				dey                      ; --X ; previous color entry.
  1672 37A3 10 F7			bpl bRTC_RecolorText     ; do 0 entry, too. stop at -1.
  1673
  1674 37A5 60				rts
  1675
  1676
  1677 				;==============================================================================
  1678 				; RESET TITLE COLORS 
  1679 				;==============================================================================
  1680 				; Support function. Set the original colors for the title pixels.
  1681 				; -----------------------------------------------------------------------------
  1682
  1683 37A6			ResetTitleColors
  1684
  1685 37A6 A2 05			ldx #5
  1686 37A8			bRTC_RecolorTitle            ; Fix the six bytes of Title color entries.
  1687 37A8 BD 1D 4E			lda TITLE_PIXEL_COLORS,x
  1688 37AB 9D B8 50			sta COLPF0_TABLE+3,x
  1689 37AE CA				dex                      ; --X ; previous color entry.
  1690 37AF 10 F7			bpl bRTC_RecolorTitle    ; do 0 entry, too. stop at -1.
  1691
  1692 37B1 60				rts
  1693
  1694
  1695 				;==============================================================================
  1696 				; C H A R A C T E R   A N I M A T I O N
  1697 				;==============================================================================
  1698
  1699 				;==============================================================================
  1700 				;										DoBoatCharacterAnimation  A  X
  1701 				;==============================================================================
  1702 				; Based on the current frame value and the component value, copy 
  1703 				; the 8 bytes from the animation table to the character image.
  1704 				;
  1705 				; ManageBoatAnimations takes care of determining if it is time to animate, 
  1706 				; and the current component, and the frame counter.
  1707 				; This function just uses the current values and copies the indicated 
  1708 				; character image.
  1709 				;
  1710 				; When BoatyMcBoatCounter is 0, then animate based on BoatyComponent
  1711 				; 0 = Right Boat Front
  1712 				; 1 = Right Boat Back
  1713 				; 2 = Left Boat Front
  1714 				; 3 = Left Boat Back
  1715 				;BoatyFrame         .byte 0  ; counts 0 to 7.
  1716 				;BoatyMcBoatCounter .byte 2  ; decrement.  On 0 animate a component.
  1717 				;BoatyComponent     .byte 0  ; 0, 1, 2, 3 one of the four boat parts.
  1718 				; 
  1719 				; The Boat Front is two characters.   One of the characters changes
  1720 				; only on frame 2 and frame 6, so there is extra exception logic to 
  1721 				; copy those frames when they occur.
  1722 				;
  1723 				; You know, a marginally smart person would have made this code smaller 
  1724 				; by using  another list of values based on component number to provide the 
  1725 				; base pointers to the arrays of addresses for the source and target
  1726 				; character maps.
  1727 				;
  1728 				; X = frame counter
  1729 				; -----------------------------------------------------------------------------
  1730
  1731 37B2			DoBoatCharacterAnimation
  1732 				; Zero is Right Front Boat.
  1733
  1734 37B2 A5 D5			lda BoatyComponent               ; Get the component to animate
  1735 37B4 D0 32			bne TestBoaty1                   ; Non-zero means try 1, 2, 3
  1736
  1737 37B6 BD FA 52			lda RIGHT_BOAT_WATER_LOW,x       ; Get pointer for the data for this frame 
  1738 37B9 85 D7			sta VBIPointer1
  1739 37BB BD 02 53			lda RIGHT_BOAT_WATER_HIGH,x
  1740 37BE 85 D8			sta VBIPointer1+1
  1741
  1742 37C0 A9 48			lda #<[CHARACTER_SET+I_BOAT_RFW*8] ; Get pointer to destination character.
  1743 37C2 85 D9			sta VBIPointer2
  1744 37C4 A9 42			lda #>[CHARACTER_SET+I_BOAT_RFW*8]
  1745 37C6 85 DA			sta VBIPointer2+1
  1746 37C8 20 4D 38			jsr BoatCsetCopy8                ; Copy the 8 bytes to the character set via the pointers set up.
  1747
  1748 				; Zero, Part 2 for Right Front Boat.
  1749
  1750 37CB E0 02			cpx #2                           ; Frame 2 and 6 have new images at front of boat.
  1751 37CD F0 04			beq bCopyRightFrontBoat          ; Yes, this is 2. Copy new image
  1752 37CF E0 06			cpx #6                           ; If not, then is it 6?
  1753 37D1 D0 79			bne ExitBoatCharacterAnimation   ; Not 6, so done with the frame animation.
  1754
  1755 37D3			bCopyRightFrontBoat
  1756 37D3 BD 0A 53			lda RIGHT_BOAT_FRONT_LOW,x       ; Get pointer for the data for this frame 
  1757 37D6 85 D7			sta VBIPointer1
  1758 37D8 BD 12 53			lda RIGHT_BOAT_FRONT_HIGH,x
  1759 37DB 85 D8			sta VBIPointer1+1
  1760
  1761 37DD A9 58			lda #<[CHARACTER_SET+I_BOAT_RF*8]  ; Get pointer to destination character.
  1762 37DF 85 D9			sta VBIPointer2
  1763 37E1 A9 42			lda #>[CHARACTER_SET+I_BOAT_RF*8]
  1764 37E3 85 DA			sta VBIPointer2+1
  1765 37E5 4C 49 38			jmp BoatCopy8                    ;  Go do the 8 byte copy to the character set via the pointers.
  1766
  1767 				; One is Right Back Boat.
  1768
  1769 37E8			TestBoaty1
  1770 37E8 C9 01			cmp #1
  1771 37EA D0 15			bne TestBoaty2                   ; Not 1.  So, not the Right back boat.
  1772
  1773 37EC BD 1A 53			lda RIGHT_BOAT_WAKE_LOW,x        ; Get pointer for the data for this frame 
  1774 37EF 85 D7			sta VBIPointer1
  1775 37F1 BD 22 53			lda RIGHT_BOAT_WAKE_HIGH,x
  1776 37F4 85 D8			sta VBIPointer1+1
  1777
  1778 37F6 A9 D8			lda #<[CHARACTER_SET+I_BOAT_RBW*8] ; Get pointer to destination character.
  1779 37F8 85 D9			sta VBIPointer2
  1780 37FA A9 40			lda #>[CHARACTER_SET+I_BOAT_RBW*8]
  1781 37FC 85 DA			sta VBIPointer2+1
  1782 37FE 4C 49 38			jmp BoatCopy8                    ;  Go do the 8 byte copy to the character set via the pointers.
  1783
  1784 				; Two is Left Front Boat.
  1785
  1786 3801			TestBoaty2
  1787 3801 C9 02			cmp #2
  1788 3803 D0 32			bne TestBoaty3
  1789
  1790 3805 BD 2A 53			lda LEFT_BOAT_WATER_LOW,x        ; Get pointer for the data for this frame 
  1791 3808 85 D7			sta VBIPointer1
  1792 380A BD 32 53			lda LEFT_BOAT_WATER_HIGH,x
  1793 380D 85 D8			sta VBIPointer1+1
  1794
  1795 380F A9 18			lda #<[CHARACTER_SET+I_BOAT_LFW*8] ; Get pointer to destination character.
  1796 3811 85 D9			sta VBIPointer2
  1797 3813 A9 40			lda #>[CHARACTER_SET+I_BOAT_LFW*8]
  1798 3815 85 DA			sta VBIPointer2+1
  1799 3817 20 4D 38			jsr BoatCsetCopy8                ; Copy the 8 bytes to the character set via the pointers set up.
  1800
  1801 				; Two, Part 2 for Left Front Boat.
  1802
  1803 381A E0 02			cpx #2                           ; Frame 2 and 6 have new images at front of boat.
  1804 381C F0 04			beq bCopyLeftFrontBoat           ; Yes, this is 2. Copy new image
  1805 381E E0 06			cpx #6                           ; If not, then is it 6?
  1806 3820 D0 2A			bne ExitBoatCharacterAnimation   ; Not 6, so done with the frame animation.
  1807
  1808 3822			bCopyLeftFrontBoat
  1809 3822 BD 3A 53			lda LEFT_BOAT_FRONT_LOW,x        ; Get pointer for the data for this frame 
  1810 3825 85 D7			sta VBIPointer1
  1811 3827 BD 42 53			lda LEFT_BOAT_FRONT_HIGH,x
  1812 382A 85 D8			sta VBIPointer1+1
  1813
  1814 382C A9 10			lda #<[CHARACTER_SET+I_BOAT_LF*8]  ; Get pointer to destination character.
  1815 382E 85 D9			sta VBIPointer2
  1816 3830 A9 40			lda #>[CHARACTER_SET+I_BOAT_LF*8]
  1817 3832 85 DA			sta VBIPointer2+1
  1818 3834 4C 49 38			jmp BoatCopy8                    ;  Go do the 8 byte copy to the character set via the pointers.
  1819
  1820 				; Three is Left Back Boat.
  1821
  1822 3837			TestBoaty3
  1823 3837 BD 4A 53			lda LEFT_BOAT_WAKE_LOW,x        ; Get pointer for the data for this frame 
  1824 383A 85 D7			sta VBIPointer1
  1825 383C BD 52 53			lda LEFT_BOAT_WAKE_HIGH,x
  1826 383F 85 D8			sta VBIPointer1+1
  1827
  1828 3841 A9 78			lda #<[CHARACTER_SET+I_BOAT_LBW*8] ; Get pointer to destination character.
  1829 3843 85 D9			sta VBIPointer2
  1830 3845 A9 40			lda #>[CHARACTER_SET+I_BOAT_LBW*8]
  1831 3847 85 DA			sta VBIPointer2+1
  1832
  1833 				; Done with frame setup.  Now copy the frame.
  1834
  1835 3849			BoatCopy8
  1836 3849 20 4D 38			jsr BoatCsetCopy8            ;  Copy the 8 bytes to the character set via the pointers set up.
  1837
  1838 384C			ExitBoatCharacterAnimation
  1839 384C 60				rts
  1840
  1841
  1842 				;==============================================================================
  1843 				;										BoatCsetCopy8  A  Y
  1844 				;==============================================================================
  1845 				; DoBoatCharacterAnimation set up zero page VBIPointer1 and VBIPointer2.
  1846 				; Copy 8 bytes from pointer1 to pointer 2.
  1847 				; Without the cpy/bne loop overhead *  8 bytes.
  1848 				;
  1849 				; Y = byte index.
  1850 				; -----------------------------------------------------------------------------
  1851
  1852 384D			BoatCsetCopy8
  1853
  1854 384D A0 00			ldy #0
  1855
  1856 384F B1 D7			lda (VBIPointer1),y ; 1
  1857 3851 91 D9			sta (VBIPointer2),y
  1858 3853 C8				iny
  1859 3854 B1 D7			lda (VBIPointer1),y ; 2
  1860 3856 91 D9			sta (VBIPointer2),y
  1861 3858 C8				iny
  1862 3859 B1 D7			lda (VBIPointer1),y ; 3
  1863 385B 91 D9			sta (VBIPointer2),y
  1864 385D C8				iny
  1865 385E B1 D7			lda (VBIPointer1),y ; 4
  1866 3860 91 D9			sta (VBIPointer2),y
  1867 3862 C8				iny
  1868 3863 B1 D7			lda (VBIPointer1),y ; 5
  1869 3865 91 D9			sta (VBIPointer2),y
  1870 3867 C8				iny
  1871 3868 B1 D7			lda (VBIPointer1),y ; 6
  1872 386A 91 D9			sta (VBIPointer2),y
  1873 386C C8				iny
  1874 386D B1 D7			lda (VBIPointer1),y ; 7
  1875 386F 91 D9			sta (VBIPointer2),y
  1876 3871 C8				iny
  1877 3872 B1 D7			lda (VBIPointer1),y ; 8
  1878 3874 91 D9			sta (VBIPointer2),y
  1879
  1880 3876 60				rts
  1881
  1882
  1883 				;==============================================================================
  1884 				; F I N E   S C R O L L I N G
  1885 				;==============================================================================
  1886
  1887 				; ==========================================================================
  1888 				; FINE SCROLL THE CREDIT LINE
  1889 				; ==========================================================================
  1890 				; Perpetually Scrolling Credits
  1891 				; 
  1892 				; The credits appear at the bottom line of the screen and continue 
  1893 				; scrolling forever.
  1894 				; 
  1895 				; ANTIC supports fine horizontal scrolling 16 color clocks or 4 text
  1896 				; characters at a time.  This means the buffer to scroll needs to be a 
  1897 				; multiple of 4 character long.  Just remember to pad after editing.
  1898 				;
  1899 				; Most of the time only update HSCROL.  
  1900 				; Occasionally, add 4 to the LMS pointer to screen data to coarse scroll.
  1901 				; --------------------------------------------------------------------------
  1902
  1903 3877			FineScrollTheCreditLine          ; scroll the text identifying the perpetrators
  1904
  1905 3877 C6 BA			dec CreditHSCROL             ; Subtract one color clock from the left (aka fine scroll).
  1906 3879 10 13			bpl ExitScrollTheCredits     ; It did not roll 0 to -1.  Nothing else to do here.
  1907
  1908 387B			ResetCreditScroll                ; Fine Scroll reached 0, so coarse scroll the text.
  1909 387B A5 F7			lda SCROLL_CREDIT_LMS        ; Move text left one character position.
  1910 387D 18				clc
  1911 387E 69 04			adc #4
  1912 3880 85 F7			sta SCROLL_CREDIT_LMS
  1913 3882 C9 D0			cmp #<END_OF_CREDITS         ; Did coarse scroll position reach the end of the text?
  1914 3884 D0 04			bne RestartCreditHSCROL      ; No.  We are done with coarse scroll, now reset fine scroll. 
  1915
  1916 3886 A9 00			lda #<SCROLLING_CREDIT       ; Yes, restart coarse scroll to the beginning position.
  1917 3888 85 F7			sta SCROLL_CREDIT_LMS
  1918
  1919 388A			RestartCreditHSCROL              ; Reset the 
  1920 388A A9 0F			lda #15                      ; horizontal fine 
  1921 388C 85 BA			sta CreditHSCROL             ; scrolling.
  1922
  1923 388E			ExitScrollTheCredits
  1924 388E 60				rts
  1925
  1926
  1927 				;==============================================================================
  1928 				; F I N E   S C R O L L I N G   B O A T S
  1929 				;==============================================================================
  1930
  1931 				; Offsets from the first LMS low byte in the Display List 
  1932 				; to the subsequent LMS low byte of each boat line. (VBI)
  1933 				; For the Right Boats this is the offset from PF_LMS1.
  1934 				; For the Left Boats this is the offset from PF_LMS2.
  1935 388F			BOAT_LMS_OFFSET 
  1936 388F 00 00 00 00 11 11 + 	.by 0 0 0 0 17 17 0 34 34 0 51 51 0 68 68 0 85 85 
  1937
  1938 				; Index into DLI's HSCROL table for each boat row. 
  1939 38A1			BOAT_HS_TABLE
  1940 38A1 00 04 05 00 07 08 + 	.by 0 4 5 0 7 8 0 10 11 0 13 14 0 16 17 0 19 20
  1941
  1942 				; ==========================================================================
  1943 				; RIGHT BOAT FINE SCROLLING
  1944 				; ==========================================================================
  1945 				; 
  1946 				; Start Scroll position = LMS + 12 (decrement), HSCROL 0  (Increment)
  1947 				; End   Scroll position = LMS + 0,              HSCROL 15
  1948 				;
  1949 				; X and Y are current row to analyze.
  1950 				; --------------------------------------------------------------------------
  1951
  1952 38B3			RightBoatFineScrolling
  1953
  1954 					; Easier to push the frog first before the actual fine scrolling.
  1955 38B3 C4 80			cpy FrogRow              ; Are we on the frog's row?
  1956 38B5 D0 07			bne DoFineScrollRight    ; No.  Continue with boat scroll.
  1957 38B7 18				clc
  1958 38B8 A5 85			lda FrogNewPMX
  1959 38BA 71 D2			adc (BoatMovePointer),y  ; Increment the position same as HSCROL distance.
  1960 38BC 85 85			sta FrogNewPMX
  1961
  1962 38BE			DoFineScrollRight
  1963 38BE BE A1 38			ldx BOAT_HS_TABLE,y      ; X = Get the index into HSCROL table.
  1964 38C1 BD 79 51			lda HSCROL_TABLE,x       ; Get value of HSCROL.
  1965 38C4 18				clc
  1966 38C5 71 D2			adc (BoatMovePointer),y  ; Increment the HSCROL.
  1967 38C7 C9 10			cmp #16                  ; Shift past scroll limit?
  1968 38C9 B0 04			bcs DoCoarseScrollRight  ; Yes.  Need to coarse scroll.
  1969 38CB 9D 79 51			sta HSCROL_TABLE,x       ; No. Save the updated HSCROL.
  1970 38CE 60				rts                      ; Done.  No coarse scroll this time.
  1971
  1972 					; HSCROL wrapped over 15.  Time to coarse scroll by subtracting 4 from LMS.
  1973 38CF			DoCoarseScrollRight
  1974 				;	sec  ; Got here via bcs
  1975 38CF E9 10			sbc #16                  ; Fix the new HSCROL
  1976 38D1 9D 79 51			sta HSCROL_TABLE,x       ; Save the updated HSCROL.
  1977 38D4 BE 8F 38			ldx BOAT_LMS_OFFSET,y    ; X = Get the index to the LMS in the Display List for this line.
  1978 38D7 BD 4D 46			lda PF_LMS1,x            ; Get the actual LMS low byte.
  1979 38DA 38				sec
  1980 38DB E9 04			sbc #4                   ; Subtract 4 from LMS in display list.
  1981 38DD 10 02			bpl SaveNewRightLMS      ; If still positive (0), then good to update LMS
  1982 38DF A9 0C			lda #12                  ; LMS went negative. Reset to start position.
  1983 38E1			SaveNewRightLMS
  1984 38E1 9D 4D 46			sta PF_LMS1,x            ; Update LMS pointer.
  1985
  1986 				;EndOfRightBoat
  1987 38E4 60				rts
  1988
  1989
  1990 				; ==========================================================================
  1991 				; LEFT BOAT FINE SCROLLING
  1992 				; ==========================================================================
  1993 				; 
  1994 				; Start Scroll position = LMS + 0 (increment), HSCROL 15  (Decrement)
  1995 				; End   Scroll position = LMS + 12,            HSCROL 0
  1996 				;
  1997 				; X and Y are current row to analyze/scroll.
  1998 				; --------------------------------------------------------------------------
  1999
  2000 38E5			LeftBoatFineScrolling
  2001
  2002 					; Easier to push the frog first before the actual fine scrolling.
  2003 38E5 C4 80			cpy FrogRow              ; Are we on the frog's row?
  2004 38E7 D0 07			bne DoFineScrollLeft     ; No.  Continue with boat scroll.
  2005 38E9 38				sec
  2006 38EA A5 85			lda FrogNewPMX
  2007 38EC F1 D2			sbc (BoatMovePointer),y  ; Decrement the position same as HSCROL distance.
  2008 38EE 85 85			sta FrogNewPMX
  2009
  2010 38F0			DoFineScrollLeft
  2011 38F0 BE A1 38			ldx BOAT_HS_TABLE,y      ; X = Get the index into HSCROL table.
  2012 38F3 BD 79 51			lda HSCROL_TABLE,x       ; Get value of HSCROL.
  2013 38F6 38				sec
  2014 38F7 F1 D2			sbc (BoatMovePointer),y  ; Decrement the HSCROL
  2015 38F9 30 04			bmi DoCoarseScrollLeft   ; It went negative, must reset and coarse scroll
  2016 38FB 9D 79 51			sta HSCROL_TABLE,x       ; It's OK. Save the updated HSCROL.
  2017 38FE 60				rts                      ; Done.  No coarse scroll this time.
  2018
  2019 					; HSCROL wrapped below 0.  Time to coarse scroll by Adding 4 to LMS.
  2020 38FF			DoCoarseScrollLeft
  2021 38FF 69 10			adc #16                  ; Re-wrap over 0 into the positive.
  2022 3901 9D 79 51			sta HSCROL_TABLE,x       ; Save the updated HSCROL.
  2023 3904 BE 8F 38			ldx BOAT_LMS_OFFSET,y    ; X = Get the index to the LMS in the Display List for this line.
  2024 3907 BD 54 46			lda PF_LMS2,x            ; Get the actual LMS low byte.
  2025 390A 18				clc
  2026 390B 69 04			adc #4                   ; Add 4 to LMS in display list.
  2027 390D C9 0D			cmp #13                  ; Is it greater than max (12)? 
  2028 390F 90 02			bcc SaveNewLeftLMS       ; No.  Good to update LMS.
  2029 3911 A9 00			lda #0                   ; LMS greater than 12. Reset to start position.
  2030 3913			SaveNewLeftLMS
  2031 3913 9D 54 46			sta PF_LMS2,x            ; Update LMS pointer.
  2032
  2033 				;EndOfLeftBoat
  2034 3916 60				rts
  2035
  2036
  2037 				;==============================================================================
  2038 				; F I N E   S C R O L L I N G   T I T L E
  2039 				;==============================================================================
  2040
  2041 				; ==========================================================================
  2042 				; TITLE_START=TITLE_MEM1-1 ; Cheating. To show all color clocks from 
  2043 				;                          ; TITLE_MEM1 the LMS is at * -1, and HSCROLL 0
  2044 				; TITLE_END   = TITLE_START+10
  2045 				;
  2046 				; Values for manipulating screen memory.
  2047 				; TITLE_LEFT  = TITLE_MEM1
  2048 				; TITLE_RIGHT = TITLE_MEM1+10
  2049 				;
  2050 				; Start Scroll position = TITLE_START (Increment), HSCROL 0  (Decrement)
  2051 				; End   Scroll position = TITLE_START + 10,        HSCROL 0
  2052 				; --------------------------------------------------------------------------
  2053
  2054 				; Offsets from first LMS low byte in Display List to 
  2055 				; the subsequent LMS low byte of each title line. (VBI use)
  2056 				; Offset from TT_LMS0.
  2057
  2058 3917			TITLE_LMS_OFFSET 
  2059 3917 00 03 06 09 0C 0F		.by 0 3 6 9 12 15 
  2060
  2061 391D			TITLE_LMS_ORIGIN
  2062 391D 3F 53 67 7B 8F A3		.by <TITLE_START <[TITLE_START+20] <[TITLE_START+40] <[TITLE_START+60] <[TITLE_START+80] <[TITLE_START+100]
  2063
  2064
  2065 				; ==========================================================================
  2066 				; TITLE IS IT AT THE END
  2067 				; ==========================================================================
  2068 				; Test Scrolling values.
  2069 				; Returns CPU flag:
  2070 				;  0 = At the end.
  2071 				; !0 = Continue to scroll.
  2072 				; --------------------------------------------------------------------------
  2073
  2074 3923			TitleIsItAtTheEnd
  2075
  2076 3923 AD 0C 46			lda TT_LMS0            ; Get current LMS
  2077 3926 C9 49			cmp #<[TITLE_END]      ; Did it reach the end? which is <[TITLE_START+10]
  2078 3928 D0 02			bne bTIIATE_Exit       ; No.  Exit here, since scrolling can continue. 
  2079 392A A5 B7			lda TitleHSCROL        ; What is the fine scroll position?
  2080
  2081 392C			bTIIATE_Exit
  2082 392C 60				rts
  2083
  2084
  2085 				; ==========================================================================
  2086 				; TITLE LEFT SCROLL
  2087 				; ==========================================================================
  2088 				; Left scroll from origin (LMS-1/0) to Right target (9/0)
  2089 				; --------------------------------------------------------------------------
  2090
  2091 392D			TitleLeftScroll
  2092
  2093 392D 20 23 39			jsr TitleIsItAtTheEnd  ; Test if scrolling limits reached.
  2094 3930 F0 21			beq bTLF_Exit          ; Zero.  Reached the end.  Nothing to do.
  2095
  2096 				;bTLF_Scrollit              ; 2 color clocks per scroll.
  2097 3932 C6 B7			dec TitleHSCROL        ; Decrement HSCROL... 14, 12, 10, 8, 6, 4, 2, 0
  2098 3934 20 23 39			jsr TitleIsItAtTheEnd  ; Test if scrolling limits reached.
  2099 3937 F0 1A			beq bTLF_Exit          ; At the end.
  2100 3939 C6 B7			dec TitleHSCROL        ; Decrement HSCROL. 13, 11, 9, 7, 5, 3, 1, -1 (reset)
  2101 393B 10 16			bpl bTLF_Exit          ; Positive.  Nothing else to do.
  2102
  2103 				;bTLF_ResetTitleHScrol
  2104 393D A9 0F			lda #15                ; Coarse scrolling to next byte
  2105 393F 85 B7			sta TitleHSCROL        ; Reset HSCROL for next screen byte.
  2106
  2107 3941 EE 0C 46			inc TT_LMS0            ; Coarse scroll display to next byte...
  2108 3944 EE 0F 46			inc TT_LMS1            ; Incrementing 6 pointers rather than copying 60 bytes.
  2109 3947 EE 12 46			inc TT_LMS2
  2110 394A EE 15 46			inc TT_LMS3
  2111 394D EE 18 46			inc TT_LMS4
  2112 3950 EE 1B 46			inc TT_LMS5
  2113
  2114 3953			bTLF_Exit
  2115 3953 60				rts
  2116
  2117
  2118 				; ==========================================================================
  2119 				; TITLE SHIFT DOWN
  2120 				; ==========================================================================
  2121 				; Shift down the content of the Left buffer to incrementally and visibly 
  2122 				; clear the Left buffer before the scroll from the right.   ALSO shift down
  2123 				; the color table entries for the Title to follow the text pixels.
  2124 				; --------------------------------------------------------------------------
  2125
  2126 3954			TitleShiftDown
  2127
  2128 3954 20 A6 3A			jsr TitleWaitForScanLine88 ; Be sure the beam passed the title. 
  2129
  2130 3957 A2 09			ldx #9
  2131
  2132 3959			bTSD_Loop
  2133 3959 BD 90 48			lda TITLE_LEFT+80,x   ; Copy Pixel Row 5 
  2134 395C 9D A4 48			sta TITLE_LEFT+100,x  ; down to Row 6
  2135
  2136 395F BD 7C 48			lda TITLE_LEFT+60,x   ; Copy Pixel Row 4
  2137 3962 9D 90 48			sta TITLE_LEFT+80,x   ; down to Row 5
  2138
  2139 3965 BD 68 48			lda TITLE_LEFT+40,x   ; Copy Pixel Row 3
  2140 3968 9D 7C 48			sta TITLE_LEFT+60,x   ; down to Row 4
  2141
  2142 396B BD 54 48			lda TITLE_LEFT+20,x   ; Copy Pixel Row 2
  2143 396E 9D 68 48			sta TITLE_LEFT+40,x   ; down to Row 3
  2144
  2145 3971 BD 40 48			lda TITLE_LEFT,x      ; Copy Pixel Row 1
  2146 3974 9D 54 48			sta TITLE_LEFT+20,x   ; down to Row 2
  2147
  2148 3977 A9 00			lda #0                ; Erase
  2149 3979 9D 40 48			sta TITLE_LEFT,x      ; Row 1
  2150 				 
  2151 397C CA				dex
  2152 397D 10 DA			bpl bTSD_Loop         ; Loop including 0
  2153
  2154
  2155 397F A2 04			ldx #4                ; Now move the pixel colors to match.
  2156
  2157 3981			bTSD_ColorLoop
  2158 3981 BD B8 50			lda COLPF0_TABLE+3,x  ; shift colors in table 3 to 7 (actually from 7, 6, 5, 4, 3)
  2159 3984 9D B9 50			sta COLPF0_TABLE+4,x  ; down to table 4 to 8         (actually to 8, 7, 6, 5, 4)
  2160
  2161 3987 CA				dex
  2162 3988 10 F7			bpl bTSD_ColorLoop    ; Loop including 0
  2163
  2164 398A 60				rts
  2165
  2166
  2167 				; ==========================================================================
  2168 				; Screen codes for printing the numbers for the Option/Select Hacks.
  2169 				; ==========================================================================
  2170 				; Combine something from the "LIST" and stuff it into the "NUMBER" 
  2171 				; location, then print the string to pixels.
  2172 				; "LEVEL 9"   "7 LIVES"
  2173 				; --------------------------------------------------------------------------
  2174
  2175 398B 00 2C 65 76 65 6C + LEVEL_TEXT   .sb " Level "
  2176 3992 00 00 00		LEVEL_NUMBER .sb "   "            ; Actual number goes here.
  2177
  2178 3995			LIVES_LIST                        ; Reference 1 to 7 as --X, so 0 to 8
  2179 3995 11 12 13 14 15 16 + LEVEL_LIST1  .sb "12345678911111" ; 0 to 13 == 1 to 14
  2180 39A3 00 00 00 00 00 00 + LEVEL_LIST2  .sb "         01234" ; 
  2181
  2182 39B1 00			LIVES_TEXT   .sb " "
  2183 39B2 00 00 2C 69 76 65 + LIVES_NUMBER .sb "  Lives  "      ; Actual number goes there
  2184
  2185
  2186 				; ==========================================================================
  2187 				; TITLE PREP LEVEL
  2188 				; ==========================================================================
  2189 				; Convert the user-selected NewLevelStart to "text" built of pixels
  2190 				; that will be scrolled into the Title area.
  2191 				; --------------------------------------------------------------------------
  2192
  2193 39BB			TitlePrepLevel
  2194
  2195 39BB A6 8C			ldx NewLevelStart   ; 0 to 13  is 1 to 14
  2196
  2197 39BD BD 95 39			lda LEVEL_LIST1,x
  2198 39C0 8D 92 39			sta LEVEL_NUMBER
  2199
  2200 39C3 BD A3 39			lda LEVEL_LIST2,x
  2201 39C6 8D 93 39			sta LEVEL_NUMBER+1
  2202
  2203 39C9 A9 8B			lda #<LEVEL_TEXT
  2204 39CB A2 39			ldx #>LEVEL_TEXT
  2205
  2206 39CD 4C F8 39			jmp TitleFinishPrep
  2207
  2208
  2209 				; ==========================================================================
  2210 				; TITLE PREP LIVES
  2211 				; ==========================================================================
  2212 				; Convert the user-selected NewNumberOfLives to "text" built of pixels
  2213 				; that will be scrolled into the Title area.
  2214 				; Correctly label the value as "LIFE" or "LIVES".
  2215 				; hackitty hack hack hack
  2216 				; --------------------------------------------------------------------------
  2217
  2218 39D0			TitlePrepLives
  2219
  2220 39D0 A6 8F			ldx NewNumberOfLives ; 1 to 7 
  2221 39D2 CA				dex
  2222 39D3 D0 0C			bne bTPL_UsePlural ; 1 LIFE, 2 LIVES, right?
  2223 					; Singular
  2224 39D5 A9 66			lda #I_F
  2225 39D7 8D B6 39			sta LIVES_NUMBER+4   
  2226 39DA A9 00			lda #I_SPACE
  2227 39DC 8D B8 39			sta LIVES_NUMBER+6   
  2228 39DF F0 0A			beq bTPL_SkipPlural
  2229
  2230 39E1			bTPL_UsePlural
  2231 39E1 A9 76			lda #I_V
  2232 39E3 8D B6 39			sta LIVES_NUMBER+4
  2233 39E6 A9 73			lda #I_S
  2234 39E8 8D B8 39			sta LIVES_NUMBER+6
  2235
  2236 39EB			bTPL_SkipPlural
  2237 39EB BD 95 39			lda LEVEL_LIST1,x
  2238 39EE 8D B2 39			sta LIVES_NUMBER
  2239
  2240 39F1 A9 B1			lda #<LIVES_TEXT
  2241 39F3 A2 39			ldx #>LIVES_TEXT
  2242
  2243 39F5 4C F8 39			jmp TitleFinishPrep
  2244
  2245
  2246 				; ==========================================================================
  2247 				; TITLE FINISH PREP
  2248 				; ==========================================================================
  2249 				; Common code.  Fill in pointer, set length.  Print the pixels.
  2250 				;
  2251 				; A+X == Address of screen codes to print.
  2252 				; --------------------------------------------------------------------------
  2253
  2254 39F8			TitleFinishPrep
  2255
  2256 39F8 85 A3			sta MainPointer1
  2257 39FA 86 A4			stx MainPointer1+1
  2258
  2259 39FC A2 00			ldx #0
  2260 39FE A0 0A			ldy #10
  2261
  2262 3A00 20 04 3A			jsr TitlePrintString
  2263
  2264 3A03 60				rts
  2265
  2266
  2267 				; ==========================================================================
  2268 				; TITLE PRINT STRING                                MainPointer1  A  X  Y
  2269 				; ==========================================================================
  2270 				; Iterate through a string of internal screen code characters.
  2271 				;
  2272 				; Uses MainPointer1 for string pointer.
  2273 				; Uses SAVEY to remember the string length.
  2274 				; Uses A to pass each character to the printing routine.
  2275 				;
  2276 				; X = position in screen's Right text buffer.  0 to 9.
  2277 				; Y = length
  2278 				; 
  2279 				; Registers saved prior to work.
  2280 				; --------------------------------------------------------------------------
  2281
  2282 3A04			TitlePrintString
  2283
  2284 3A04 C0 00			cpy #0                ; If length is 0, then
  2285 3A06 F0 0F			beq bTPS_Exit         ; Nothing to do here.  (yes, overkill. could check X too for greater than 9.  derp.)
  2286
  2287 3A08 84 FF			sty SAVEY             ; Remember length for later.
  2288
  2289 3A0A A0 00			ldy #0                ; Start working length at 0 (index into input).
  2290 3A0C			bTPS_Loop
  2291 3A0C B1 A3			lda (MainPointer1),y  ; Get internal code character from input
  2292 3A0E 20 18 3A			jsr TitlePrintChar    ; Print it.  This routine preserves all registers.
  2293 3A11 E8				inx                   ; Next character position in output screen buffer
  2294 3A12 C8				iny                   ; Next position in the input string
  2295 3A13 C4 FF			cpy SAVEY             ; Did it reach length?
  2296 3A15 D0 F5			bne bTPS_Loop         ; Not yet.  Do next character.
  2297
  2298 3A17			bTPS_Exit
  2299 3A17 60				rts
  2300
  2301
  2302 				; ==========================================================================
  2303 				; TITLE PRINT CHAR                                             A  X
  2304 				; ==========================================================================
  2305 				; Write bytes 1 to 6 (skipping 0 and 8) of the character from an internal 
  2306 				; character code into the right side Title buffer at a designated position.
  2307 				; The position is byte aligned.  Thanks to 2 color graphics mode there is
  2308 				; no fancy bit twiddling to do pixel placement. Charset bitmap and graphics 
  2309 				; bitmap are the same.
  2310 				;
  2311 				; Uses MaintPointer2 for character pointer.
  2312 				; Uses SAVEA temporarily.
  2313 				;
  2314 				; A = Internal Character Code
  2315 				; X = position in screen Right text buffer.  0 to 9.
  2316 				; 
  2317 				; Registers saved prior to work.
  2318 				; --------------------------------------------------------------------------
  2319
  2320 3A18			TitlePrintChar
  2321
  2322 3A18 85 FD			sta SAVEA ; save A for routine.
  2323
  2324 3A1A				mRegSave  ; Preserve all regs on stack so routine does not affect caller.
Macro: MREGSAVE [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/macros.asm]
     1 3A1A 08				PHP 
     1 3A1B 48				PHA 
     2 3A1C 98				TYA 
     3 3A1D 48				PHA 
     4 3A1E 8A				TXA 
     5 3A1F 48				PHA 
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03ScreenGfx.asm
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03ScreenGfx.asm
  2325
  2326 3A20 A9 00			lda #0
  2327 3A22 85 A5			sta MainPointer2
  2328 3A24 85 A6			sta MainPointer2+1
  2329
  2330 3A26 A5 FD			lda SAVEA
  2331
  2332 					; MainPointer2 = A * 8
  2333 3A28 0A				asl
  2334 3A29 26 A6			rol MainPointer2+1
  2335 3A2B 0A				asl
  2336 3A2C 26 A6			rol MainPointer2+1
  2337 3A2E 0A				asl
  2338 3A2F 26 A6			rol MainPointer2+1
  2339 3A31 85 A5			sta MainPointer2
  2340
  2341 					; MainPointer2+1  += $e0 ; Or maybe use the redefined set?
  2342 3A33 18				clc
  2343 3A34 A9 E0			lda #$E0
  2344 3A36 65 A6			adc MainPointer2+1
  2345 3A38 85 A6			sta MainPointer2+1
  2346
  2347 					; Copy middle 6 bytes from character set to screen memory.
  2348 3A3A A0 01			ldy #1
  2349 3A3C B1 A5			lda (MainPointer2),y
  2350 3A3E 9D 4A 48			sta TITLE_RIGHT,x
  2351 3A41 C8				iny
  2352 3A42 B1 A5			lda (MainPointer2),y
  2353 3A44 9D 5E 48			sta TITLE_RIGHT+20,x
  2354 3A47 C8				iny
  2355 3A48 B1 A5			lda (MainPointer2),y
  2356 3A4A 9D 72 48			sta TITLE_RIGHT+40,x
  2357 3A4D C8				iny
  2358 3A4E B1 A5			lda (MainPointer2),y
  2359 3A50 9D 86 48			sta TITLE_RIGHT+60,x
  2360 3A53 C8				iny
  2361 3A54 B1 A5			lda (MainPointer2),y
  2362 3A56 9D 9A 48			sta TITLE_RIGHT+80,x
  2363 3A59 C8				iny
  2364 3A5A B1 A5			lda (MainPointer2),y
  2365 3A5C 9D AE 48			sta TITLE_RIGHT+100,x
  2366
  2367 3A5F				mRegRestore
Macro: MREGRESTORE [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/macros.asm]
     1 3A5F 68				PLA 
     2 3A60 AA				TAX 
     3 3A61 68				PLA 
     4 3A62 A8				TAY 
     5 3A63 68				PLA 
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03ScreenGfx.asm
     3 3A64 28				PLP 
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03ScreenGfx.asm
  2368
  2369 3A65 60				rts
  2370
  2371
  2372 				; ==========================================================================
  2373 				; TITLE SET ORIGIN                                            
  2374 				; ==========================================================================
  2375 				; For the Title display, wait for the scan line to be below the title 
  2376 				; before changing the LMS values to avoid weirdness on display.
  2377 				; Set All Display List LMS to the Left Side buffer. Reset Title HSCROL.
  2378 				; This is called before scrolling from right to left. 
  2379 				; --------------------------------------------------------------------------
  2380
  2381 3A66			TitleSetOrigin
  2382
  2383 3A66 20 A6 3A			jsr TitleWaitForScanLine88 ; Be sure the beam passed the title. 
  2384
  2385 3A69 A2 05			ldx #5
  2386
  2387 3A6B			bTSO_Loop
  2388 3A6B BC 17 39			ldy TITLE_LMS_OFFSET,x  ; Get LMS offset
  2389
  2390 3A6E BD 1D 39			lda TITLE_LMS_ORIGIN,x  ; Get low byte for this line of the scrolling buffer
  2391
  2392 3A71 99 0C 46			sta TT_LMS0,y           ; Update LMS with low byte to TITLE. 
  2393
  2394 3A74 CA				dex                     ; next line
  2395 3A75 10 F4			bpl bTSO_Loop           ; Reached the end?
  2396
  2397 3A77 A2 00			ldx #0
  2398 3A79 86 B7			stx TitleHSCROL         ; Zero the fine scroll while we're here
  2399
  2400 3A7B 60				rts
  2401
  2402
  2403 				; ==========================================================================
  2404 				; TITLE COPY RIGHT TO LEFT GRAPHICS                                             
  2405 				; ==========================================================================
  2406 				; Copy data on the right side of the buffer to the left side, so 
  2407 				; the scrolling can be reset to the origin. 
  2408 				; --------------------------------------------------------------------------
  2409
  2410 3A7C			TitleCopyRightToLeftGraphics
  2411
  2412 3A7C A2 09			ldx #9
  2413
  2414 3A7E			bTCRTLG_Loop
  2415 3A7E BD 4A 48			lda TITLE_RIGHT,x
  2416 3A81 9D 40 48			sta TITLE_LEFT,x
  2417 3A84 BD 5E 48			lda TITLE_RIGHT+20,x
  2418 3A87 9D 54 48			sta TITLE_LEFT+20,x
  2419 3A8A BD 72 48			lda TITLE_RIGHT+40,x
  2420 3A8D 9D 68 48			sta TITLE_LEFT+40,x
  2421 3A90 BD 86 48			lda TITLE_RIGHT+60,x
  2422 3A93 9D 7C 48			sta TITLE_LEFT+60,x
  2423 3A96 BD 9A 48			lda TITLE_RIGHT+80,x
  2424 3A99 9D 90 48			sta TITLE_LEFT+80,x
  2425 3A9C BD AE 48			lda TITLE_RIGHT+100,x
  2426 3A9F 9D A4 48			sta TITLE_LEFT+100,x
  2427
  2428 3AA2 CA				dex
  2429 3AA3 10 D9			bpl bTCRTLG_Loop
  2430
  2431 3AA5 60				rts
  2432
  2433
  2434 				; ==========================================================================
  2435 				; TITLE WAIT FOR SCAN LINE 88                                             
  2436 				; ==========================================================================
  2437 				; Wait to start changes to the Title graphics until after the electron beam
  2438 				; passes the title block.  This should prevent visible tearing or glitches 
  2439 				; while updating LMS or actual pixel values. 
  2440 				; --------------------------------------------------------------------------
  2441
  2442 3AA6			TitleWaitForScanLine88
  2443
  2444 3AA6 AD 0B D4			lda VCOUNT                 ; Current electron bean scan line
  2445 3AA9 C9 2C			cmp #44                    ; scan line 88 / 2 should be ok.
  2446 3AAB 90 F9			bcc TitleWaitForScanLine88 ; Loop until scan line after the Title.
  2447
  2448 3AAD 60				rts
  2449
  2450
  2451 				;==============================================================================
  2452 				; P R E S S   J O Y S T I C K   B U T T O N   P R O M P T
  2453 				;==============================================================================
  2454
  2455 				; ==========================================================================
  2456 				; HIDE BUTTON PROMPT                                                   A
  2457 				; ==========================================================================
  2458 				; Tell the VBI to shut off the prompt.
  2459 				;
  2460 				; Uses A.   Preserves original value, so caller is not affected.
  2461 				; --------------------------------------------------------------------------
  2462
  2463 3AAE			HideButtonPrompt
  2464
  2465 3AAE 48				pha                     ; Save whatever is here.
  2466
  2467 3AAF A9 00			lda #0                  ; 0 == off
  2468 3AB1 85 DB			sta EnablePressAButton  ; Tell VBI this is off.
  2469
  2470 3AB3 68				pla                     ; Get A back.
  2471
  2472 3AB4 60				rts                     ; bye.  Are there enough comments here?
  2473
  2474
  2475 				;==============================================================================
  2476 				; TOGGLE PRESS A BUTTON STATE 
  2477 				;==============================================================================
  2478 				; Flip the fade up/fade down state.
  2479
  2480 3AB5			TogglePressAButtonState
  2481
  2482 3AB5 A5 DC			lda PressAButtonState    ; Get button state
  2483 3AB7 49 FF			eor #$FF                 ; Invert the value
  2484 3AB9 85 DC			sta PressAButtonState    ; Save new value.
  2485
  2486 3ABB 60				rts
  2487
  2488
  2489 				;==============================================================================
  2490 				; TOGGLE BUTTON PROMPT
  2491 				;==============================================================================
  2492 				; Fade the prompt colors up and down. 
  2493 				;
  2494 				; PressAButtonState...
  2495 				; If  0, then fading background down to dark.  (and text light)  
  2496 				; If  1, then fading background up to light  (and text dark) 
  2497 				; When background reaches 0 luminance change the color.
  2498 				;
  2499 				; On entry, the first choice may end up being black/white.  
  2500 				; The code generally tries to exclude black/white, but on 
  2501 				; entry this may occur depending on prior state. (fadeouts, etc.)
  2502 				;
  2503 				; A  is used for background color
  2504 				; X  is used for text color.
  2505 				; --------------------------------------------------------------------------
  2506
  2507 3ABC			ToggleButtonPrompt
  2508
  2509 3ABC A9 03			lda #BLINK_SPEED            ; Text Fading speed for prompt
  2510 3ABE 85 DD			sta PressAButtonFrames      ; Reset the frame counter.
  2511
  2512 3AC0 A5 DC			lda PressAButtonState       ; Up or down?
  2513 3AC2 D0 1B			bne PromptFadeUp            ; >0 == up.
  2514
  2515 					; Prompt Fading the background down.
  2516 3AC4 A5 DE			lda PressAButtonColor       ; Get the current background color.
  2517 3AC6 29 0F			AND #$0F                    ; Look at only the luminance.
  2518 3AC8 D0 10			bne RegularPromptFadeDown   ; Not 0 yet, do a normal job on it.
  2519
  2520 3ACA			SetNewPromptColor
  2521 3ACA AD 0A D2			lda RANDOM                  ; A random color and then prevent same 
  2522 3ACD 45 DE			eor PressAButtonColor         ; value by chewing on it with the original color.
  2523 3ACF 29 F0			and #$F0                    ; Mask out the luminance for Dark.
  2524 3AD1 F0 F7			beq SetNewPromptColor       ; Do again if black/color 0 turned up
  2525 3AD3 85 DE			sta PressAButtonColor       ; Set background.
  2526 3AD5 20 B5 3A			jsr TogglePressAButtonState ; Change fading mode to up (1)
  2527 3AD8 D0 13			bne SetTextAsInverse        ; Text Brightness inverse from the background
  2528
  2529 3ADA			RegularPromptFadeDown
  2530 3ADA C6 DE			dec PressAButtonColor       ; Subtract 1 from the color (which is the luminance)
  2531 3ADC 4C ED 3A			jmp SetTextAsInverse        ; And reset the text to accordingly.
  2532
  2533 3ADF			PromptFadeUp
  2534 3ADF A5 DE			lda PressAButtonColor
  2535 3AE1 29 0F			AND #$0F                    ; Look at only the luminance.
  2536 3AE3 C9 0F			cmp #$0F                    ; Is it is at max luminance now?
  2537 3AE5 D0 04			bne RegularPromptFadeUp     ; No, do the usual fade.
  2538
  2539 3AE7 20 B5 3A			jsr TogglePressAButtonState ; Change fading mode to down.
  2540 3AEA 60				rts
  2541
  2542 3AEB			RegularPromptFadeUp
  2543 3AEB E6 DE			inc PressAButtonColor       ; Add 1 to the color (which is the luminance)
  2544 					; and fall into setting the text luminance setup....
  2545
  2546 3AED			SetTextAsInverse  ; Make the text luminance the opposite of the background.
  2547 3AED A5 DE			lda PressAButtonColor       ; Background color...
  2548 3AEF 49 0F			eor #$0F                    ; Not (!) the background color's luminance.
  2549 3AF1 85 DF			sta PressAButtonText        ; Use as the text's luminance.
  2550
  2551 3AF3 60				rts
  2552
  2553
  2554 				;==============================================================================
  2555 				; RUN PROMPT FOR BUTTON
  2556 				;==============================================================================
  2557 				; Maintain blinking timer.
  2558 				; Update/blink text on line 23.
  2559 				; Return 0/BEQ when the any key is not pressed.
  2560 				; Return !0/BNE when the any key is pressed.
  2561 				;
  2562 				; On Exit:
  2563 				; A  contains key press.
  2564 				; CPU flags are comparison of key value to $FF which means no key press.
  2565 				; --------------------------------------------------------------------------
  2566
  2567 3AF4			RunPromptForButton
  2568
  2569 3AF4 A9 01			lda #1
  2570 3AF6 85 DB			sta EnablePressAButton  ; Tell VBI to the prompt flashing is enabled.
  2571
  2572 3AF8 20 9E 28			jsr CheckInput          ; Get input. Non Zero means there is input.
  2573 3AFB 29 10			and #%00010000          ; Strip it down to only the joystick button.
  2574 3AFD F0 05			beq ExitRunPrompt       ; If 0, then do not play sound.
  2575
  2576 3AFF 20 D6 31			jsr PlayTink            ; Button pressed. Set Pokey channel 2 to tink sound.
  2577
  2578 3B02 A9 10			lda #%00010000          ; Set the button is pressed.
  2579
  2580 3B04			ExitRunPrompt
  2581
  2582 3B04 60				rts
  2583
  2584
  2585 				;==============================================================================
  2586 				; P L A Y E R / M I S S I L E   G R A P H I C S
  2587 				;==============================================================================
  2588 				; Game-specific Shapes:
  2589 				; SHAPE_OFF   = 0
  2590 				; SHAPE_FROG  = 1
  2591 				; SHAPE_SPLAT = 2
  2592 				; SHAPE_TOMB  = 3
  2593
  2594 				; ==========================================================================
  2595 				; SET SPLATTERED ON SCREEN
  2596 				; ==========================================================================
  2597 				; Show the splattered frog image on the screen...
  2598 				;
  2599 				; This does not bother changing the FrogUpdate for the VBI, since 
  2600 				; this activity should only occur when frog animation is already 
  2601 				; underway.
  2602 				; --------------------------------------------------------------------------
  2603
  2604 3B05			SetSplatteredOnScreen
  2605
  2606 3B05 A9 02			lda #SHAPE_SPLAT
  2607 3B07 85 87			sta FrogNewShape
  2608
  2609 3B09 60				rts
  2610
  2611
  2612 				; ==========================================================================
  2613 				; SET FROG ON SCREEN
  2614 				; ==========================================================================
  2615 				; Show the frog image on the screen...
  2616 				;
  2617 				; Set default eyeball shape.  
  2618 				; Enable updates for the VBI.
  2619 				; Write the Frog character into screen memory.
  2620 				; --------------------------------------------------------------------------
  2621
  2622 3B0A			SetFrogOnScreen
  2623
  2624 3B0A A9 01			lda #SHAPE_FROG
  2625 3B0C 85 87			sta FrogNewShape ; Set new shape
  2626 3B0E A9 01			lda #1
  2627 3B10 85 BB			sta FrogEyeball  ; Set default eyeball shape (1 is default/centered)
  2628
  2629 3B12 85 88			sta FrogUpdate   ; and finally enable VBI to do P/M redraw. (>0 is ON)
  2630
  2631 3B14 60				rts
  2632
  2633
  2634 				; ==========================================================================
  2635 				; REMOVE FROG ON SCREEN
  2636 				; ==========================================================================
  2637 				; Remove the frog from the screen...
  2638 				;
  2639 				; VBI will update other values, and the shape ID.
  2640 				; --------------------------------------------------------------------------
  2641
  2642 3B15			RemoveFrogOnScreen
  2643
  2644 3B15 A9 FF			lda #$FF           ; (<0 is shutdown)
  2645 3B17 85 88			sta FrogUpdate     ; Signal VBI to erase and do not redraw. 
  2646
  2647 3B19 60				rts
  2648
  2649
  2650 				;==============================================================================
  2651 				;												PmgInit  A  X  Y
  2652 				;==============================================================================
  2653 				; One-time setup tasks to do Player/Missile graphics.
  2654 				; -----------------------------------------------------------------------------
  2655
  2656 3B1A			libPmgInit
  2657
  2658 3B1A 20 53 3B			jsr libPmgAllZero  ; get all Players/Missiles off screen, etc.
  2659 					
  2660 					; clear all bitmap images
  2661 3B1D 20 6C 3B			jsr libPmgClearBitmaps
  2662
  2663 					; Load text labels into P/M memory
  2664 3B20 20 9F 3B			jsr LoadPMGTextLines
  2665
  2666 					; Tell ANTIC where P/M memory is located for DMA to GTIA
  2667 3B23 A9 58			lda #>PMADR
  2668 3B25 8D 07 D4			sta PMBASE
  2669
  2670 					; Enable GTIA to accept DMA to the GRAFxx registers.
  2671 3B28 A9 03			lda #ENABLE_PLAYERS|ENABLE_MISSILES
  2672 3B2A 8D 1D D0			sta GRACTL
  2673
  2674 					; Set all the ANTIC screen controls and DMA options.
  2675 3B2D A9 3E			lda #ENABLE_DL_DMA|PM_1LINE_RESOLUTION|ENABLE_PM_DMA|PLAYFIELD_WIDTH_NORMAL
  2676 3B2F 8D 2F 02			sta SDMCTL
  2677
  2678 					; Ordinarily, GPRIOR would be set here.
  2679 					; However, GTIA GPRIOR varies by Display.
  2680 					; The VBI will manage the values based on the current Display List.
  2681
  2682 3B32 A2 01			ldx #SHAPE_FROG ; Frog Shape
  2683 3B34 20 82 3B			jsr libPmgSetColors
  2684
  2685 3B37 60				rts 
  2686
  2687
  2688 				;==============================================================================
  2689 				;											SetPmgHPOSZero  A  X
  2690 				;==============================================================================
  2691 				; Zero the hardware HPOS registers.
  2692 				;
  2693 				; Useful for DLI which needs to remove Players from the screen.
  2694 				; With no other changes (i.e. the size,) this is sufficient to remove 
  2695 				; visibility for all Player/Missile overlay objects 
  2696 				; -----------------------------------------------------------------------------
  2697
  2698 3B38			libSetPmgHPOSZero
  2699
  2700 3B38 A9 00			lda #$00                ; 0 position
  2701
  2702 3B3A 8D 00 D0			sta HPOSP0 ; Player positions 0, 1, 2, 3
  2703 3B3D 8D 01 D0			sta HPOSP1
  2704 3B40 8D 02 D0			sta HPOSP2
  2705 3B43 8D 03 D0			sta HPOSP3
  2706 3B46 8D 04 D0			sta HPOSM0 ; Missile positions 0, 1, 2, 3
  2707 3B49 8D 05 D0			sta HPOSM1
  2708 3B4C 8D 06 D0			sta HPOSM2
  2709 3B4F 8D 07 D0			sta HPOSM3
  2710
  2711 3B52 60				rts
  2712
  2713
  2714 				;==============================================================================
  2715 				;											PmgAllZero  A  X
  2716 				;==============================================================================
  2717 				; Simple hardware reset of all Player/Missile registers.
  2718 				; Typically used only at program startup to zero everything
  2719 				; and prevent any screen glitchiness on startup.
  2720 				;
  2721 				; Reset all Players and Missiles horizontal positions to 0, so
  2722 				; that none are visible no matter the size or bitmap contents.
  2723 				; Zero all colors.
  2724 				; Also reset sizes to zero.
  2725 				; -----------------------------------------------------------------------------
  2726
  2727 3B53			libPmgAllZero
  2728
  2729 3B53 20 38 3B			jsr libSetPmgHPOSZero   ; Sets all HPOS off screen.
  2730
  2731 3B56 A9 00			lda #$00                ; 0 position
  2732 3B58 A2 03			ldx #$03                ; four objects, 3 to 0
  2733
  2734 3B5A			bAZ_LoopZeroPMSpecs
  2735 3B5A 9D 08 D0			sta SIZEP0,x            ; Player width 3, 2, 1, 0
  2736 3B5D 9D C0 02			sta PCOLOR0,x           ; And black the colors.
  2737 3B60 CA				dex
  2738 3B61 10 F7			bpl bAZ_LoopZeroPMSpecs
  2739
  2740 3B63 8D 0C D0			sta SIZEM
  2741
  2742 3B66 A9 01			lda #[GTIA_MODE_DEFAULT|%0001] ; Default priority 
  2743 3B68 8D 6F 02			sta GPRIOR
  2744
  2745 3B6B 60				rts
  2746
  2747
  2748 				;==============================================================================
  2749 				;											PmgClearBitmaps  A  X
  2750 				;==============================================================================
  2751 				; Zero the bitmaps for all players and missiles
  2752 				; 
  2753 				; Try to make this called only once at game initialization.
  2754 				; All other P/M  use should be orderly and clean up after itself.
  2755 				; Residual P/M pixels are verboten.
  2756 				; -----------------------------------------------------------------------------
  2757
  2758 3B6C			libPmgClearBitmaps
  2759
  2760 3B6C A9 00			lda #$00
  2761 3B6E AA				tax      ; count 0 to 255.
  2762
  2763 3B6F			bCB_Loop
  2764 3B6F 9D 00 5B			sta MISSILEADR,x  ; Missiles
  2765 3B72 9D 00 5C			sta PLAYERADR0,x  ; Player 0
  2766 3B75 9D 00 5D			sta PLAYERADR1,x  ; Player 1
  2767 3B78 9D 00 5E			sta PLAYERADR2,x  ; Player 2
  2768 3B7B 9D 00 5F			sta PLAYERADR3,x  ; Player 3
  2769 3B7E E8				inx
  2770 3B7F D0 EE			bne bCB_Loop      ; Count 1 to 255, then 0 breaks out of loop
  2771
  2772 3B81 60				rts
  2773
  2774
  2775 				;==============================================================================
  2776 				;											PmgSetColors  A  X
  2777 				;==============================================================================
  2778 				; Load the P0-P3 colors based on shape identity.
  2779 				; 
  2780 				; X == SHAPE Identify  0 (off), 1, 2, 3...
  2781 				; -----------------------------------------------------------------------------
  2782
  2783 3B82			libPmgSetColors
  2784
  2785 3B82 8A				txa   ; Object number
  2786 3B83 0A				asl   ; Times 2
  2787 3B84 0A				asl   ; Times 4
  2788 3B85 AA				tax   ; Back into index for referencing from table.
  2789
  2790 3B86 BD BA 58			lda BASE_PMCOLORS_TABLE,x    ; Get color associated to object                 
  2791 3B89 8D 90 51			sta COLPM0_TABLE+2           ; Stuff in the Player color registers.
  2792
  2793 3B8C BD BB 58			lda BASE_PMCOLORS_TABLE+1,x
  2794 3B8F 8D 93 51			sta COLPM1_TABLE+2
  2795
  2796 3B92 BD BC 58			lda BASE_PMCOLORS_TABLE+2,x
  2797 3B95 8D 96 51			sta COLPM2_TABLE+2
  2798
  2799 3B98 BD BD 58			lda BASE_PMCOLORS_TABLE+3,x
  2800 3B9B 8D 99 51			sta COLPM3_TABLE+2
  2801
  2802 3B9E 60				rts
  2803
  2804
  2805 				; ==========================================================================
  2806 				; LOAD PMG TEXT LINES                                                 A  X  
  2807 				; ==========================================================================
  2808 				; Load the Text labels for the the scores, lives, and saved frogs into 
  2809 				; the Player/Missile memory.
  2810 				; --------------------------------------------------------------------------
  2811
  2812 = 0018			PMGLABEL_OFFSET=24
  2813
  2814 3B9F			LoadPmgTextLines
  2815
  2816 3B9F A2 0E			ldx #14
  2817
  2818 3BA1			bLPTL_LoadBytes
  2819 3BA1 BD CA 58			lda P0TEXT_TABLE,x
  2820 3BA4 9D 18 5C			sta PLAYERADR0+PMGLABEL_OFFSET,x
  2821 					
  2822 3BA7 BD D9 58			lda P1TEXT_TABLE,x
  2823 3BAA 9D 18 5D			sta PLAYERADR1+PMGLABEL_OFFSET,x
  2824 					
  2825 3BAD BD E8 58			lda P2TEXT_TABLE,x
  2826 3BB0 9D 18 5E			sta PLAYERADR2+PMGLABEL_OFFSET,x
  2827 					
  2828 3BB3 BD F7 58			lda P3TEXT_TABLE,x
  2829 3BB6 9D 18 5F			sta PLAYERADR3+PMGLABEL_OFFSET,x
  2830 					
  2831 3BB9 BD 06 59			lda MTEXT_TABLE,x
  2832 3BBC 9D 18 5B			sta MISSILEADR+PMGLABEL_OFFSET,x
  2833
  2834 3BBF CA				dex
  2835 3BC0 10 DF			bpl bLPTL_LoadBytes
  2836
  2837 3BC2 60				rts
  2838
  2839
  2840 				;==============================================================================
  2841 				;											SetPmgAllZero  A  X
  2842 				;==============================================================================
  2843 				; Zero the table entries for the animated object on screen.
  2844 				;
  2845 				; -----------------------------------------------------------------------------
  2846
  2847 3BC3			SetPmgAllZero
  2848
  2849 3BC3 A9 00			lda #$00            ; 0 position
  2850
  2851 3BC5 8D 90 51			sta COLPM0_TABLE+2
  2852 3BC8 8D 93 51			sta COLPM1_TABLE+2
  2853 3BCB 8D 96 51			sta COLPM2_TABLE+2
  2854 3BCE 8D 99 51			sta COLPM3_TABLE+2
  2855 					
  2856 3BD1 8D 9C 51			sta SIZEP0_TABLE+2
  2857 3BD4 8D 9C 51			sta SIZEP0_TABLE+2
  2858 3BD7 8D 9C 51			sta SIZEP0_TABLE+2
  2859 3BDA 8D 9C 51			sta SIZEP0_TABLE+2
  2860 3BDD 8D A8 51			sta SIZEM_TABLE+2   ; and Missile size 3, 2, 1, 0
  2861 					
  2862 3BE0 8D AB 51			sta HPOSP0_TABLE+2
  2863 3BE3 8D AE 51			sta HPOSP1_TABLE+2
  2864 3BE6 8D B1 51			sta HPOSP2_TABLE+2
  2865 3BE9 8D B4 51			sta HPOSP3_TABLE+2
  2866 					
  2867 3BEC 8D B7 51			sta HPOSM0_TABLE+2
  2868 3BEF 8D BA 51			sta HPOSM1_TABLE+2
  2869 3BF2 8D BD 51			sta HPOSM2_TABLE+2
  2870 3BF5 8D C0 51			sta HPOSM3_TABLE+2
  2871
  2872 3BF8 A9 01			lda #[GTIA_MODE_DEFAULT|%0001]
  2873 3BFA 8D C3 51			sta PRIOR_TABLE+2
  2874
  2875 3BFD 60				rts
  2876
  2877
  2878 				;==============================================================================
  2879 				;														CopyPmgBase  A  Y
  2880 				;==============================================================================
  2881 				; Bulk copy the base values for the current display to the working table.
  2882 				;
  2883 				; -----------------------------------------------------------------------------
  2884
  2885 3BFE			CopyPmgBase
  2886
  2887 3BFE A0 35			ldy #53
  2888
  2889 3C00			bCPB_loop
  2890 3C00 B1 9E			lda (BasePmgAddr),y
  2891 3C02 99 8E 51			sta PLAYER_MISSILE_BASE_SPECS,y
  2892 3C05 88				dey
  2893 3C06 10 F8			bpl bCPB_loop
  2894
  2895 3C08 60				rts
  2896
  2897
  2898 				; ==========================================================================
  2899 				; WOBBLE DE WOBBLE                                                 A  X  
  2900 				; ==========================================================================
  2901 				; Frog (etc) Gymnastics.
  2902 				; On the title screen the frog moves in a sine path from  +88 to +160.
  2903 				; This value is centered at 128, the middle of the screen.
  2904 				; The data from the sine generator is 0 to $80  (0 to 80).
  2905 				; The center of the screen should be 128,128. 
  2906 				; So, the value to add to center the sine motion on the screen is:
  2907 				; 128 - (80 / 2) ==  88. 
  2908 				; Minus 4 for the width/height of the Frog == 84
  2909 				; Add that to current values to position the frog.
  2910 				; The rate of updates between X and Y values differs, so the 
  2911 				; frog does not travel in a circle, but a distorted arc.
  2912 				; The frog Y center position is offset slightly differently from 
  2913 				; the X Center.
  2914 				; This same code is used for the Tomb/gravestone on the GameOver screen.
  2915 				;
  2916 				; Uses AnimateFrame2 and AnimateFrames3
  2917 				; --------------------------------------------------------------------------
  2918
  2919 3C09			WOBBLE_SINE_TABLE
  2920 3C09 28 2C 30 34 37 3B + 	.by $28 $2c $30 $34 $37 $3b $3e $41 
  2921 3C11 44 47 49 4B 4D 4E + 	.by $44 $47 $49 $4b $4d $4e $4f $50 
  2922 3C19 50 50 4F 4E 4D 4B + 	.by $50 $50 $4f $4e $4d $4b $49 $47 
  2923 3C21 44 41 3E 3B 37 34 + 	.by $44 $41 $3e $3b $37 $34 $30 $2c 
  2924 3C29 28 24 20 1C 19 15 + 	.by $28 $24 $20 $1c $19 $15 $12 $0f 
  2925 3C31 0C 09 07 05 03 02 + 	.by $0c $09 $07 $05 $03 $02 $01 $00 
  2926 3C39 00 00 01 02 03 05 + 	.by $00 $00 $01 $02 $03 $05 $07 $09 
  2927 3C41 0C 0F 12 15 19 1C + 	.by $0c $0f $12 $15 $19 $1c $20 $24 
  2928
  2929 3C49			WobbleDeWobble
  2930
  2931 3C49 A5 B2			lda AnimateFrames3        ; Get the countdown timer for X movement.
  2932 3C4B D0 07			bne CheckOnAnimateY      ; Not 0.  No X movement.  Go try Y movement.
  2933
  2934 3C4D A9 02			lda #WOBBLEX_SPEED       ; Reset the X movement timer.
  2935 3C4F 85 B2			sta AnimateFrames3        
  2936
  2937 3C51 20 60 3C			jsr WobbleDeWobbleX_Now  ; Do the actual X wobble work.
  2938
  2939 3C54			CheckOnAnimateY
  2940 3C54 A5 B1			lda AnimateFrames2       ; Get the countdown timer for Y movement.
  2941 3C56 D0 07			bne EndWobbleDeWobble    ; Not 0.  No Y movement.  Depart.
  2942
  2943 3C58 A9 03			lda #WOBBLEY_SPEED       ; Reset the Y movement timer.
  2944 3C5A 85 B1			sta AnimateFrames2
  2945
  2946 3C5C 20 70 3C			jsr WobbleDeWobbleY_Now  ; Do the actual X wobble work.
  2947
  2948 3C5F			EndWobbleDeWobble
  2949 3C5F 60				rts
  2950
  2951 				; Working parts of the Wobble, callable by others.
  2952
  2953 3C60			WobbleDeWobbleX_Now          ; jsr here to force wobble coordinates
  2954
  2955 3C60 E6 94			inc WobbleX              ; Increment Index for X offset
  2956 3C62 A5 94			lda WobbleX              ; Get new X index
  2957 3C64 29 3F			and #$3F                 ; Limit to 0 to 63.
  2958 					; Remarkably, the Base-2-ness of the size plus the AND above make it unecessary to update WobbleX.
  2959 3C66 AA				tax                      ; X = Index for X movement
  2960 3C67 BD 09 3C			lda WOBBLE_SINE_TABLE,x  ; Get current path value for Horizontal placement.
  2961 3C6A 18				clc
  2962 3C6B 65 96			adc WobOffsetX           ; Add to offset for placement.
  2963 3C6D 85 85			sta FrogNewPMX           ; Tell VBI where to draw the object.
  2964
  2965 3C6F 60				rts
  2966
  2967 				; Working parts of the Wobble, callable by others.
  2968
  2969 3C70			WobbleDeWobbleY_Now          ; jsr here to force wobble coordinates
  2970
  2971 3C70 E6 95			inc WobbleY              ; Increment Index for Y offset.
  2972 3C72 A5 95			lda WobbleY              ; Get new Y index
  2973 3C74 29 3F			and #$3F                 ; Limit to 0 to 63.
  2974 					; Remarkably, the Base-2-ness of the size plus the AND above make it unnecessary to update WobbleY.
  2975 3C76 AA				tax                      ; X = Index for Y movement
  2976 3C77 BD 09 3C			lda WOBBLE_SINE_TABLE,x  ; Get current path value for Vertical placement.
  2977 3C7A 18				clc
  2978 3C7B 65 97			adc WobOffsetY           ; Add to offset for placement.
  2979 3C7D 85 83			sta FrogNewPMY           ; Tell VBI where to draw the object.
  2980
  2981 3C7F 60				rts
  2982
  2983
  2984 				;==============================================================================
  2985 				;											CheckRidetheBoat    A 
  2986 				;==============================================================================
  2987 				; Collision processing the prior frame results is utterly trivial.
  2988 				;
  2989 				; The caller should make this check for collisions only when the  
  2990 				; Frog is in a Boat row.
  2991 				;
  2992 				; Here's how life and death works:
  2993 				; As long as a frog part (Player 0 or 1) is touching the colored, horizontal 
  2994 				; lines (COLPF2) on the boat, then the frog lives.
  2995 				;
  2996 				; This is easy, because the Atari identifies exactly what playfield 
  2997 				; color is involved in the collision.  
  2998 				; On other systems we're lucky to get a bit that says a sprite collided 
  2999 				; with a pixel. Then we would have to do a series of coordinate bounding 
  3000 				; box checks to see if the frog is in a safe position on a boat.
  3001 				; 
  3002 				; In the event of a rare border condition where the frog lost the collision  
  3003 				; attachment on the past frame AND the player has directed the frog move to 
  3004 				; the next row in the coming frame, then grace is applied to ignore the 
  3005 				; collision results and keep the frog alive.  
  3006 				;
  3007 				; Output: 
  3008 				; FrogSafety = 0  ; Life
  3009 				; FrogSafety = 1  ; Death
  3010 				; -----------------------------------------------------------------------------
  3011
  3012 3C80			CheckRideTheBoat
  3013
  3014 3C80 A5 89			lda FrogSafety               ; Is the frog already dead ?
  3015 3C82 D0 12			bne ExitCheckRideTheBoat     ; Yes.   No need to check.
  3016
  3017 3C84 AD 04 D0			lda P0PF                     ; Get Player 0 collision with playfield
  3018 3C87 0D 05 D0			ora P1PF                     ; OR with Player 1 collision with playfield
  3019 3C8A 29 04			and #COLPMF2_BIT             ; Keep only the collision with COLPF2 (lines on the boats)
  3020 3C8C D0 08			bne ExitCheckRideTheBoat     ; 1 == touching the lines. Therefore Frog is safe.
  3021
  3022 					; Oops.  The frog is off a boat. 
  3023 					; Frog must die. Unless, the frog must live. :-) 
  3024 					; If the Frog is moving to the next row on the next frame, then 
  3025 					; disregard the collision failure to permit the frog to live.
  3026
  3027 3C8E A5 80			lda FrogRow                  ; Get the current Row number.
  3028 3C90 C5 81			cmp FrogNewRow               ; Is the new Row the same?  
  3029 3C92 D0 02			bne ExitCheckRideTheBoat     ; No.  Life!
  3030
  3031 3C94 E6 89			inc FrogSafety               ; Yes.  Die, Frog, Die!
  3032
  3033 					; The rest of the VBI motion processing will happily drag the frog  
  3034 					; corpse along with the moving boats/water.
  3035 					; It is MAIN's job to change the image to the splattered frog.
  3036
  3037 3C96			ExitCheckRideTheBoat
  3038 3C96 60				rts
  3039
  3040
  3041 				;==============================================================================
  3042 				;											EraseShape  A  X  Y
  3043 				;==============================================================================
  3044 				; Erase current Shape at current position.
  3045 				; -----------------------------------------------------------------------------
  3046
  3047 3C97			EraseShape
  3048
  3049 3C97 A5 86			lda FrogShape          ; Current shape?
  3050 3C99 F0 29			beq bES_ExitEraseShape ; 0 is off. Nothing to Erase.
  3051
  3052 					; Note that if there is animation here is where the frame change 
  3053 					; would be evaluated to be followed by the position check if the 
  3054 					; frame does not change.
  3055
  3056 3C9B A4 88			ldy FrogUpdate         ; If -1, then update/erase is mandatory.
  3057 3C9D 30 0A			bmi bES_Test1
  3058
  3059 3C9F C5 87			cmp FrogNewShape       ; Is it different from the old shape?
  3060 3CA1 D0 06			bne bES_Test1          ; Yes.  Erase is mandatory.
  3061
  3062 3CA3 A4 83			ldy FrogNewPMY         ; Get new position.
  3063 3CA5 C4 82			cpy FrogPMY            ; Is it the same as the old position?
  3064 3CA7 F0 1B			beq bES_ExitEraseShape ; Yes.  Nothing to erase here.
  3065
  3066 3CA9			bES_Test1
  3067 3CA9 C9 01			cmp #SHAPE_FROG
  3068 3CAB D0 06			bne bES_Test2
  3069 3CAD 20 0D 3D			jsr EraseFrog
  3070 3CB0 4C C4 3C			jmp bES_ExitEraseShape
  3071
  3072 3CB3			bES_Test2
  3073 3CB3 C9 02			cmp #SHAPE_SPLAT
  3074 3CB5 D0 06			bne bES_Test3
  3075 3CB7 20 FC 3C			jsr EraseSplat
  3076 3CBA 4C C4 3C			jmp bES_ExitEraseShape
  3077
  3078 3CBD			bES_Test3
  3079 3CBD C9 03			cmp #SHAPE_TOMB
  3080 3CBF D0 03			bne bES_ExitEraseShape
  3081 3CC1 20 E2 3C			jsr EraseTomb
  3082
  3083 				; Do not change FrogShape to FrogNewShape.   
  3084 				; Drawing a new shape will transition New to Current.
  3085 3CC4			bES_ExitEraseShape
  3086 3CC4 A5 86			lda FrogShape  ; return with value for caller.
  3087
  3088 3CC6 60				rts
  3089
  3090
  3091 				;==============================================================================
  3092 				;											EraseGameBorder  A  X  Y
  3093 				;==============================================================================
  3094 				; Erase Shape in Missile memory.
  3095 				; -----------------------------------------------------------------------------
  3096
  3097 = 0029			BORDER_OFFSET=41
  3098
  3099 3CC7			EraseGameBorder
  3100
  3101 3CC7 A9 00			lda #$00
  3102 3CC9 8D B4 51			sta HPOSP3_TABLE+2
  3103 3CCC 8D C0 51			sta HPOSM3_TABLE+2
  3104
  3105 3CCF A2 B2			ldx #178
  3106
  3107 3CD1			bEGB_LoopFillBorder
  3108 3CD1 A9 00			lda #$00
  3109 3CD3 9D 29 5F			sta PLAYERADR3+BORDER_OFFSET,x
  3110 					
  3111 3CD6 BD 29 5B			lda MISSILEADR+BORDER_OFFSET,x
  3112 3CD9 29 3F			and #%00111111
  3113 3CDB 9D 29 5B			sta MISSILEADR+BORDER_OFFSET,x
  3114
  3115 3CDE CA				dex
  3116 3CDF D0 F0			bne bEGB_LoopFillBorder
  3117
  3118 3CE1 60				rts
  3119
  3120
  3121 				;==============================================================================
  3122 				;											EraseTomb  A  X  Y
  3123 				;==============================================================================
  3124 				; Erase Tomb at current position.
  3125 				; -----------------------------------------------------------------------------
  3126
  3127 3CE2			EraseTomb
  3128
  3129 3CE2 A9 00			lda #0
  3130 3CE4 A6 82			ldx FrogPMY      ; Old  Y
  3131 3CE6 A0 16			ldy #22
  3132
  3133 3CE8			bET_LoopErase
  3134 3CE8 9D 00 5C			sta PLAYERADR0,x ; main  1
  3135 3CEB 9D 00 5D			sta PLAYERADR1,x ; main  2
  3136 3CEE 9D 00 5E			sta PLAYERADR2,x ; 
  3137 3CF1 9D 00 5F			sta PLAYERADR3,x ; 
  3138 3CF4 9D 00 5B			sta MISSILEADR,x ; 
  3139 3CF7 E8				inx
  3140 3CF8 88				dey
  3141 3CF9 10 ED			bpl bET_LoopErase
  3142
  3143 3CFB 60				rts
  3144
  3145
  3146 				;==============================================================================
  3147 				;											EraseSplat  A  X  Y
  3148 				;==============================================================================
  3149 				; Erase Splat at current position.
  3150 				; -----------------------------------------------------------------------------
  3151
  3152 3CFC			EraseSplat
  3153
  3154 3CFC A9 00			lda #0
  3155 3CFE A6 82			ldx FrogPMY        ; Old frog Y
  3156 3D00 A0 0A			ldy #10
  3157
  3158 3D02			bES_LoopErase
  3159 3D02 9D 00 5C			sta PLAYERADR0,x   ; splat 1
  3160 3D05 9D 00 5D			sta PLAYERADR1,x   ; splat 2
  3161 3D08 E8				inx
  3162 3D09 88				dey
  3163 3D0A 10 F6			bpl bES_LoopErase
  3164
  3165 3D0C 60				rts
  3166
  3167
  3168 				;==============================================================================
  3169 				;											EraseFrog  A  X  Y
  3170 				;==============================================================================
  3171 				; Erase Frog at current position.
  3172 				; -----------------------------------------------------------------------------
  3173
  3174 3D0D			EraseFrog
  3175
  3176 3D0D A9 00			lda #0
  3177 3D0F A6 82			ldx FrogPMY       ; Old frog Y
  3178 3D11 A0 0A			ldy #10
  3179
  3180 3D13			bEF_LoopErase
  3181 3D13 9D 00 5C			sta PLAYERADR0,x  ; main frog 1
  3182 3D16 9D 00 5D			sta PLAYERADR1,x  ; main frog 2, mouth, pupil
  3183 3D19 9D 00 5E			sta PLAYERADR2,x  ; eyeball
  3184 3D1C E8				inx
  3185 3D1D 88				dey
  3186 3D1E 10 F3			bpl bEF_LoopErase
  3187
  3188 3D20 60				rts
  3189
  3190
  3191 				;==============================================================================
  3192 				;											DrawShape  A  X  Y
  3193 				;==============================================================================
  3194 				; Draw current Shape at current position.
  3195 				; -----------------------------------------------------------------------------
  3196
  3197 3D21			DrawShape
  3198
  3199 3D21 A5 87			lda FrogNewShape
  3200 3D23 F0 2D			beq ExitDrawShape  ; 0 is off.
  3201
  3202 3D25 A4 88			ldy FrogUpdate        ; Is update mandatory?
  3203 3D27 30 29			bmi ExitDrawShape     ; Update is forced off.
  3204 3D29 F0 02			beq bDS_CheckInMotion ; Update is neutral.
  3205 3D2B 10 0A			bpl bDS_Test1         ; FrogUpdate >0 means redraw is required.
  3206 					
  3207 					; Note that if there is animation here is where the frame change 
  3208 					; would be evaluated to be followed by the position check if the 
  3209 					; frame does not change.
  3210
  3211 3D2D			bDS_CheckInMotion
  3212 3D2D C5 86			cmp FrogShape          ; Is it different from the old shape?
  3213 3D2F D0 06			bne bDS_Test1          ; Yes.  Redraw is mandatory.
  3214
  3215 3D31 A4 83			ldy FrogNewPMY         ; Get new position.
  3216 3D33 C4 82			cpy FrogPMY            ; Is it the same as the old position?
  3217 3D35 F0 1B			beq ExitDrawShape      ; Yes.  Nothing to draw here.
  3218
  3219 3D37			bDS_Test1
  3220 3D37 C9 01			cmp #SHAPE_FROG
  3221 3D39 D0 06			bne bDS_Test2
  3222 3D3B 20 A4 3D			jsr DrawFrog
  3223 3D3E 4C 52 3D			jmp ExitDrawShape
  3224
  3225 3D41			bDS_Test2
  3226 3D41 C9 02			cmp #SHAPE_SPLAT
  3227 3D43 D0 06			bne bDS_Test3
  3228 3D45 20 8F 3D			jsr DrawSplat
  3229 3D48 4C 52 3D			jmp ExitDrawShape
  3230
  3231 3D4B			bDS_Test3
  3232 3D4B C9 03			cmp #SHAPE_TOMB
  3233 3D4D D0 03			bne ExitDrawShape
  3234 3D4F 20 68 3D			jsr DrawTomb
  3235
  3236 3D52			ExitDrawShape
  3237 3D52 A5 87			lda FrogNewShape ; return value to caller.
  3238
  3239 3D54 60				rts
  3240
  3241
  3242 				;==============================================================================
  3243 				;											DrawGameBorder  A  X  Y
  3244 				;==============================================================================
  3245 				; Show the black border that masks the left and right sides of the background.
  3246 				;
  3247 				; Draw Shape in Player/Missile memory.
  3248 				; Set color of border to Black.
  3249 				; Set position of Player/Missile.
  3250 				; Set size of Player and Missile.
  3251 				; -----------------------------------------------------------------------------
  3252
  3253 3D55			DrawGameBorder
  3254
  3255 3D55 A2 B2			ldx #178
  3256 3D57			bDGB_LoopFillBorder
  3257 3D57 A9 C0			lda #$C0
  3258 3D59 9D 29 5F			sta PLAYERADR3+BORDER_OFFSET,x
  3259
  3260 3D5C BD 29 5B			lda MISSILEADR+BORDER_OFFSET,x
  3261 3D5F 09 C0			ora #$C0 ; or %11000000
  3262 3D61 9D 29 5B			sta MISSILEADR+BORDER_OFFSET,x
  3263
  3264 3D64 CA				dex
  3265 3D65 D0 F0			bne bDGB_LoopFillBorder
  3266
  3267 3D67 60				rts
  3268
  3269
  3270 				;==============================================================================
  3271 				;											DrawTomb   A  X  Y
  3272 				;==============================================================================
  3273 				; Draw Tomb at new position.
  3274 				; -----------------------------------------------------------------------------
  3275
  3276 3D68			DrawTomb
  3277
  3278 3D68 A6 83			ldx FrogNewPMY            ; New frog Y
  3279 3D6A A0 16			ldy #22
  3280
  3281 3D6C			bDT_LoopDrawTomb
  3282 3D6C B9 47 58			lda PLAYER0_GRAVE_DATA,y
  3283 3D6F 9D 16 5C			sta PLAYERADR0+22,x
  3284
  3285 3D72 B9 5E 58			lda PLAYER1_GRAVE_DATA,y
  3286 3D75 9D 16 5D			sta PLAYERADR1+22,x
  3287
  3288 3D78 B9 75 58			lda PLAYER2_GRAVE_DATA,y
  3289 3D7B 9D 16 5E			sta PLAYERADR2+22,x
  3290
  3291 3D7E B9 8C 58			lda PLAYER3_GRAVE_DATA,y
  3292 3D81 9D 16 5F			sta PLAYERADR3+22,x
  3293
  3294 3D84 B9 A3 58			lda PLAYER5_GRAVE_DATA,y
  3295 3D87 9D 16 5B			sta MISSILEADR+22,x
  3296
  3297 3D8A CA				dex
  3298 3D8B 88				dey
  3299 3D8C 10 DE			bpl bDT_LoopDrawTomb
  3300
  3301 3D8E 60				rts
  3302
  3303
  3304 				;==============================================================================
  3305 				;											DrawSplat   A  X  Y
  3306 				;==============================================================================
  3307 				; Draw SplatteredFrog at new position.
  3308 				; -----------------------------------------------------------------------------
  3309
  3310 3D8F			DrawSplat
  3311
  3312 3D8F A6 83			ldx FrogNewPMY
  3313 3D91 A0 0A			ldy #10
  3314 					
  3315 3D93			bDS_LoopDrawSplatFrog
  3316 3D93 B9 31 58			lda PLAYER0_SPLATTER_DATA,y
  3317 3D96 9D 0A 5C			sta PLAYERADR0+10,x
  3318
  3319 3D99 B9 3C 58			lda PLAYER1_SPLATTER_DATA,y
  3320 3D9C 9D 0A 5D			sta PLAYERADR1+10,x
  3321
  3322 3D9F CA				dex
  3323 3DA0 88				dey
  3324 3DA1 10 F0			bpl bDS_LoopDrawSplatFrog
  3325
  3326 3DA3 60				rts
  3327
  3328
  3329 				;==============================================================================
  3330 				;											DrawFrog  A  X  Y
  3331 				;==============================================================================
  3332 				; Draw Frog at new position.
  3333 				; -----------------------------------------------------------------------------
  3334
  3335 3DA4			DrawFrog
  3336
  3337 3DA4 A6 83			ldx FrogNewPMY            ; New frog Y
  3338 3DA6 A0 0A			ldy #10
  3339
  3340 3DA8			bDF_LoopDrawFrog
  3341 3DA8 B9 00 58			lda PLAYER0_FROG_DATA,y
  3342 3DAB 9D 0A 5C			sta PLAYERADR0+10,x
  3343
  3344 3DAE B9 0B 58			lda PLAYER1_FROG_DATA,y
  3345 3DB1 9D 0A 5D			sta PLAYERADR1+10,x
  3346
  3347 3DB4 CA				dex
  3348 3DB5 88				dey
  3349 3DB6 10 F0			bpl bDF_LoopDrawFrog
  3350
  3351 					; Player 2 is the eyeball whites
  3352 3DB8 A6 83			ldx FrogNewPMY             ; Reload new frog Y
  3353 3DBA A9 EE			lda #$EE
  3354 3DBC 9D 02 5E			sta PLAYERADR2+2,x
  3355 3DBF 9D 03 5E			sta PLAYERADR2+3,x
  3356 3DC2 9D 04 5E			sta PLAYERADR2+4,x
  3357
  3358 					; Player 1 also contains the animated pupil.
  3359 3DC5 A5 BB			lda FrogEyeball            ; What shape is the eye pupil?
  3360 3DC7 0A				asl
  3361 3DC8 0A				asl
  3362 3DC9 A8				tay
  3363
  3364 3DCA B9 21 58			lda PLAYER1_EYE_DATA,y
  3365 3DCD 9D 02 5D			sta PLAYERADR1+2,x
  3366 3DD0 C8				iny
  3367 3DD1 B9 21 58			lda PLAYER1_EYE_DATA,y
  3368 3DD4 9D 03 5D			sta PLAYERADR1+3,x
  3369 3DD7 C8				iny
  3370 3DD8 B9 21 58			lda PLAYER1_EYE_DATA,y
  3371 3DDB 9D 04 5D			sta PLAYERADR1+4,x
  3372
  3373 3DDE 60				rts
  3374
  3375
  3376 				;==============================================================================
  3377 				;											PositionShape  A  X  Y
  3378 				;==============================================================================
  3379 				; Set HPOS coords of the shape parts. 
  3380 				; -----------------------------------------------------------------------------
  3381
  3382 3DDF			PositionShape
  3383
  3384 3DDF A4 87			ldy FrogNewShape       ; Get new shape
  3385 3DE1 C4 86			cpy FrogShape          ; Is it different from the old shape?
  3386 3DE3 D0 06			bne bps_Test0          ; Yes.   Reposition is mandatory.
  3387
  3388 3DE5 A4 85			ldy FrogNewPMX         ; Get new position.
  3389 3DE7 C4 84			cpy FrogPMX            ; Is it the same as the old position?
  3390 3DE9 F0 22			beq ExitPositionShape  ; Yes.  Nothing to draw here.
  3391
  3392 3DEB			bPS_Test0
  3393 3DEB C9 00			cmp #SHAPE_OFF
  3394 3DED D0 03			bne bPS_Test1
  3395 3DEF 4C 0D 3E			jmp ExitPositionShape
  3396
  3397 3DF2			bPS_Test1
  3398 3DF2 C9 01			cmp #SHAPE_FROG
  3399 3DF4 D0 06			bne bPS_Test2
  3400 3DF6 20 33 3E			jsr PositionFrog
  3401 3DF9 4C 0D 3E			jmp ExitPositionShape
  3402
  3403 3DFC			bPS_Test2
  3404 3DFC C9 02			cmp #SHAPE_SPLAT
  3405 3DFE D0 06			bne bPS_Test3
  3406 3E00 20 29 3E			jsr PositionSplat
  3407 3E03 4C 0D 3E			jmp ExitPositionShape
  3408
  3409 3E06			bPS_Test3
  3410 3E06 C9 03			cmp #SHAPE_TOMB
  3411 3E08 D0 03			bne ExitPositionShape
  3412 3E0A 20 10 3E			jsr PositionTomb
  3413
  3414 3E0D			ExitPositionShape
  3415 3E0D A5 87			lda FrogNewShape ; return value to caller.
  3416 3E0F 60				rts
  3417
  3418
  3419 				;==============================================================================
  3420 				;											PositionTomb  A  X  Y
  3421 				;==============================================================================
  3422 				; Move X position.
  3423 				; Set sizes of parts.
  3424 				; -----------------------------------------------------------------------------
  3425
  3426 3E10			PositionTomb
  3427
  3428 3E10 A6 85			ldx FrogNewPMX            ; New frog X...
  3429
  3430 					; Do horizontal repositioning.
  3431 					; Change frog HPOS.  Each part is not at 0 origin, so there are offsets...
  3432
  3433 3E12 8E AB 51			stx HPOSP0_TABLE+2 ; + 0 is shadow on left
  3434 3E15 E8				inx
  3435 3E16 E8				inx
  3436 3E17 8E B7 51			stx HPOSM0_TABLE+2 ; + 2 is p5 left part of tombstone
  3437 3E1A E8				inx
  3438 3E1B E8				inx
  3439 3E1C 8E B4 51			stx HPOSP3_TABLE+2 ; + 4 is part of RIP
  3440 3E1F E8				inx
  3441 3E20 8E B1 51			stx HPOSP2_TABLE+2 ; + 5 is rest of the RIP
  3442 3E23 E8				inx
  3443 3E24 E8				inx
  3444 3E25 8E AE 51			stx HPOSP1_TABLE+2 ; + 7 right side of tombstone
  3445
  3446 3E28 60				rts
  3447
  3448
  3449 				;==============================================================================
  3450 				;											PositionSplat  A  X  Y
  3451 				;==============================================================================
  3452 				; Move X position.
  3453 				; Set sizes of parts.
  3454 				; -----------------------------------------------------------------------------
  3455
  3456 3E29			PositionSplat
  3457
  3458 3E29 A6 85			ldx FrogNewPMX            ; New frog X...
  3459
  3460 					; Do horizontal repositioning.
  3461 					; Change frog HPOS.  Each part is not at 0 origin, so there are offsets...
  3462
  3463 3E2B 8E AB 51			stx HPOSP0_TABLE+2 ; + 0 is splat parts 1
  3464 3E2E E8				inx
  3465 3E2F 8E AE 51			stx HPOSP1_TABLE+2 ; + 1 is splat parts 2
  3466
  3467 3E32 60				rts
  3468
  3469
  3470 				;==============================================================================
  3471 				;											PositionFrog  A  X  Y
  3472 				;==============================================================================
  3473 				; Move X position.
  3474 				; Set sizes of parts.
  3475 				; -----------------------------------------------------------------------------
  3476
  3477 3E33			PositionFrog
  3478
  3479 3E33 A6 85			ldx FrogNewPMX            ; New frog X...
  3480
  3481 					; Do horizontal repositioning.
  3482 					; Change frog HPOS.  Each part is not at 0 origin, so there are offsets...
  3483
  3484 3E35 8E AB 51			stx HPOSP0_TABLE+2 ; + 0 is frog parts 1
  3485 3E38 E8				inx
  3486 3E39 8E AE 51			stx HPOSP1_TABLE+2 ; + 1 is frog parts 2
  3487 3E3C 8E B1 51			stx HPOSP2_TABLE+2 ; + 1 is frog eye iris
  3488
  3489
  3490 3E3F 60				rts
  3491
  3492
  3493 				;==============================================================================
  3494 				; UPDATE SHAPE SPECS                                           A  X  Y
  3495 				;==============================================================================
  3496 				; Set all Current values to the New values.
  3497 				; 
  3498 				; On Exit X is the new shape. Useful if someone wants to call the color update.
  3499 				; -----------------------------------------------------------------------------
  3500
  3501 3E40			UpdateShapeSpecs
  3502
  3503 3E40 A5 85			lda FrogNewPMX       ; New Y coord.
  3504 3E42 85 84			sta FrogPMX
  3505
  3506 3E44 A5 83			lda FrogNewPMY       ; New X coord.
  3507 3E46 85 82			sta FrogPMY 
  3508
  3509 3E48 A5 81			lda FrogNewRow       ; Also new Frog Row.
  3510 3E4A 85 80			sta FrogRow
  3511
  3512 3E4C A6 87			ldx FrogNewShape    ; And the shape.
  3513 3E4E 86 86			stx FrogShape
  3514
  3515 3E50 60				rts
  3516
  3517
  3518 				;==============================================================================
  3519 				;											UpdateShape  A  X  Y
  3520 				;==============================================================================
  3521 				; Complete redisplay of the object/shape.  
  3522 				; Erase old object/shape position if needed.
  3523 				; Load new object/shape into PM Memory at the new position.
  3524 				; Update current position == new position.
  3525 				; Y positioning different from X positioning, since it must reload memory.
  3526 				; Update current shape = new shape.
  3527 				; Frog Update controls parts to do (because Main trying to erase the 
  3528 				; shape is arguing with the VBI)
  3529 				; FrogUpdate 0 = no changes.  
  3530 				;            1 = Any reason to change position... 
  3531 				;           -1 = erase, stop, and no further updates. 
  3532 				; -----------------------------------------------------------------------------
  3533
  3534 3E51			UpdateShape
  3535
  3536 3E51 A5 88			lda FrogUpdate       ; 
  3537 3E53 F0 17			beq ExitUpdateShape  ; 0 == no movement.  skip all.
  3538
  3539 3E55 20 97 3C			jsr EraseShape       ; Remove old shape at the old vertical Y position.
  3540 3E58 A5 88			lda FrogUpdate        
  3541 3E5A 10 0A			bpl bUS_RedrawShape  ; >0 = continue   
  3542
  3543 3E5C A9 00			lda #SHAPE_OFF       ; <0 = stop, so stop doing things after the erase.
  3544 3E5E 85 88			sta FrogUpdate       ; Erased above, therefore stop everything further.
  3545 3E60 85 87			sta FrogNewShape     ; SHAPE_OFF is 0.  Make all shapes off.
  3546 3E62 85 86			sta FrogShape
  3547 3E64 F0 06			beq ExitUpdateShape
  3548
  3549 3E66			bUS_RedrawShape
  3550 3E66 20 21 3D			jsr DrawShape        ; Draw NEW shape at new vertical Y position.
  3551 3E69 20 DF 3D			jsr PositionShape    ; Move shape to new horizontal X position. (and set sizes).
  3552
  3553 3E6C			ExitUpdateShape
  3554 3E6C 20 40 3E			jsr UpdateShapeSpecs ; Commit the new shape and the new X and Y coords.
  3555 					                     ;  UpdateShapeSpecs returns the new shape number in X.
  3556 3E6F 20 82 3B			jsr libPmgSetColors  ; Set colors for this object.  Depends on X = Shape number.
  3557
  3558 3E72 60				rts
  3559
  3560
  3561 				;==============================================================================
  3562 				; PROCESS NEW SHAPE POSITION                                         
  3563 				;==============================================================================
  3564 				; Forcibly clip the new frog positions to the game's playfield area limits.
  3565 				; Call the main routine to redraw the object.
  3566 				; -----------------------------------------------------------------------------
  3567
  3568 3E73			ProcessNewShapePosition
  3569
  3570 3E73 A5 85			lda FrogNewPMX      ; Is the new X different
  3571 3E75 C9 30			cmp #MIN_FROGX      ; Is PM X smaller than the minimum?
  3572 3E77 B0 06			bcs CheckHPOSMax    ; No.  
  3573
  3574 3E79 A9 30			lda #MIN_FROGX      ; Yes.  Reset X
  3575 3E7B 85 85			sta FrogNewPMX      ; to the minimum.
  3576 3E7D D0 08			bne UpdateTheFrog   ; render it.
  3577
  3578 3E7F			CheckHPOSMax
  3579 3E7F C9 C8			cmp #MAX_FROGX+1    ; Is PM X bigger than the maximum?
  3580 3E81 90 04			bcc UpdateTheFrog   ; No.
  3581
  3582 3E83 A9 C7			lda #MAX_FROGX      ; Yes.  Reset X
  3583 3E85 85 85			sta FrogNewPMX      ; to the maximum.
  3584
  3585 3E87			UpdateTheFrog
  3586 3E87 20 51 3E			jsr UpdateShape     ; then FrogPMX == FrogNewPMX. FrogPMY == FrogNewPMY. FrogRow=FrogNewRow.
  3587
  3588 3E8A 60				rts
  3589
   716
   717 				; ==========================================================================
   718 				; Graphics assets.
   719 				; To make sure these won't accidentally cross an ANTIC hardware limit
   720 				; these need to be aligned per ANTIC specs.
   721 				; --------------------------------------------------------------------------
   722
   723 3E8B				icl "Frogger03CharSet.asm"      ; Aligns to 1K and defines CHARACTER_SET
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03CharSet.asm
     1 				; ==========================================================================
     2 				; Pet Frogger
     3 				; (c) November 1983 by John C. Dale, aka Dalesoft
     4 				; for the Commodore Pet 4032
     5 				; ==========================================================================
     6 				; Ported (parodied) to Atari 8-bit computers
     7 				; by Ken Jennings (if this were 1983, aka FTR Enterprises)
     8 				; ==========================================================================
     9 				; Version 00, November 2018
    10 				; Version 01, December 2018
    11 				; Version 02, February 2019
    12 				; Version 03, August 2019
    13 				; ==========================================================================
    14
    15 				; ==========================================================================
    16 				; Custom Character Set for V02  . . .
    17 				;
    18 				; Internal Codes for redefined objects.
    19 				; Several things going on here in one character set...
    20 				; * The usual Mode 2 text:  
    21 				;   A-z, a-z, 0-9, and necessary punctuation are used for the instructions 
    22 				;   on the title screen.  These are redefined in their natural positions, 
    23 				;   so every character does not need to be declared.  
    24 				; * Mode 2 color artifacts: 
    25 				;   Specific characters are defined for the text in the score lines.  
    26 				; * Mode 4, 5 colors colors:
    27 				;   This provides the game's beach and rocks graphics, waves, animated
    28 				;   boats and water effects. Five colors (including background.)
    29 				;
    30 				; Boat Lines:
    31 				; COLBK  = Water waves (from above line)
    32 				; COLPF0 = blue (and varieties) for the water waves. 
    33 				; COLPF1 = Browns Main boat body. 
    34 				; COLPF2 = Boat Seats (collision color used for safe frog on boat.) 
    35 				; COLPF3 = White (full screen) Wave effects, Missile colors for frog eyes.
    36 				;
    37 				; Beach Lines:
    38 				; COLBK  = Sand color
    39 				; COLPF0 = Water color (from line above)
    40 				; COLPF1 = Rock 1 main color
    41 				; COLPF2 = Sand background (darker) 
    42 				; COLPF3 = Rock 2 (lighter)
    43 				; --------------------------------------------------------------------------
    44
    45 = 0002			I_BOAT_LF    = $02 ; ", boat, left, front,       animated (2 images)
    46 = 0003			I_BOAT_LFW   = $03 ; #, boat, left, front waves, animated (8 images)
    47 = 0004			I_SEATS_L1   = $04 ; $, boat, left, seats 1
    48 = 0005			I_SEATS_L2   = $05 ; %, boat, left, seats 2
    49 = 0006			I_SEATS_L3   = $06 ; &, boat, left, seats 3
    50 = 000A			I_BOAT_EMPTY = $0A ; *, boat, common filler before engine. 
    51 = 000B			I_BOAT_LB    = $0B ; +, boat, left, back (engine)
    52 = 000F			I_BOAT_LBW   = $0F ; /, boat, left, back waves,  animated (8 images)
    53
    54 = 001B			I_BOAT_RBW   = $1b ; ;, boat, right, back waves,   animated (8 images)
    55 = 001C			I_BOAT_RB    = $1c ; <, boat, right, back (engine)
    56
    57 = 001E			I_SEATS_R3   = $1e ; >, boat, right, seats 3
    58 = 0046			I_SEATS_R2   = $46 ; ctrl-F, boat, right, seats 2
    59 = 0047			I_SEATS_R1   = $47 ; ctrl-G, boat, right, seats 1
    60 = 0049			I_BOAT_RFW   = $49 ; ctrl-I, boat, right, front waves, animated (8 images)
    61 = 004B			I_BOAT_RF    = $4b ; ctrl-K, boat, right, front,       animated (2 images)
    62
    63 = 004C			I_BEACH1     = $4c ; ctrl-L, beach part 1
    64 = 004D			I_BEACH2     = $4d ; ctrl-M, beach part 2
    65 = 004E			I_BEACH3     = $4e ; ctrl-N, beach part 3
    66 = 004F			I_BEACH4     = $4f ; ctrl-O, beach part 4
    67 = 0051			I_BEACH5     = $51 ; ctrl-Q, beach part 5
    68 = 0052			I_BEACH6     = $52 ; ctrl-R, beach part 6 (and alternate beach rocks)
    69 = 0053			I_BEACH7     = $53 ; ctrl-S, beach part 7 (and alternate beach rocks)
    70 = 0054			I_BEACH8     = $54 ; ctrl-T, beach part 8
    71
    72 = 0055			I_ROCKS1L    = $55 ; ctrl-U, alternate rocks1 (left)  I_BEACH6
    73 = 0056			I_ROCKS1R    = $56 ; ctrl-V, alternate rocks1 (right) I_BEACH7
    74 = 0057			I_ROCKS2     = $57 ; ctrl-W, alternate rocks2 (right) I_BEACH7
    75 = 0058			I_ROCKS3     = $58 ; ctrl-X, alternate rocks3 (right) I_BEACH7
    76 = 0059			I_ROCKS4     = $59 ; ctrl-Y, alternate rocks4 (left)  I_BEACH6
    77
    78 = 005A			I_WATER1     = $5A ; ctrl-Z, Water
    79 = 005B			I_WATER2     = $5B ; escape, water
    80 = 005C			I_WATER3     = $5C ; up,     water
    81 = 005D			I_WATER4     = $5D ; down,   water
    82
    83 				; Special artifact characters for Score:, :Hi, Frogs:, Saved Frogs:
    84 				; I_BS = $50 ; "S", ctrl-P
    85 				;I_SC = $41 ; "c", ctrl-A
    86 				;I_SO = $42 ; "o", ctrl-B
    87 				;I_SR = $43 ; "r", ctrl-C
    88 				;I_SE = $44 ; "e", ctrl-D
    89 = 0020			I_CO = $20 ; ":", @
    90
    91 				;I_BH = $3E ; "H", ^
    92 				;I_SI = $3F ; "i", _
    93
    94 				;I_BF = $3B ; "F", [
    95 				;I_SS = $3C ; "s", \
    96 				;I_SG = $3D ; "g", ]
    97
    98 				;I_BA = $45 ; "a", ctrl-E
    99 				;I_SV = $48 ; "v", ctrl-H
   100 				;I_SD = $4A ; "d", ctrl-J
   101
   102 				; Frog shapes alternate in the Frog counter to make their 8-pixel wide
   103 				; shapes more recognizable.
   104 = 007E			I_FROG1 = $7E ; DELETE, A Frog for frog counter. 
   105 = 007F			I_FROG2 = $7F ; TAB, A Frog for frog counter. 
   106
   107 				; Used for the SELECT hack to play with number of lives to write the 
   108 				; singular LIFE vs plural LIVES.
   109 = 0000			I_SPACE = $00
   110 = 0066			I_F     = 102
   111 = 0073			I_S     = 115
   112 = 0076			I_V     = 118
   113
   114 				 
   115 3E8B				.align $0400 ; Start at ANTIC's 1K boundary for character sets
   116
   117 				 
   118 4000			CHARACTER_SET
   119 				; Page 0xE0.  Chars 0 to 31 -- Symbols, numbers
   120 				; Char $00: SPACE
   121 4000-451F> 00 00 00 00 + 	.BYTE $00,$00,$00,$00,$00,$00,$00,$00
   122 				; $00: . . . . . . . .
   123 				; $00: . . . . . . . .
   124 				; $00: . . . . . . . .
   125 				; $00: . . . . . . . .
   126 				; $00: . . . . . . . .
   127 				; $00: . . . . . . . .
   128 				; $00: . . . . . . . .
   129 				; $00: . . . . . . . .
   130
   131 				; Char $01:   !
   132 4008 00 18 18 18 18 00 + 	.BYTE $00,$18,$18,$18,$18,$00,$18,$00
   133 				; $00: . . . . . . . .
   134 				; $18: . . . # # . . .
   135 				; $18: . . . # # . . .
   136 				; $18: . . . # # . . .
   137 				; $18: . . . # # . . .
   138 				; $00: . . . . . . . .
   139 				; $18: . . . # # . . .
   140 				; $00: . . . . . . . .
   141
   142 				; Boat Lines:
   143 				; COLBK  = Water waves (matching COLPF0 from water line above)
   144 				; COLPF0 = blue (and varieties) for the water waves. 
   145 				; COLPF1 = Main boat body. 
   146 				; COLPF2 = Boat Seats (collision color used for safe frog on boat.) 
   147 				; COLPF3 = White (full screen) Wave effects, Missile colors for frog eyes.
   148
   149 				; .. == 00 == COLBK
   150 				; ## == 01 == COLPF0
   151 				; OO == 10 == COLPF1
   152 				; XX == 11 == COLPF2 
   153 				; XX == 11 == COLPF3 (inverse char) 
   154
   155 				; Char $02:   " ======================= I_BOAT_LF animated (2 images)
   156 4010 A0 AA 2A 2A 0A 03 +   .BYTE $A0,$AA,$2A,$2A,$0A,$03,$17,$55
   157 				; $A0: OO OO .. .. 
   158 				; $AA: OO OO OO OO 
   159 				; $2A: .. OO OO OO 
   160 				; $2A: .. OO OO OO 
   161 				; $0A: .. .. OO OO 
   162 				; $03: .. .. .. XX 
   163 				; $17: .. ## ## XX 
   164 				; $55: ## ## ## ## 
   165
   166 				; Char $03:   # ======================= I_BOAT_LFW animated (8 images)
   167 4018 00 A0 AA AA EA FA +   .BYTE $00,$A0,$AA,$AA,$EA,$FA,$FE,$FF
   168 				; $00: .. .. .. .. 
   169 				; $A0: OO OO .. .. 
   170 				; $AA: OO OO OO OO 
   171 				; $AA: OO OO OO OO 
   172 				; $EA: XX OO OO OO 
   173 				; $FA: XX XX OO OO 
   174 				; $FE: XX XX XX OO 
   175 				; $FF: XX XX XX XX 
   176
   177 				; Char $04:   $ ======================= I_SEATS_L1
   178 4020 00 00 AA FF AA BF +   .BYTE $00,$00,$AA,$FF,$AA,$BF,$AA,$AA
   179 				; $00: .. .. .. .. 
   180 				; $00: .. .. .. .. 
   181 				; $AA: OO OO OO OO 
   182 				; $FF: XX XX XX XX 
   183 				; $AA: OO OO OO OO 
   184 				; $BF: OO XX XX XX 
   185 				; $AA: OO OO OO OO 
   186 				; $AA: OO OO OO OO 
   187
   188 				; Char $05:   % ======================= I_SEATS_L2
   189 4028 00 00 A8 AA FF AA +   .BYTE $00,$00,$A8,$AA,$FF,$AA,$FF,$AA
   190 				; $00: .. .. .. .. 
   191 				; $00: .. .. .. .. 
   192 				; $A8: OO OO OO .. 
   193 				; $AA: OO OO OO OO 
   194 				; $FF: XX XX XX XX 
   195 				; $AA: OO OO OO OO 
   196 				; $FF: XX XX XX XX 
   197 				; $AA: OO OO OO OO 
   198
   199 				; Char $06:   & ======================= I_SEATS_L3
   200 4030 00 00 00 AA FF AA +   .BYTE $00,$00,$00,$AA,$FF,$AA,$FE,$AA
   201 				; $00: .. .. .. .. 
   202 				; $00: .. .. .. .. 
   203 				; $00: .. .. .. .. 
   204 				; $AA: OO OO OO OO 
   205 				; $FF: XX XX XX XX 
   206 				; $AA: OO OO OO OO 
   207 				; $FE: XX XX XX OO 
   208 				; $AA: OO OO OO OO 
   209
   210 				; Char $07:   '    
   211 4038 00 18 18 18 00 00 +   .BYTE $00,$18,$18,$18,$00,$00,$00,$00
   212 				; $00: . . . . . . . . 
   213 				; $18: . . . # # . . . 
   214 				; $18: . . . # # . . . 
   215 				; $18: . . . # # . . . 
   216 				; $00: . . . . . . . . 
   217 				; $00: . . . . . . . . 
   218 				; $00: . . . . . . . . 
   219 				; $00: . . . . . . . . 
   220
   221 				; Char $08:   (    
   222 4040 00 0E 18 18 18 18 +   .BYTE $00,$0E,$18,$18,$18,$18,$0E,$00
   223 				; $00: . . . . . . . . 
   224 				; $0E: . . . . # # # . 
   225 				; $18: . . . # # . . . 
   226 				; $18: . . . # # . . . 
   227 				; $18: . . . # # . . . 
   228 				; $18: . . . # # . . . 
   229 				; $0E: . . . . # # # . 
   230 				; $00: . . . . . . . . 
   231
   232 				; Char $09:   )    
   233 4048 00 70 18 18 18 18 +   .BYTE $00,$70,$18,$18,$18,$18,$70,$00
   234 				; $00: . . . . . . . . 
   235 				; $70: . # # # . . . . 
   236 				; $18: . . . # # . . . 
   237 				; $18: . . . # # . . . 
   238 				; $18: . . . # # . . . 
   239 				; $18: . . . # # . . . 
   240 				; $70: . # # # . . . . 
   241 				; $00: . . . . . . . . 
   242
   243 				; Char $0A:   * ======================= I_BOAT_EMPTY
   244 4050 00 00 00 AA AA AA +   .BYTE $00,$00,$00,$AA,$AA,$AA,$AA,$AA
   245 				; $00: .. .. .. .. 
   246 				; $00: .. .. .. .. 
   247 				; $00: .. .. .. .. 
   248 				; $AA: OO OO OO OO 
   249 				; $AA: OO OO OO OO 
   250 				; $AA: OO OO OO OO 
   251 				; $AA: OO OO OO OO 
   252 				; $AA: OO OO OO OO 
   253
   254 				; Char $0B:   + ======================= I_BOAT_LB
   255 4058 28 2A 2A 8A 8A 88 +   .BYTE $28,$2A,$2A,$8A,$8A,$88,$8C,$FF
   256 				; $28: .. OO OO .. 
   257 				; $2A: .. OO OO OO 
   258 				; $2A: .. OO OO OO 
   259 				; $8A: OO .. OO OO 
   260 				; $8A: OO .. OO OO 
   261 				; $88: OO .. OO .. 
   262 				; $8C: OO .. XX .. 
   263 				; $FF: XX XX XX XX 
   264
   265 				; Char $0C:   ,
   266 4060 00 00 00 00 00 18 + 	.BYTE $00,$00,$00,$00,$00,$18,$18,$30
   267 				; $00: . . . . . . . .
   268 				; $00: . . . . . . . .
   269 				; $00: . . . . . . . .
   270 				; $00: . . . . . . . .
   271 				; $00: . . . . . . . .
   272 				; $18: . . . # # . . .
   273 				; $18: . . . # # . . .
   274 				; $30: . . # # . . . .
   275
   276 				; Char $0D:   -    
   277 4068 00 00 00 7E 00 00 +   .BYTE $00,$00,$00,$7e,$00,$00,$00,$00
   278 				; $00: . . . . . . . .
   279 				; $00: . . . . . . . .
   280 				; $00: . . . . . . . .
   281 				; $7E: . # # # # # # .
   282 				; $00: . . . . . . . .
   283 				; $18: . . . . . . . .
   284 				; $18: . . . . . . . .
   285 				; $00: . . . . . . . .
   286
   287 				; Char $0E:   .
   288 4070 00 00 00 00 00 18 + 	.BYTE $00,$00,$00,$00,$00,$18,$18,$00
   289 				; $00: . . . . . . . .
   290 				; $00: . . . . . . . .
   291 				; $00: . . . . . . . .
   292 				; $00: . . . . . . . .
   293 				; $00: . . . . . . . .
   294 				; $18: . . . # # . . .
   295 				; $18: . . . # # . . .
   296 				; $00: . . . . . . . .
   297
   298 				; Char $0F:   / ======================= I_BOAT_LBW animated (8 images)
   299 4078 00 00 00 00 00 00 +   .BYTE $00,$00,$00,$00,$00,$00,$CC,$F5
   300 				; $00: .. .. .. .. 
   301 				; $00: .. .. .. .. 
   302 				; $00: .. .. .. .. 
   303 				; $00: .. .. .. .. 
   304 				; $00: .. .. .. .. 
   305 				; $00: .. .. .. .. 
   306 				; $CC: XX .. XX .. 
   307 				; $F5: XX XX ## ## 
   308
   309 				; Char $10:   0
   310 4080 00 7E 66 66 66 66 + 	.BYTE $00,$7E,$66,$66,$66,$66,$7E,$00
   311 				; $00: . . . . . . . .
   312 				; $7E: . # # # # # # .
   313 				; $66: . # # . . # # .
   314 				; $66: . # # . . # # .
   315 				; $66: . # # . . # # .
   316 				; $66: . # # . . # # .
   317 				; $7E: . # # # # # # .
   318 				; $00: . . . . . . . .
   319
   320 				; Char $11:   1
   321 4088 00 18 18 18 18 18 + 	.BYTE $00,$18,$18,$18,$18,$18,$18,$00
   322 				; $00: . . . . . . . .
   323 				; $18: . . . # # . . .
   324 				; $18: . . . # # . . .
   325 				; $18: . . . # # . . .
   326 				; $18: . . . # # . . .
   327 				; $18: . . . # # . . .
   328 				; $18: . . . # # . . .
   329 				; $00: . . . . . . . .
   330
   331 				; Char $12:   2
   332 4090 00 7E 06 7E 60 60 + 	.BYTE $00,$7E,$06,$7E,$60,$60,$7E,$00
   333 				; $00: . . . . . . . .
   334 				; $7E: . # # # # # # .
   335 				; $06: . . . . . # # .
   336 				; $7E: . # # # # # # .
   337 				; $60: . # # . . . . .
   338 				; $60: . # # . . . . .
   339 				; $7E: . # # # # # # .
   340 				; $00: . . . . . . . .
   341
   342 				; Char $13:   3
   343 4098 00 7E 06 1E 06 06 + 	.BYTE $00,$7E,$06,$1E,$06,$06,$7E,$00
   344 				; $00: . . . . . . . .
   345 				; $7E: . # # # # # # .
   346 				; $06: . . . . . # # .
   347 				; $1E: . . . # # # # .
   348 				; $06: . . . . . # # .
   349 				; $06: . . . . . # # .
   350 				; $7E: . # # # # # # .
   351 				; $00: . . . . . . . .
   352
   353 				; Char $14:   4
   354 40A0 00 66 66 66 7E 06 + 	.BYTE $00,$66,$66,$66,$7E,$06,$06,$00
   355 				; $00: . . . . . . . .
   356 				; $66: . # # . . # # .
   357 				; $66: . # # . . # # .
   358 				; $66: . # # . . # # .
   359 				; $7E: . # # # # # # .
   360 				; $06: . . . . . # # .
   361 				; $06: . . . . . # # .
   362 				; $00: . . . . . . . .
   363
   364 				; Char $15:   5
   365 40A8 00 7E 60 7E 06 06 + 	.BYTE $00,$7E,$60,$7E,$06,$06,$7E,$00
   366 				; $00: . . . . . . . .
   367 				; $7E: . # # # # # # .
   368 				; $60: . # # . . . . .
   369 				; $7E: . # # # # # # .
   370 				; $06: . . . . . # # .
   371 				; $06: . . . . . # # .
   372 				; $7E: . # # # # # # .
   373 				; $00: . . . . . . . .
   374
   375 				; Char $16:   6
   376 40B0 00 7E 60 7E 66 66 + 	.BYTE $00,$7E,$60,$7E,$66,$66,$7E,$00
   377 				; $00: . . . . . . . .
   378 				; $7E: . # # # # # # .
   379 				; $60: . # # . . . . .
   380 				; $7E: . # # # # # # .
   381 				; $66: . # # . . # # .
   382 				; $66: . # # . . # # .
   383 				; $7E: . # # # # # # .
   384 				; $00: . . . . . . . .
   385
   386 				; Char $17:   7
   387 40B8 00 7E 06 06 06 06 + 	.BYTE $00,$7E,$06,$06,$06,$06,$06,$00
   388 				; $00: . . . . . . . .
   389 				; $7E: . # # # # # # .
   390 				; $06: . . . . . # # .
   391 				; $06: . . . . . # # .
   392 				; $06: . . . . . # # .
   393 				; $06: . . . . . # # .
   394 				; $06: . . . . . # # .
   395 				; $00: . . . . . . . .
   396
   397 				; Char $18:   8
   398 40C0 00 7E 66 7E 66 66 + 	.BYTE $00,$7E,$66,$7E,$66,$66,$7E,$00
   399 				; $00: . . . . . . . .
   400 				; $7E: . # # # # # # .
   401 				; $66: . # # . . # # .
   402 				; $7E: . # # # # # # .
   403 				; $66: . # # . . # # .
   404 				; $66: . # # . . # # .
   405 				; $7E: . # # # # # # .
   406 				; $00: . . . . . . . .
   407
   408 				; Char $19:   9
   409 40C8 00 7E 66 7E 06 06 + 	.BYTE $00,$7E,$66,$7E,$06,$06,$06,$00
   410 				; $00: . . . . . . . .
   411 				; $7E: . # # # # # # .
   412 				; $66: . # # . . # # .
   413 				; $7E: . # # # # # # .
   414 				; $06: . . . . . # # .
   415 				; $06: . . . . . # # .
   416 				; $06: . . . . . # # .
   417 				; $00: . . . . . . . .
   418 				; Char $1A:   :
   419 40D0 00 00 18 18 00 18 + 	.BYTE $00,$00,$18,$18,$00,$18,$18,$00
   420 				; $00: . . . . . . . .
   421 				; $00: . . . . . . . .
   422 				; $10: . . . # # . . .
   423 				; $10: . . . # # . . .
   424 				; $00: . . . . . . . .
   425 				; $10: . . . # # . . .
   426 				; $10: . . . # # . . .
   427 				; $00: . . . . . . . .
   428
   429 				; Char $1B:   ; ======================= I_BOAT_RBW animated (8 images)
   430 40D8 00 00 00 00 00 00 +   .BYTE $00,$00,$00,$00,$00,$00,$33,$5F
   431 				; $00: .. .. .. .. 
   432 				; $00: .. .. .. .. 
   433 				; $00: .. .. .. .. 
   434 				; $00: .. .. .. .. 
   435 				; $00: .. .. .. .. 
   436 				; $00: .. .. .. .. 
   437 				; $33: .. XX .. XX 
   438 				; $5F: ## ## XX XX 
   439
   440 				; Char $1C:   < ======================= I_BOAT_RB
   441 40E0 28 A8 A8 A2 A2 22 +   .BYTE $28,$A8,$A8,$A2,$A2,$22,$32,$FF
   442 				; $28: .. OO OO .. 
   443 				; $A8: OO OO OO .. 
   444 				; $A8: OO OO OO .. 
   445 				; $A2: OO OO .. OO 
   446 				; $A2: OO OO .. OO 
   447 				; $22: .. OO .. OO 
   448 				; $32: .. XX .. OO 
   449 				; $FF: XX XX XX XX 
   450
   451 				; Char $1D:   =
   452 40E8 00 00 7E 00 00 7E + 	.BYTE $00,$00,$7E,$00,$00,$7E,$00,$00
   453 				; $00: . . . . . . . .
   454 				; $00: . . . . . . . .
   455 				; $7E: . # # # # # # .
   456 				; $00: . . . . . . . .
   457 				; $00: . . . . . . . .
   458 				; $7E: . # # # # # # .
   459 				; $00: . . . . . . . .
   460 				; $00: . . . . . . . .
   461
   462 				; Char $1E:   > ======================= I_SEATS_R3
   463 40F0 00 00 00 AA FF AA +   .BYTE $00,$00,$00,$AA,$FF,$AA,$BF,$AA
   464 				; $00: .. .. .. .. 
   465 				; $00: .. .. .. .. 
   466 				; $00: .. .. .. .. 
   467 				; $AA: OO OO OO OO 
   468 				; $FF: XX XX XX XX 
   469 				; $AA: OO OO OO OO 
   470 				; $BF: OO XX XX XX 
   471 				; $AA: OO OO OO OO 
   472
   473 				; Char $1F:   ?
   474 40F8 00 3C 66 0C 18 00 + 	.BYTE $00,$3C,$66,$0C,$18,$00,$18,$00
   475 				; $00: . . . . . . . .
   476 				; $3C: . . # # # # . .
   477 				; $66: . # # . . # # .
   478 				; $0C: . . . . # # . .
   479 				; $18: . . . # # . . .
   480 				; $00: . . . . . . . .
   481 				; $18: . . . # # . . .
   482 				; $00: . . . . . . . .
   483
   484 				; Page 0xE1.  Chars 32 to 63 -- Uppercase
   485
   486 				; Char $20:   @ ======================= I_CO
   487 4100 00 00 10 10 00 10 +   .BYTE $00,$00,$10,$10,$00,$10,$10,$00
   488 				; $00: .. .. .. .. 
   489 				; $00: .. .. .. .. 
   490 				; $10: .. ## .. .. 
   491 				; $10: .. ## .. .. 
   492 				; $00: .. .. .. .. 
   493 				; $10: .. ## .. .. 
   494 				; $10: .. ## .. .. 
   495 				; $00: .. .. .. .. 
   496
   497 				; Char $21:   A
   498 4108 00 7E 66 7E 66 66 + 	.BYTE $00,$7E,$66,$7E,$66,$66,$66,$00
   499 				; $00: . . . . . . . .
   500 				; $7E: . # # # # # # .
   501 				; $66: . # # . . # # .
   502 				; $7E: . # # # # # # .
   503 				; $66: . # # . . # # .
   504 				; $66: . # # . . # # .
   505 				; $66: . # # . . # # .
   506 				; $00: . . . . . . . .
   507
   508 				; Char $22:   B
   509 4110 00 7E 66 7E 66 66 + 	.BYTE $00,$7E,$66,$7E,$66,$66,$7E,$00
   510 				; $00: . . . . . . . .
   511 				; $7E: . # # # # # # .
   512 				; $66: . # # . . # # .
   513 				; $7E: . # # # # # # .
   514 				; $66: . # # . . # # .
   515 				; $66: . # # . . # # .
   516 				; $7E: . # # # # # # .
   517 				; $00: . . . . . . . .
   518
   519 				; Char $23:   C
   520 4118 00 7E 60 60 60 60 + 	.BYTE $00,$7E,$60,$60,$60,$60,$7E,$00
   521 				; $00: . . . . . . . .
   522 				; $7E: . # # # # # # .
   523 				; $60: . # # . . . . .
   524 				; $60: . # # . . . . .
   525 				; $60: . # # . . . . .
   526 				; $60: . # # . . . . .
   527 				; $7E: . # # # # # # .
   528 				; $00: . . . . . . . .
   529
   530 				; Char $24:   D
   531 4120 00 7C 66 66 66 66 + 	.BYTE $00,$7C,$66,$66,$66,$66,$7C,$00
   532 				; $00: . . . . . . . .
   533 				; $7C: . # # # # # . .
   534 				; $66: . # # . . # # .
   535 				; $66: . # # . . # # .
   536 				; $66: . # # . . # # .
   537 				; $66: . # # . . # # .
   538 				; $7C: . # # # # # . .
   539 				; $00: . . . . . . . .
   540
   541 				; Char $25:   E
   542 4128 00 7E 60 7C 60 60 + 	.BYTE $00,$7E,$60,$7C,$60,$60,$7E,$00
   543 				; $00: . . . . . . . .
   544 				; $7E: . # # # # # # .
   545 				; $60: . # # . . . . .
   546 				; $7C: . # # # # # . .
   547 				; $60: . # # . . . . .
   548 				; $60: . # # . . . . .
   549 				; $7E: . # # # # # # .
   550 				; $00: . . . . . . . .
   551
   552 				; Char $26:   F
   553 4130 00 7E 60 7C 60 60 + 	.BYTE $00,$7E,$60,$7C,$60,$60,$60,$00
   554 				; $00: . . . . . . . .
   555 				; $7E: . # # # # # # .
   556 				; $60: . # # . . . . .
   557 				; $7C: . # # # # # . .
   558 				; $60: . # # . . . . .
   559 				; $60: . # # . . . . .
   560 				; $60: . # # . . . . .
   561 				; $00: . . . . . . . .
   562
   563 				; Char $27:   G
   564 4138 00 7E 60 60 66 66 + 	.BYTE $00,$7E,$60,$60,$66,$66,$7E,$00
   565 				; $00: . . . . . . . .
   566 				; $7E: . # # # # # # .
   567 				; $60: . # # . . . . .
   568 				; $60: . # # . . . . .
   569 				; $66: . # # . . # # .
   570 				; $66: . # # . . # # .
   571 				; $7E: . # # # # # # .
   572 				; $00: . . . . . . . .
   573
   574 				; Char $28:   H
   575 4140 00 66 66 7E 66 66 + 	.BYTE $00,$66,$66,$7E,$66,$66,$66,$00
   576 				; $00: . . . . . . . .
   577 				; $66: . # # . . # # .
   578 				; $66: . # # . . # # .
   579 				; $7E: . # # # # # # .
   580 				; $66: . # # . . # # .
   581 				; $66: . # # . . # # .
   582 				; $66: . # # . . # # .
   583 				; $00: . . . . . . . .
   584
   585 				; Char $29:   I
   586 4148 00 18 18 18 18 18 + 	.BYTE $00,$18,$18,$18,$18,$18,$18,$00
   587 				; $00: . . . . . . . .
   588 				; $18: . . . # # . . .
   589 				; $18: . . . # # . . .
   590 				; $18: . . . # # . . .
   591 				; $18: . . . # # . . .
   592 				; $18: . . . # # . . .
   593 				; $18: . . . # # . . .
   594 				; $00: . . . . . . . .
   595
   596 				; Char $2A:   J
   597 4150 00 06 06 06 06 06 + 	.BYTE $00,$06,$06,$06,$06,$06,$7E,$00
   598 				; $00: . . . . . . . .
   599 				; $06: . . . . . # # .
   600 				; $06: . . . . . # # .
   601 				; $06: . . . . . # # .
   602 				; $06: . . . . . # # .
   603 				; $06: . . . . . # # .
   604 				; $7E: . # # # # # # .
   605 				; $00: . . . . . . . .
   606
   607 				; Char $2B:   K
   608 4158 00 66 66 78 78 66 + 	.BYTE $00,$66,$66,$78,$78,$66,$66,$00
   609 				; $00: . . . . . . . .
   610 				; $66: . # # . . # # .
   611 				; $66: . # # . . # # .
   612 				; $78: . # # # # . . .
   613 				; $78: . # # # # . . .
   614 				; $66: . # # . . # # .
   615 				; $66: . # # . . # # .
   616 				; $00: . . . . . . . .
   617
   618 				; Char $2C:   L
   619 4160 00 60 60 60 60 60 + 	.BYTE $00,$60,$60,$60,$60,$60,$7E,$00
   620 				; $00: . . . . . . . .
   621 				; $60: . # # . . . . .
   622 				; $60: . # # . . . . .
   623 				; $60: . # # . . . . .
   624 				; $60: . # # . . . . .
   625 				; $60: . # # . . . . .
   626 				; $7E: . # # # # # # .
   627 				; $00: . . . . . . . .
   628
   629 				; Char $2D:   M
   630 4168 00 66 7E 7E 66 66 + 	.BYTE $00,$66,$7E,$7E,$66,$66,$66,$00
   631 				; $00: . . . . . . . .
   632 				; $66: . # # . . # # .
   633 				; $7E: . # # # # # # .
   634 				; $7E: . # # # # # # .
   635 				; $66: . # # . . # # .
   636 				; $66: . # # . . # # .
   637 				; $66: . # # . . # # .
   638 				; $00: . . . . . . . .
   639
   640 				; Char $2E:   N
   641 4170 00 66 76 7E 7E 66 + 	.BYTE $00,$66,$76,$7E,$7E,$66,$66,$00
   642 				; $00: . . . . . . . .
   643 				; $66: . # # . . # # .
   644 				; $76: . # # # . # # .
   645 				; $7E: . # # # # # # .
   646 				; $7E: . # # # # # # .
   647 				; $66: . # # . . # # .
   648 				; $66: . # # . . # # .
   649 				; $00: . . . . . . . .
   650
   651 				; Char $2F:   O
   652 4178 00 7E 66 66 66 66 + 	.BYTE $00,$7E,$66,$66,$66,$66,$7E,$00
   653 				; $00: . . . . . . . .
   654 				; $7E: . # # # # # # .
   655 				; $66: . # # . . # # .
   656 				; $66: . # # . . # # .
   657 				; $66: . # # . . # # .
   658 				; $66: . # # . . # # .
   659 				; $7E: . # # # # # # .
   660 				; $00: . . . . . . . .
   661
   662 				; Char $30:   P
   663 4180 00 7E 66 66 7E 60 + 	.BYTE $00,$7E,$66,$66,$7E,$60,$60,$00
   664 				; $00: . . . . . . . .
   665 				; $7E: . # # # # # # .
   666 				; $66: . # # . . # # .
   667 				; $66: . # # . . # # .
   668 				; $7E: . # # # # # # .
   669 				; $60: . # # . . . . .
   670 				; $60: . # # . . . . .
   671 				; $00: . . . . . . . .
   672
   673 				; Char $31:   Q
   674 4188 00 7E 66 66 66 6C + 	.BYTE $00,$7E,$66,$66,$66,$6C,$76,$00
   675 				; $00: . . . . . . . .
   676 				; $7E: . # # # # # # .
   677 				; $66: . # # . . # # .
   678 				; $66: . # # . . # # .
   679 				; $66: . # # . . # # .
   680 				; $6C: . # # . # # . .
   681 				; $76: . # # # . # # .
   682 				; $00: . . . . . . . .
   683
   684 				; Char $32:   R
   685 4190 00 7E 66 7E 6C 66 + 	.BYTE $00,$7E,$66,$7E,$6C,$66,$66,$00
   686 				; $00: . . . . . . . .
   687 				; $7E: . # # # # # # .
   688 				; $66: . # # . . # # .
   689 				; $7E: . # # # # # # .
   690 				; $6C: . # # . # # . .
   691 				; $66: . # # . . # # .
   692 				; $66: . # # . . # # .
   693 				; $00: . . . . . . . .
   694
   695 				; Char $33:   S
   696 4198 00 7E 60 7E 06 06 + 	.BYTE $00,$7E,$60,$7E,$06,$06,$7E,$00
   697 				; $00: . . . . . . . .
   698 				; $7E: . # # # # # # .
   699 				; $60: . # # . . . . .
   700 				; $7E: . # # # # # # .
   701 				; $06: . . . . . # # .
   702 				; $06: . . . . . # # .
   703 				; $7E: . # # # # # # .
   704 				; $00: . . . . . . . .
   705
   706 				; Char $34:   T
   707 41A0 00 7E 18 18 18 18 + 	.BYTE $00,$7E,$18,$18,$18,$18,$18,$00
   708 				; $00: . . . . . . . .
   709 				; $7E: . # # # # # # .
   710 				; $18: . . . # # . . .
   711 				; $18: . . . # # . . .
   712 				; $18: . . . # # . . .
   713 				; $18: . . . # # . . .
   714 				; $18: . . . # # . . .
   715 				; $00: . . . . . . . .
   716
   717 				; Char $35:   U
   718 41A8 00 66 66 66 66 66 + 	.BYTE $00,$66,$66,$66,$66,$66,$7E,$00
   719 				; $00: . . . . . . . .
   720 				; $66: . # # . . # # .
   721 				; $66: . # # . . # # .
   722 				; $66: . # # . . # # .
   723 				; $66: . # # . . # # .
   724 				; $66: . # # . . # # .
   725 				; $7E: . # # # # # # .
   726 				; $00: . . . . . . . .
   727
   728 				; Char $36:   V
   729 41B0 00 66 66 66 66 66 + 	.BYTE $00,$66,$66,$66,$66,$66,$18,$00
   730 				; $00: . . . . . . . .
   731 				; $66: . # # . . # # .
   732 				; $66: . # # . . # # .
   733 				; $66: . # # . . # # .
   734 				; $66: . # # . . # # .
   735 				; $66: . # # . . # # .
   736 				; $18: . . . # # . . .
   737 				; $00: . . . . . . . .
   738
   739 				; Char $37:   W
   740 41B8 00 66 66 66 7E 7E + 	.BYTE $00,$66,$66,$66,$7E,$7E,$66,$00
   741 				; $00: . . . . . . . .
   742 				; $66: . # # . . # # .
   743 				; $66: . # # . . # # .
   744 				; $66: . # # . . # # .
   745 				; $7E: . # # # # # # .
   746 				; $7E: . # # # # # # .
   747 				; $66: . # # . . # # .
   748 				; $00: . . . . . . . .
   749
   750 				; Char $38:   X
   751 41C0 00 66 66 18 18 66 + 	.BYTE $00,$66,$66,$18,$18,$66,$66,$00
   752 				; $00: . . . . . . . .
   753 				; $66: . # # . . # # .
   754 				; $66: . # # . . # # .
   755 				; $18: . . . # # . . .
   756 				; $18: . . . # # . . .
   757 				; $66: . # # . . # # .
   758 				; $66: . # # . . # # .
   759 				; $00: . . . . . . . .
   760
   761 				; Char $39:   Y
   762 41C8 00 66 66 18 18 18 + 	.BYTE $00,$66,$66,$18,$18,$18,$18,$00
   763 				; $00: . . . . . . . .
   764 				; $66: . # # . . # # .
   765 				; $66: . # # . . # # .
   766 				; $18: . . . # # . . .
   767 				; $18: . . . # # . . .
   768 				; $18: . . . # # . . .
   769 				; $18: . . . # # . . .
   770 				; $00: . . . . . . . .
   771
   772 				; Char $3A:   Z
   773 41D0 00 7E 06 7E 60 60 + 	.BYTE $00,$7E,$06,$7E,$60,$60,$7E,$00
   774 				; $00: . . . . . . . .
   775 				; $7E: . # # # # # # .
   776 				; $06: . . . . . # # .
   777 				; $7E: . # # # # # # .
   778 				; $60: . # # . . . . .
   779 				; $60: . # # . . . . .
   780 				; $7E: . # # # # # # .
   781 				; $00: . . . . . . . .
   782
   783 				; Char $3B:   [ ==================== I_BF
   784 41D8 00 2A 20 28 20 20 +   .BYTE $00,$2A,$20,$28,$20,$20,$20,$00
   785 				; $00: .. .. .. .. 
   786 				; $2A: .. OO OO OO 
   787 				; $20: .. OO .. .. 
   788 				; $28: .. OO OO .. 
   789 				; $20: .. OO .. .. 
   790 				; $20: .. OO .. .. 
   791 				; $20: .. OO .. .. 
   792 				; $00: .. .. .. .. 
   793
   794 				; Char $3C:   \    
   795 41E0 00 00 2A 20 2A 02 +   .BYTE $00,$00,$2A,$20,$2A,$02,$2A,$00
   796 				; $00: .. .. .. .. 
   797 				; $00: .. .. .. .. 
   798 				; $2A: .. OO OO OO 
   799 				; $20: .. OO .. .. 
   800 				; $2A: .. OO OO OO 
   801 				; $02: .. .. .. OO 
   802 				; $2A: .. OO OO OO 
   803 				; $00: .. .. .. .. 
   804
   805 				; Char $3D:   ]    
   806 41E8 00 00 2A 20 22 22 +   .BYTE $00,$00,$2A,$20,$22,$22,$2A,$00
   807 				; $00: .. .. .. .. 
   808 				; $00: .. .. .. .. 
   809 				; $2A: .. OO OO OO 
   810 				; $20: .. OO .. .. 
   811 				; $22: .. OO .. OO 
   812 				; $22: .. OO .. OO 
   813 				; $2A: .. OO OO OO 
   814 				; $00: .. .. .. .. 
   815
   816 				; Char $3E:   ^ ==================== I_BH
   817 41F0 00 22 22 2A 22 22 +   .BYTE $00,$22,$22,$2A,$22,$22,$22,$00
   818 				; $00: .. .. .. .. 
   819 				; $22: .. OO .. OO 
   820 				; $22: .. OO .. OO 
   821 				; $2A: .. OO OO OO 
   822 				; $22: .. OO .. OO 
   823 				; $22: .. OO .. OO 
   824 				; $22: .. OO .. OO 
   825 				; $00: .. .. .. .. 
   826
   827 				; Char $3F:   _    
   828 41F8 00 00 08 08 08 08 +   .BYTE $00,$00,$08,$08,$08,$08,$08,$00
   829 				; $00: .. .. .. .. 
   830 				; $00: .. .. .. .. 
   831 				; $08: .. .. OO .. 
   832 				; $08: .. .. OO .. 
   833 				; $08: .. .. OO .. 
   834 				; $08: .. .. OO .. 
   835 				; $08: .. .. OO .. 
   836 				; $00: .. .. .. .. 
   837
   838 				; Page 0xE2.  Chars 64 to 95 -- graphics control characters
   839 				; Char $40: ctrl-,
   840 4200 00 36 7F 7F 3E 1C + 	.BYTE $00,$36,$7F,$7F,$3E,$1C,$08,$00
   841 				; $00: . . . . . . . .
   842 				; $36: . . # # . # # .
   843 				; $7F: . # # # # # # #
   844 				; $7F: . # # # # # # #
   845 				; $3E: . . # # # # # .
   846 				; $1C: . . . # # # . .
   847 				; $08: . . . . # . . .
   848 				; $00: . . . . . . . .
   849
   850 				; Char $41: ctrl-A ==================== I_SC
   851 4208 00 00 2A 20 20 20 +   .BYTE $00,$00,$2A,$20,$20,$20,$2A,$00
   852 				; $00: .. .. .. .. 
   853 				; $00: .. .. .. .. 
   854 				; $2A: .. OO OO OO 
   855 				; $20: .. OO .. .. 
   856 				; $20: .. OO .. .. 
   857 				; $20: .. OO .. .. 
   858 				; $2A: .. OO OO OO 
   859 				; $00: .. .. .. .. 
   860
   861 				; Char $42: ctrl-B 
   862 4210 00 00 2A 22 22 22 +   .BYTE $00,$00,$2A,$22,$22,$22,$2A,$00
   863 				; $00: .. .. .. .. 
   864 				; $00: .. .. .. .. 
   865 				; $2A: .. OO OO OO 
   866 				; $22: .. OO .. OO 
   867 				; $22: .. OO .. OO 
   868 				; $22: .. OO .. OO 
   869 				; $2A: .. OO OO OO 
   870 				; $00: .. .. .. .. 
   871
   872 				; Char $43: ctrl-C 
   873 4218 00 00 2A 20 20 20 +   .BYTE $00,$00,$2A,$20,$20,$20,$20,$00
   874 				; $00: .. .. .. .. 
   875 				; $00: .. .. .. .. 
   876 				; $2A: .. OO OO OO 
   877 				; $20: .. OO .. .. 
   878 				; $20: .. OO .. .. 
   879 				; $20: .. OO .. .. 
   880 				; $20: .. OO .. .. 
   881 				; $00: .. .. .. .. 
   882
   883 				; Char $44: ctrl-D 
   884 4220 00 00 2A 20 28 20 +   .BYTE $00,$00,$2A,$20,$28,$20,$2A,$00
   885 				; $00: .. .. .. .. 
   886 				; $00: .. .. .. .. 
   887 				; $2A: .. OO OO OO 
   888 				; $20: .. OO .. .. 
   889 				; $28: .. OO OO .. 
   890 				; $20: .. OO .. .. 
   891 				; $2A: .. OO OO OO 
   892 				; $00: .. .. .. .. 
   893
   894 				; Char $45: ctrl-E 
   895 4228 00 00 2A 22 2A 22 +   .BYTE $00,$00,$2A,$22,$2A,$22,$22,$00
   896 				; $00: .. .. .. .. 
   897 				; $00: .. .. .. .. 
   898 				; $2A: .. OO OO OO 
   899 				; $22: .. OO .. OO 
   900 				; $2A: .. OO OO OO 
   901 				; $22: .. OO .. OO 
   902 				; $22: .. OO .. OO 
   903 				; $00: .. .. .. .. 
   904
   905 				; Char $46: ctrl-F ==================== I_SEATS_R2
   906 4230 00 00 2A AA FF AA +   .BYTE $00,$00,$2A,$AA,$FF,$AA,$FF,$AA
   907 				; $00: .. .. .. .. 
   908 				; $00: .. .. .. .. 
   909 				; $2A: .. OO OO OO 
   910 				; $AA: OO OO OO OO 
   911 				; $FF: XX XX XX XX 
   912 				; $AA: OO OO OO OO 
   913 				; $FF: XX XX XX XX 
   914 				; $AA: OO OO OO OO 
   915
   916 				; Char $47: ctrl-G ==================== I_SEATS_R1
   917 4238 00 00 AA FF AA FE +   .BYTE $00,$00,$AA,$FF,$AA,$FE,$AA,$AA
   918 				; $00: .. .. .. .. 
   919 				; $00: .. .. .. .. 
   920 				; $AA: OO OO OO OO 
   921 				; $FF: XX XX XX XX 
   922 				; $AA: OO OO OO OO 
   923 				; $FE: XX XX XX OO 
   924 				; $AA: OO OO OO OO 
   925 				; $AA: OO OO OO OO 
   926
   927 				; Char $48: ctrl-H 
   928 4240 00 00 22 22 22 22 +   .BYTE $00,$00,$22,$22,$22,$22,$08,$00
   929 				; $00: .. .. .. .. 
   930 				; $00: .. .. .. .. 
   931 				; $22: .. OO .. OO 
   932 				; $22: .. OO .. OO 
   933 				; $22: .. OO .. OO 
   934 				; $22: .. OO .. OO 
   935 				; $08: .. .. OO .. 
   936 				; $00: .. .. .. .. 
   937
   938 				; Char $49: ctrl-I ==================== I_BOAT_RFW animated (8 images)
   939 4248 00 0A AA AA AB AF +   .BYTE $00,$0A,$AA,$AA,$AB,$AF,$BF,$FF
   940 				; $00: .. .. .. .. 
   941 				; $0A: .. .. OO OO 
   942 				; $AA: OO OO OO OO 
   943 				; $AA: OO OO OO OO 
   944 				; $AB: OO OO OO XX 
   945 				; $AF: OO OO XX XX 
   946 				; $BF: OO XX XX XX 
   947 				; $FF: XX XX XX XX 
   948
   949 				; Char $4A: ctrl-J 
   950 4250 00 00 28 22 22 22 +   .BYTE $00,$00,$28,$22,$22,$22,$28,$00
   951 				; $00: .. .. .. .. 
   952 				; $00: .. .. .. .. 
   953 				; $28: .. OO OO .. 
   954 				; $22: .. OO .. OO 
   955 				; $22: .. OO .. OO 
   956 				; $22: .. OO .. OO 
   957 				; $28: .. OO OO .. 
   958 				; $00: .. .. .. .. 
   959
   960 				; Char $4B: ctrl-K ==================== I_BOAT_RF animated (2 images)
   961 4258 0A AA A8 A8 A0 C0 +   .BYTE $0A,$AA,$A8,$A8,$A0,$C0,$D4,$55
   962 				; $0A: .. .. OO OO 
   963 				; $AA: OO OO OO OO 
   964 				; $A8: OO OO OO .. 
   965 				; $A8: OO OO OO .. 
   966 				; $A0: OO OO .. .. 
   967 				; $C0: XX .. .. .. 
   968 				; $D4: XX ## ## .. 
   969 				; $55: ## ## ## ## 
   970
   971 				; Beach Lines:
   972 				; COLBK  = Sand color
   973 				; COLPF0 = Water color (from line above)
   974 				; COLPF1 = Rock 1 main color
   975 				; COLPF2 = Sand background (darker) 
   976 				; COLPF3 = White (rock hilight) 
   977
   978 				; .. == 00 == COLBK
   979 				; ## == 01 == COLPF0
   980 				; OO == 10 == COLPF1
   981 				; XX == 11 == COLPF2 
   982 				; XX == 11 == COLPF3 (inverse char) 
   983
   984 				; Char $4C: ctrl-L ==================== I_BEACH1
   985 4260 57 5F FF FF FF F0 +   .BYTE $57,$5F,$FF,$FF,$FF,$F0,$00,$00
   986 				; $57: ## ## ## XX 
   987 				; $5F: ## ## XX XX 
   988 				; $FF: XX XX XX XX 
   989 				; $FF: XX XX XX XX 
   990 				; $FF: XX XX XX XX 
   991 				; $F0: XX XX .. .. 
   992 				; $00: .. .. .. .. 
   993 				; $00: .. .. .. .. 
   994
   995 				; Char $4D: ctrl-M ==================== I_BEACH2
   996 4268 F5 FF FF FF C0 00 +   .BYTE $F5,$FF,$FF,$FF,$C0,$00,$00,$00
   997 				; $F5: XX XX ## ## 
   998 				; $FF: XX XX XX XX 
   999 				; $FF: XX XX XX XX 
  1000 				; $FF: XX XX XX XX 
  1001 				; $C0: XX .. .. .. 
  1002 				; $00: .. .. .. .. 
  1003 				; $00: .. .. .. .. 
  1004 				; $00: .. .. .. .. 
  1005
  1006 				; Char $4E: ctrl-N ==================== I_BEACH3
  1007 4270 55 5F FF FF 0F 00 +   .BYTE $55,$5F,$FF,$FF,$0F,$00,$00,$00
  1008 				; $55: ## ## ## ## 
  1009 				; $5F: ## ## XX XX 
  1010 				; $FF: XX XX XX XX 
  1011 				; $FF: XX XX XX XX 
  1012 				; $0F: .. .. XX XX 
  1013 				; $00: .. .. .. .. 
  1014 				; $00: .. .. .. .. 
  1015 				; $00: .. .. .. .. 
  1016
  1017 				; Char $4F: ctrl-O ==================== I_BEACH4
  1018 4278 FD FF FF FF FF 0F +   .BYTE $FD,$FF,$FF,$FF,$FF,$0F,$00,$00
  1019 				; $FD: XX XX XX ## 
  1020 				; $FF: XX XX XX XX 
  1021 				; $FF: XX XX XX XX 
  1022 				; $FF: XX XX XX XX 
  1023 				; $FF: XX XX XX XX 
  1024 				; $0F: .. .. XX XX 
  1025 				; $00: .. .. .. .. 
  1026 				; $00: .. .. .. .. 
  1027
  1028 				; Char $50: ctrl-P ==================== I_BS
  1029 4280 00 2A 20 2A 02 02 +   .BYTE $00,$2A,$20,$2A,$02,$02,$2A,$00
  1030 				; $00: .. .. .. .. 
  1031 				; $2A: .. OO OO OO 
  1032 				; $20: .. OO .. .. 
  1033 				; $2A: .. OO OO OO 
  1034 				; $02: .. .. .. OO 
  1035 				; $02: .. .. .. OO 
  1036 				; $2A: .. OO OO OO 
  1037 				; $00: .. .. .. .. 
  1038
  1039 				; Char $51: ctrl-Q ==================== I_BEACH5
  1040 4288 55 55 F5 FF F0 00 +   .BYTE $55,$55,$F5,$FF,$F0,$00,$00,$00
  1041 				; $55: ## ## ## ## 
  1042 				; $55: ## ## ## ## 
  1043 				; $F5: XX XX ## ## 
  1044 				; $FF: XX XX XX XX 
  1045 				; $F0: XX XX .. .. 
  1046 				; $00: .. .. .. .. 
  1047 				; $00: .. .. .. .. 
  1048 				; $00: .. .. .. .. 
  1049
  1050 				; Char $52: ctrl-R ==================== I_BEACH6
  1051 4290 55 55 50 00 00 00 +   .BYTE $55,$55,$50,$00,$00,$00,$00,$00
  1052 				; $55: ## ## ## ## 
  1053 				; $55: ## ## ## ## 
  1054 				; $50: ## ## .. .. 
  1055 				; $00: .. .. .. .. 
  1056 				; $00: .. .. .. .. 
  1057 				; $00: .. .. .. .. 
  1058 				; $00: .. .. .. .. 
  1059 				; $00: .. .. .. .. 
  1060
  1061 				; Char $53: ctrl-S ==================== I_BEACH7
  1062 4298 55 55 05 00 00 00 +   .BYTE $55,$55,$05,$00,$00,$00,$00,$00
  1063 				; $55: ## ## ## ## 
  1064 				; $55: ## ## ## ## 
  1065 				; $05: .. .. ## ## 
  1066 				; $00: .. .. .. .. 
  1067 				; $00: .. .. .. .. 
  1068 				; $00: .. .. .. .. 
  1069 				; $00: .. .. .. .. 
  1070 				; $00: .. .. .. .. 
  1071
  1072 				; Char $54: ctrl-T ==================== I_BEACH8
  1073 42A0 55 55 57 3F 03 00 +   .BYTE $55,$55,$57,$3F,$03,$00,$00,$00
  1074 				; $55: ## ## ## ## 
  1075 				; $55: ## ## ## ## 
  1076 				; $57: ## ## ## XX 
  1077 				; $3F: .. XX XX XX 
  1078 				; $03: .. .. .. XX 
  1079 				; $00: .. .. .. .. 
  1080 				; $00: .. .. .. .. 
  1081 				; $00: .. .. .. .. 
  1082
  1083 				; Char $55: ctrl-U ==================== I_ROCKS1L
  1084 42A8 55 55 50 00 00 02 +   .BYTE $55,$55,$50,$00,$00,$02,$2A,$AA
  1085 				; $55: ## ## ## ## 
  1086 				; $55: ## ## ## ## 
  1087 				; $50: ## ## .. .. 
  1088 				; $00: .. .. .. .. 
  1089 				; $0F: .. .. .. .. 
  1090 				; $3A: .. .. .. OO 
  1091 				; $3A: .. OO OO OO 
  1092 				; $3A: OO OO OO OO 
  1093
  1094 				; Char $56: ctrl-V ==================== I_ROCKS1R
  1095 42B0 55 55 05 00 00 00 +   .BYTE $55,$55,$05,$00,$00,$00,$A0,$A8
  1096 				; $55: ## ## ## ## 
  1097 				; $55: ## ## ## ## 
  1098 				; $05: .. .. ## ## 
  1099 				; $00: .. .. .. .. 
  1100 				; $00: .. .. .. .. 
  1101 				; $00: .. .. .. .. 
  1102 				; $80: OO OO .. .. 
  1103 				; $A0: OO OO OO .. 
  1104
  1105 				; Char $57: ctrl-W ==================== I_ROCKS2
  1106 42B8 55 55 05 00 00 00 +   .BYTE $55,$55,$05,$00,$00,$00,$20,$A8
  1107 				; $55: ## ## ## ## 
  1108 				; $55: ## ## ## ## 
  1109 				; $05: .. .. ## ## 
  1110 				; $00: .. .. .. .. 
  1111 				; $00: .. .. .. .. 
  1112 				; $03: .. .. .. .. 
  1113 				; $C0: .. OO .. .. 
  1114 				; $C0: OO OO OO .. 
  1115
  1116 				; Char $58: ctrl-X ==================== I_ROCKS3
  1117 42C0 55 55 05 00 00 08 +   .BYTE $55,$55,$05,$00,$00,$08,$2A,$00
  1118 				; $55: ## ## ## ## 
  1119 				; $55: ## ## ## ## 
  1120 				; $05: .. .. ## ## 
  1121 				; $00: .. .. .. .. 
  1122 				; $00: .. .. .. .. 
  1123 				; $02: .. .. OO .. 
  1124 				; $82: .. OO OO OO 
  1125 				; $00: .. .. .. .. 
  1126
  1127 				; Char $59: ctrl-Y ==================== I_ROCKS4
  1128 42C8 55 55 50 00 20 A8 +   .BYTE $55,$55,$50,$00,$20,$A8,$00,$00
  1129 				; $55: ## ## ## ## 
  1130 				; $55: ## ## ## ## 
  1131 				; $50: ## ## .. .. 
  1132 				; $00: .. .. .. .. 
  1133 				; $0C: .. OO .. .. 
  1134 				; $38: OO OO OO .. 
  1135 				; $EA: .. .. .. .. 
  1136 				; $00: .. .. .. .. 
  1137
  1138 				; Boat Lines:
  1139 				; COLBK  = Water waves (matching COLPF0 from water line above)
  1140 				; COLPF0 = blue (and varieties) for the water waves. 
  1141
  1142 				; .. == 00 == COLBK
  1143 				; ## == 01 == COLPF0
  1144
  1145 				; Char $5A: ctrl-Z ==================== I_WATER1
  1146 42D0 00 00 00 00 00 00 +   .BYTE $00,$00,$00,$00,$00,$00,$05,$55
  1147 				; $00: .. .. .. .. 
  1148 				; $00: .. .. .. .. 
  1149 				; $00: .. .. .. .. 
  1150 				; $00: .. .. .. .. 
  1151 				; $00: .. .. .. .. 
  1152 				; $00: .. .. .. .. 
  1153 				; $05: .. .. ## ## 
  1154 				; $55: ## ## ## ## 
  1155
  1156 				; Char $5B: ESCAPE ==================== I_WATER2
  1157 42D8 00 00 00 00 05 55 +   .BYTE $00,$00,$00,$00,$05,$55,$55,$55
  1158 				; $00: .. .. .. .. 
  1159 				; $00: .. .. .. .. 
  1160 				; $00: .. .. .. .. 
  1161 				; $00: .. .. .. .. 
  1162 				; $05: .. .. ## ## 
  1163 				; $55: ## ## ## ## 
  1164 				; $55: ## ## ## ## 
  1165 				; $55: ## ## ## ## 
  1166
  1167 				; Char $5C: UP     ==================== I_WATER3
  1168 42E0 00 00 00 00 50 55 +   .BYTE $00,$00,$00,$00,$50,$55,$55,$55
  1169 				; $00: .. .. .. .. 
  1170 				; $00: .. .. .. .. 
  1171 				; $00: .. .. .. .. 
  1172 				; $00: .. .. .. .. 
  1173 				; $50: ## ## .. .. 
  1174 				; $55: ## ## ## ## 
  1175 				; $55: ## ## ## ## 
  1176 				; $55: ## ## ## ## 
  1177
  1178 				; Char $5D: DOWN   ==================== I_WATER4
  1179 42E8 00 00 00 00 00 00 +   .BYTE $00,$00,$00,$00,$00,$00,$50,$55
  1180 				; $00: .. .. .. .. 
  1181 				; $00: .. .. .. .. 
  1182 				; $00: .. .. .. .. 
  1183 				; $00: .. .. .. .. 
  1184 				; $00: .. .. .. .. 
  1185 				; $00: .. .. .. .. 
  1186 				; $50: ## ## .. .. 
  1187 				; $55: ## ## ## ## 
  1188
  1189 				; Char $5E: LEFT
  1190 42F0 00 18 30 7E 30 18 + 	.BYTE $00,$18,$30,$7E,$30,$18,$00,$00
  1191 				; $00: . . . . . . . .
  1192 				; $18: . . . # # . . .
  1193 				; $30: . . # # . . . .
  1194 				; $7E: . # # # # # # .
  1195 				; $30: . . # # . . . .
  1196 				; $18: . . . # # . . .
  1197 				; $00: . . . . . . . .
  1198 				; $00: . . . . . . . .
  1199
  1200 				; Char $5F: RIGHT
  1201 42F8 00 18 0C 7E 0C 18 + 	.BYTE $00,$18,$0C,$7E,$0C,$18,$00,$00
  1202 				; $00: . . . . . . . .
  1203 				; $18: . . . # # . . .
  1204 				; $0C: . . . . # # . .
  1205 				; $7E: . # # # # # # .
  1206 				; $0C: . . . . # # . .
  1207 				; $18: . . . # # . . .
  1208 				; $00: . . . . . . . .
  1209 				; $00: . . . . . . . .
  1210
  1211 				; Page 0xE3.  Chars 96 to 127 -- lowercase
  1212 				; Char $60: ctrl-.
  1213 4300 00 18 3C 7E 7E 3C + 	.BYTE $00,$18,$3C,$7E,$7E,$3C,$18,$00
  1214 				; $00: . . . . . . . .
  1215 				; $18: . . . # # . . .
  1216 				; $3C: . . # # # # . .
  1217 				; $7E: . # # # # # # .
  1218 				; $7E: . # # # # # # .
  1219 				; $3C: . . # # # # . .
  1220 				; $18: . . . # # . . .
  1221 				; $00: . . . . . . . .
  1222
  1223 				; Char $61:   a
  1224 4308 00 00 7E 66 7E 66 + 	.BYTE $00,$00,$7E,$66,$7E,$66,$66,$00
  1225 				; $00: . . . . . . . .
  1226 				; $00: . . . . . . . .
  1227 				; $7E: . # # # # # # .
  1228 				; $66: . # # . . # # .
  1229 				; $7E: . # # # # # # .
  1230 				; $66: . # # . . # # .
  1231 				; $66: . # # . . # # .
  1232 				; $00: . . . . . . . .
  1233
  1234 				; Char $62:   b
  1235 4310 00 00 7E 66 7E 66 + 	.BYTE $00,$00,$7E,$66,$7E,$66,$7E,$00
  1236 				; $00: . . . . . . . .
  1237 				; $00: . . . . . . . .
  1238 				; $7E: . # # # # # # .
  1239 				; $66: . # # . . # # .
  1240 				; $7E: . # # # # # # .
  1241 				; $66: . # # . . # # .
  1242 				; $7E: . # # # # # # .
  1243 				; $00: . . . . . . . .
  1244
  1245 				; Char $63:   c
  1246 4318 00 00 7C 60 60 60 + 	.BYTE $00,$00,$7C,$60,$60,$60,$7C,$00
  1247 				; $00: . . . . . . . .
  1248 				; $00: . . . . . . . .
  1249 				; $7C: . # # # # # . .
  1250 				; $60: . # # . . . . .
  1251 				; $60: . # # . . . . .
  1252 				; $60: . # # . . . . .
  1253 				; $7C: . # # # # # . .
  1254 				; $00: . . . . . . . .
  1255
  1256 				; Char $64:   d
  1257 4320 00 00 7C 66 66 66 + 	.BYTE $00,$00,$7C,$66,$66,$66,$7C,$00
  1258 				; $00: . . . . . . . .
  1259 				; $00: . . . . . . . .
  1260 				; $7C: . # # # # # . .
  1261 				; $66: . # # . . # # .
  1262 				; $66: . # # . . # # .
  1263 				; $66: . # # . . # # .
  1264 				; $7C: . # # # # # . .
  1265 				; $00: . . . . . . . .
  1266
  1267 				; Char $65:   e
  1268 4328 00 00 7E 60 78 60 + 	.BYTE $00,$00,$7E,$60,$78,$60,$7E,$00
  1269 				; $00: . . . . . . . .
  1270 				; $00: . . . . . . . .
  1271 				; $7E: . # # # # # # .
  1272 				; $60: . # # . . . . .
  1273 				; $78: . # # # # . . .
  1274 				; $60: . # # . . . . .
  1275 				; $7E: . # # # # # # .
  1276 				; $00: . . . . . . . .
  1277
  1278 				; Char $66:   f
  1279 4330 00 00 7E 60 78 60 + 	.BYTE $00,$00,$7E,$60,$78,$60,$60,$00
  1280 				; $00: . . . . . . . .
  1281 				; $00: . . . . . . . .
  1282 				; $7E: . # # # # # # .
  1283 				; $60: . # # . . . . .
  1284 				; $78: . # # # # . . .
  1285 				; $60: . # # . . . . .
  1286 				; $60: . # # . . . . .
  1287 				; $00: . . . . . . . .
  1288
  1289 				; Char $67:   g
  1290 4338 00 00 7E 60 66 66 + 	.BYTE $00,$00,$7E,$60,$66,$66,$7E,$00
  1291 				; $00: . . . . . . . .
  1292 				; $00: . . . . . . . .
  1293 				; $7E: . # # # # # # .
  1294 				; $60: . # # . . . . .
  1295 				; $66: . # # . . # # .
  1296 				; $66: . # # . . # # .
  1297 				; $7E: . # # # # # # .
  1298 				; $00: . . . . . . . .
  1299
  1300 				; Char $68:   h
  1301 4340 00 00 66 66 7E 66 + 	.BYTE $00,$00,$66,$66,$7E,$66,$66,$00
  1302 				; $00: . . . . . . . .
  1303 				; $00: . . . . . . . .
  1304 				; $66: . # # . . # # .
  1305 				; $66: . # # . . # # .
  1306 				; $7E: . # # # # # # .
  1307 				; $66: . # # . . # # .
  1308 				; $66: . # # . . # # .
  1309 				; $00: . . . . . . . .
  1310
  1311 				; Char $69:   i
  1312 4348 00 00 18 18 18 18 + 	.BYTE $00,$00,$18,$18,$18,$18,$18,$00
  1313 				; $00: . . . . . . . .
  1314 				; $00: . . . . . . . .
  1315 				; $18: . . . # # . . .
  1316 				; $18: . . . # # . . .
  1317 				; $18: . . . # # . . .
  1318 				; $18: . . . # # . . .
  1319 				; $18: . . . # # . . .
  1320 				; $00: . . . . . . . .
  1321
  1322 				; Char $6A:   j
  1323 4350 00 00 06 06 06 06 + 	.BYTE $00,$00,$06,$06,$06,$06,$7E,$00
  1324 				; $00: . . . . . . . .
  1325 				; $00: . . . . . . . .
  1326 				; $06: . . . . . # # .
  1327 				; $06: . . . . . # # .
  1328 				; $06: . . . . . # # .
  1329 				; $06: . . . . . # # .
  1330 				; $7E: . # # # # # # .
  1331 				; $00: . . . . . . . .
  1332
  1333 				; Char $6B:   k
  1334 4358 00 00 66 66 78 66 + 	.BYTE $00,$00,$66,$66,$78,$66,$66,$00
  1335 				; $00: . . . . . . . .
  1336 				; $00: . . . . . . . .
  1337 				; $66: . # # . . # # .
  1338 				; $66: . # # . . # # .
  1339 				; $78: . # # # # . . .
  1340 				; $66: . # # . . # # .
  1341 				; $66: . # # . . # # .
  1342 				; $00: . . . . . . . .
  1343
  1344 				; Char $6C:   l
  1345 4360 00 00 60 60 60 60 + 	.BYTE $00,$00,$60,$60,$60,$60,$7E,$00
  1346 				; $00: . . . . . . . .
  1347 				; $00: . . . . . . . .
  1348 				; $60: . # # . . . . .
  1349 				; $60: . # # . . . . .
  1350 				; $60: . # # . . . . .
  1351 				; $60: . # # . . . . .
  1352 				; $7E: . # # # # # # .
  1353 				; $00: . . . . . . . .
  1354
  1355 				; Char $6D:   m
  1356 4368 00 00 66 7E 7E 66 + 	.BYTE $00,$00,$66,$7E,$7E,$66,$66,$00
  1357 				; $00: . . . . . . . .
  1358 				; $00: . . . . . . . .
  1359 				; $66: . # # . . # # .
  1360 				; $7E: . # # # # # # .
  1361 				; $7E: . # # # # # # .
  1362 				; $66: . # # . . # # .
  1363 				; $66: . # # . . # # .
  1364 				; $00: . . . . . . . .
  1365
  1366 				; Char $6E:   n
  1367 4370 00 00 7E 66 66 66 + 	.BYTE $00,$00,$7E,$66,$66,$66,$66,$00
  1368 				; $00: . . . . . . . .
  1369 				; $00: . . . . . . . .
  1370 				; $7E: . # # # # # # .
  1371 				; $66: . # # . . # # .
  1372 				; $66: . # # . . # # .
  1373 				; $66: . # # . . # # .
  1374 				; $66: . # # . . # # .
  1375 				; $00: . . . . . . . .
  1376
  1377 				; Char $6F:   o
  1378 4378 00 00 7E 66 66 66 + 	.BYTE $00,$00,$7E,$66,$66,$66,$7E,$00
  1379 				; $00: . . . . . . . .
  1380 				; $00: . . . . . . . .
  1381 				; $7E: . # # # # # # .
  1382 				; $66: . # # . . # # .
  1383 				; $66: . # # . . # # .
  1384 				; $66: . # # . . # # .
  1385 				; $7E: . # # # # # # .
  1386 				; $00: . . . . . . . .
  1387
  1388 				; Char $70:   p
  1389 4380 00 00 7E 66 7E 60 + 	.BYTE $00,$00,$7E,$66,$7E,$60,$60,$00
  1390 				; $00: . . . . . . . .
  1391 				; $00: . . . . . . . .
  1392 				; $7E: . # # # # # # .
  1393 				; $66: . # # . . # # .
  1394 				; $7E: . # # # # # # .
  1395 				; $60: . # # . . . . .
  1396 				; $60: . # # . . . . .
  1397 				; $00: . . . . . . . .
  1398
  1399 				; Char $71:   q
  1400 4388 00 00 7E 66 7E 06 + 	.BYTE $00,$00,$7E,$66,$7E,$06,$06,$00
  1401 				; $00: . . . . . . . .
  1402 				; $00: . . . . . . . .
  1403 				; $7E: . # # # # # # .
  1404 				; $66: . # # . . # # .
  1405 				; $7E: . # # # # # # .
  1406 				; $06: . . . . . # # .
  1407 				; $06: . . . . . # # .
  1408 				; $00: . . . . . . . .
  1409
  1410 				; Char $72:   r
  1411 4390 00 00 7E 60 60 60 + 	.BYTE $00,$00,$7E,$60,$60,$60,$60,$00
  1412 				; $00: . . . . . . . .
  1413 				; $00: . . . . . . . .
  1414 				; $7E: . # # # # # # .
  1415 				; $60: . # # . . . . .
  1416 				; $60: . # # . . . . .
  1417 				; $60: . # # . . . . .
  1418 				; $60: . # # . . . . .
  1419 				; $00: . . . . . . . .
  1420
  1421 				; Char $73:   s
  1422 4398 00 00 7E 60 7E 06 + 	.BYTE $00,$00,$7E,$60,$7E,$06,$7E,$00
  1423 				; $00: . . . . . . . .
  1424 				; $00: . . . . . . . .
  1425 				; $7E: . # # # # # # .
  1426 				; $60: . # # . . . . .
  1427 				; $7E: . # # # # # # .
  1428 				; $06: . . . . . # # .
  1429 				; $7E: . # # # # # # .
  1430 				; $00: . . . . . . . .
  1431
  1432 				; Char $74:   t
  1433 43A0 00 00 7E 18 18 18 + 	.BYTE $00,$00,$7E,$18,$18,$18,$18,$00
  1434 				; $00: . . . . . . . .
  1435 				; $00: . . . . . . . .
  1436 				; $7E: . # # # # # # .
  1437 				; $18: . . . # # . . .
  1438 				; $18: . . . # # . . .
  1439 				; $18: . . . # # . . .
  1440 				; $18: . . . # # . . .
  1441 				; $00: . . . . . . . .
  1442
  1443 				; Char $75:   u
  1444 43A8 00 00 66 66 66 66 + 	.BYTE $00,$00,$66,$66,$66,$66,$7E,$00
  1445 				; $00: . . . . . . . .
  1446 				; $00: . . . . . . . .
  1447 				; $66: . # # . . # # .
  1448 				; $66: . # # . . # # .
  1449 				; $66: . # # . . # # .
  1450 				; $66: . # # . . # # .
  1451 				; $7E: . # # # # # # .
  1452 				; $00: . . . . . . . .
  1453
  1454 				; Char $76:   v
  1455 43B0 00 00 66 66 66 66 + 	.BYTE $00,$00,$66,$66,$66,$66,$18,$00
  1456 				; $00: . . . . . . . .
  1457 				; $00: . . . . . . . .
  1458 				; $66: . # # . . # # .
  1459 				; $66: . # # . . # # .
  1460 				; $66: . # # . . # # .
  1461 				; $66: . # # . . # # .
  1462 				; $18: . . . # # . . .
  1463 				; $00: . . . . . . . .
  1464
  1465 				; Char $77:   w
  1466 43B8 00 00 66 66 7E 7E + 	.BYTE $00,$00,$66,$66,$7E,$7E,$66,$00
  1467 				; $00: . . . . . . . .
  1468 				; $00: . . . . . . . .
  1469 				; $66: . # # . . # # .
  1470 				; $66: . # # . . # # .
  1471 				; $7E: . # # # # # # .
  1472 				; $7E: . # # # # # # .
  1473 				; $66: . # # . . # # .
  1474 				; $00: . . . . . . . .
  1475
  1476 				; Char $78:   x
  1477 43C0 00 00 66 66 18 66 + 	.BYTE $00,$00,$66,$66,$18,$66,$66,$00
  1478 				; $00: . . . . . . . .
  1479 				; $00: . . . . . . . .
  1480 				; $66: . # # . . # # .
  1481 				; $66: . # # . . # # .
  1482 				; $18: . . . # # . . .
  1483 				; $66: . # # . . # # .
  1484 				; $66: . # # . . # # .
  1485 				; $00: . . . . . . . .
  1486
  1487 				; Char $79:   y
  1488 43C8 00 00 66 66 18 18 + 	.BYTE $00,$00,$66,$66,$18,$18,$18,$00
  1489 				; $00: . . . . . . . .
  1490 				; $00: . . . . . . . .
  1491 				; $66: . # # . . # # .
  1492 				; $66: . # # . . # # .
  1493 				; $18: . . . # # . . .
  1494 				; $18: . . . # # . . .
  1495 				; $18: . . . # # . . .
  1496 				; $00: . . . . . . . .
  1497
  1498 				; Char $7A:   z
  1499 43D0 00 00 7E 06 7E 60 + 	.BYTE $00,$00,$7E,$06,$7E,$60,$7E,$00
  1500 				; $00: . . . . . . . .
  1501 				; $00: . . . . . . . .
  1502 				; $7E: . # # # # # # .
  1503 				; $06: . . . . . # # .
  1504 				; $7E: . # # # # # # .
  1505 				; $60: . # # . . . . .
  1506 				; $7E: . # # # # # # .
  1507 				; $00: . . . . . . . .
  1508
  1509 				; Char $7B: ctrl-;
  1510 43D8 00 18 3C 7E 7E 18 + 	.BYTE $00,$18,$3C,$7E,$7E,$18,$3C,$00
  1511 				; $00: . . . . . . . .
  1512 				; $18: . . . # # . . .
  1513 				; $3C: . . # # # # . .
  1514 				; $7E: . # # # # # # .
  1515 				; $7E: . # # # # # # .
  1516 				; $18: . . . # # . . .
  1517 				; $3C: . . # # # # . .
  1518 				; $00: . . . . . . . .
  1519
  1520 				; Char $7C:   |
  1521 43E0 18 18 18 18 18 18 + 	.BYTE $18,$18,$18,$18,$18,$18,$18,$18
  1522 				; $18: . . . # # . . .
  1523 				; $18: . . . # # . . .
  1524 				; $18: . . . # # . . .
  1525 				; $18: . . . # # . . .
  1526 				; $18: . . . # # . . .
  1527 				; $18: . . . # # . . .
  1528 				; $18: . . . # # . . .
  1529 				; $18: . . . # # . . .
  1530
  1531 				; Char $7D: CLEAR
  1532 43E8 00 7E 78 7C 6E 66 + 	.BYTE $00,$7E,$78,$7C,$6E,$66,$06,$00
  1533 				; $00: . . . . . . . .
  1534 				; $7E: . # # # # # # .
  1535 				; $78: . # # # # . . .
  1536 				; $7C: . # # # # # . .
  1537 				; $6E: . # # . # # # .
  1538 				; $66: . # # . . # # .
  1539 				; $06: . . . . . # # .
  1540 				; $00: . . . . . . . .
  1541
  1542 				; Char $7E: DELETE - two versions of frog heads to display next to each other.
  1543 43F0 00 00 66 99 FF FF +   .BYTE $00,$00,$66,$99,$FF,$FF,$66,$3C
  1544 				; $00: . . . . . . . . 
  1545 				; $00: . . . . . . . . 
  1546 				; $66: . # # . . # # . 
  1547 				; $99: # . . # # . . # 
  1548 				; $FF: # # # # # # # # 
  1549 				; $FF: # # # # # # # # 
  1550 				; $66: . # # . . # # . 
  1551 				; $3C: . . # # # # . . 
  1552
  1553 				; Char $7F: TAB    
  1554 43F8 66 99 FF FF 66 3C +   .BYTE $66,$99,$FF,$FF,$66,$3C,$00,$00
  1555 				; $66: . # # . . # # . 
  1556 				; $99: # . . # # . . # 
  1557 				; $FF: # # # # # # # # 
  1558 				; $FF: # # # # # # # # 
  1559 				; $66: . # # . . # # . 
  1560 				; $3C: . . # # # # . . 
  1561 				; $00: . . . . . . . . 
  1562 				; $00: . . . . . . . . 
  1563
  1564
  1565 				;==================================================================================================
  1566
  1567 				; Here we reached the end of the 1K for the Character set, so the rest of this is a new page...
  1568 				; None of this is directly displayed.   These are individual frames that are copied to the 
  1569 				; real character position above to animate the boat parts.
  1570
  1571
  1572 4400			LEFT_BOAT_FRONT_ANIM ; 2 images, each used 4 times with one frame from LEFT_BOAT_WATER_ANIM (16 bytes)
  1573 				; Char $53: ctrl-S 
  1574 4400 A0 AA 2A 2A 0A 03 +   .BYTE $A0,$AA,$2A,$2A,$0A,$03,$17,$55
  1575 				; $A0: OO OO .. .. 
  1576 				; $AA: OO OO OO OO 
  1577 				; $2A: .. OO OO OO 
  1578 				; $2A: .. OO OO OO 
  1579 				; $0A: .. .. OO OO 
  1580 				; $03: .. .. .. XX 
  1581 				; $17: .. ## ## XX 
  1582 				; $55: ## ## ## ## 
  1583
  1584 				; Char $54: ctrl-T 
  1585 4408 A0 AA 2A 2A 0A 02 +   .BYTE $A0,$AA,$2A,$2A,$0A,$02,$17,$55
  1586 				; $A0: OO OO .. .. 
  1587 				; $AA: OO OO OO OO 
  1588 				; $2A: .. OO OO OO 
  1589 				; $2A: .. OO OO OO 
  1590 				; $0A: .. .. OO OO 
  1591 				; $02: .. .. .. OO 
  1592 				; $17: .. ## ## XX 
  1593 				; $55: ## ## ## ## 
  1594
  1595
  1596
  1597 4410			LEFT_BOAT_WATER_ANIM ; 8 frames, water waves at the front of the boat. (64 bytes)
  1598 				; Char $4A: ctrl-J 
  1599 4410 00 A0 AA AA EA FA +   .BYTE $00,$A0,$AA,$AA,$EA,$FA,$FE,$FF
  1600 				; $00: .. .. .. .. 
  1601 				; $A0: OO OO .. .. 
  1602 				; $AA: OO OO OO OO 
  1603 				; $AA: OO OO OO OO 
  1604 				; $EA: XX OO OO OO 
  1605 				; $FA: XX XX OO OO 
  1606 				; $FE: XX XX XX OO 
  1607 				; $FF: XX XX XX XX 
  1608
  1609 				; Char $4B: ctrl-K 
  1610 4418 00 A0 AA AA AA EA +   .BYTE $00,$A0,$AA,$AA,$AA,$EA,$FE,$FF
  1611 				; $00: .. .. .. .. 
  1612 				; $A0: OO OO .. .. 
  1613 				; $AA: OO OO OO OO 
  1614 				; $AA: OO OO OO OO 
  1615 				; $AA: OO OO OO OO 
  1616 				; $EA: XX OO OO OO 
  1617 				; $FE: XX XX XX OO 
  1618 				; $FF: XX XX XX XX 
  1619
  1620 				; Char $4C: ctrl-L 
  1621 4420 00 A0 AA AA AA FA +   .BYTE $00,$A0,$AA,$AA,$AA,$FA,$FE,$FF
  1622 				; $00: .. .. .. .. 
  1623 				; $A0: OO OO .. .. 
  1624 				; $AA: OO OO OO OO 
  1625 				; $AA: OO OO OO OO 
  1626 				; $AA: OO OO OO OO 
  1627 				; $FA: XX XX OO OO 
  1628 				; $FE: XX XX XX OO 
  1629 				; $FF: XX XX XX XX 
  1630
  1631 				; Char $4D: ctrl-M 
  1632 4428 00 A0 AA AA AA AA +   .BYTE $00,$A0,$AA,$AA,$AA,$AA,$BE,$FF
  1633 				; $00: .. .. .. .. 
  1634 				; $A0: OO OO .. .. 
  1635 				; $AA: OO OO OO OO 
  1636 				; $AA: OO OO OO OO 
  1637 				; $AA: OO OO OO OO 
  1638 				; $AA: OO OO OO OO 
  1639 				; $BE: OO XX XX OO 
  1640 				; $FF: XX XX XX XX 
  1641
  1642 				; Char $4E: ctrl-N 
  1643 4430 00 A0 AA AA AA AA +   .BYTE $00,$A0,$AA,$AA,$AA,$AA,$AA,$FF
  1644 				; $00: .. .. .. .. 
  1645 				; $A0: OO OO .. .. 
  1646 				; $AA: OO OO OO OO 
  1647 				; $AA: OO OO OO OO 
  1648 				; $AA: OO OO OO OO 
  1649 				; $AA: OO OO OO OO 
  1650 				; $AA: OO OO OO OO 
  1651 				; $FF: XX XX XX XX 
  1652
  1653 				; Char $4F: ctrl-O 
  1654 4438 00 A0 AA AA AA AA +   .BYTE $00,$A0,$AA,$AA,$AA,$AA,$AA,$FA
  1655 				; $00: .. .. .. .. 
  1656 				; $A0: OO OO .. .. 
  1657 				; $AA: OO OO OO OO 
  1658 				; $AA: OO OO OO OO 
  1659 				; $AA: OO OO OO OO 
  1660 				; $AA: OO OO OO OO 
  1661 				; $AA: OO OO OO OO 
  1662 				; $FA: XX XX OO OO 
  1663
  1664 				; Char $50: ctrl-P 
  1665 4440 00 A0 AA AA AA AA +   .BYTE $00,$A0,$AA,$AA,$AA,$AA,$EA,$FA
  1666 				; $00: .. .. .. .. 
  1667 				; $A0: OO OO .. .. 
  1668 				; $AA: OO OO OO OO 
  1669 				; $AA: OO OO OO OO 
  1670 				; $AA: OO OO OO OO 
  1671 				; $AA: OO OO OO OO 
  1672 				; $EA: XX OO OO OO 
  1673 				; $FA: XX XX OO OO 
  1674
  1675 				; Char $51: ctrl-Q 
  1676 4448 00 A0 AA AA AA EA +   .BYTE $00,$A0,$AA,$AA,$AA,$EA,$FA,$FE
  1677 				; $00: .. .. .. .. 
  1678 				; $A0: OO OO .. .. 
  1679 				; $AA: OO OO OO OO 
  1680 				; $AA: OO OO OO OO 
  1681 				; $AA: OO OO OO OO 
  1682 				; $EA: XX OO OO OO 
  1683 				; $FA: XX XX OO OO 
  1684 				; $FE: XX XX XX OO 
  1685
  1686
  1687 4450			LEFT_BOAT_WAKE_ANIM ; 8 Frames, water behind the engines. (64 bytes)
  1688 				; Char $41: ctrl-A 
  1689 4450 00 00 00 00 00 00 +   .BYTE $00,$00,$00,$00,$00,$00,$CC,$F5
  1690 				; $00: .. .. .. .. 
  1691 				; $00: .. .. .. .. 
  1692 				; $00: .. .. .. .. 
  1693 				; $00: .. .. .. .. 
  1694 				; $00: .. .. .. .. 
  1695 				; $00: .. .. .. .. 
  1696 				; $CC: XX .. XX .. 
  1697 				; $F5: XX XX ## ## 
  1698
  1699 				; Char $42: ctrl-B 
  1700 4458 00 00 00 00 00 33 +   .BYTE $00,$00,$00,$00,$00,$33,$FF,$F5
  1701 				; $00: .. .. .. .. 
  1702 				; $00: .. .. .. .. 
  1703 				; $00: .. .. .. .. 
  1704 				; $00: .. .. .. .. 
  1705 				; $00: .. .. .. .. 
  1706 				; $33: .. XX .. XX 
  1707 				; $FF: XX XX XX XX 
  1708 				; $F5: XX XX ## ## 
  1709
  1710 				; Char $43: ctrl-C 
  1711 4460 00 00 00 00 00 0F +   .BYTE $00,$00,$00,$00,$00,$0F,$3F,$FD
  1712 				; $00: .. .. .. .. 
  1713 				; $00: .. .. .. .. 
  1714 				; $00: .. .. .. .. 
  1715 				; $00: .. .. .. .. 
  1716 				; $00: .. .. .. .. 
  1717 				; $0F: .. .. XX XX 
  1718 				; $3F: .. XX XX XX 
  1719 				; $FD: XX XX XX ## 
  1720
  1721 				; Char $44: ctrl-D 
  1722 4468 00 00 00 00 00 03 +   .BYTE $00,$00,$00,$00,$00,$03,$3F,$FD
  1723 				; $00: .. .. .. .. 
  1724 				; $00: .. .. .. .. 
  1725 				; $00: .. .. .. .. 
  1726 				; $00: .. .. .. .. 
  1727 				; $00: .. .. .. .. 
  1728 				; $03: .. .. .. XX 
  1729 				; $3F: .. XX XX XX 
  1730 				; $FD: XX XX XX ## 
  1731
  1732 				; Char $45: ctrl-E 
  1733 4470 00 00 00 00 00 03 +   .BYTE $00,$00,$00,$00,$00,$03,$0F,$F5
  1734 				; $00: .. .. .. .. 
  1735 				; $00: .. .. .. .. 
  1736 				; $00: .. .. .. .. 
  1737 				; $00: .. .. .. .. 
  1738 				; $00: .. .. .. .. 
  1739 				; $03: .. .. .. XX 
  1740 				; $0F: .. .. XX XX 
  1741 				; $F5: XX XX ## ## 
  1742
  1743 				; Char $46: ctrl-F 
  1744 4478 00 00 00 00 00 33 +   .BYTE $00,$00,$00,$00,$00,$33,$FF,$F5
  1745 				; $00: .. .. .. .. 
  1746 				; $00: .. .. .. .. 
  1747 				; $00: .. .. .. .. 
  1748 				; $00: .. .. .. .. 
  1749 				; $00: .. .. .. .. 
  1750 				; $33: .. XX .. XX 
  1751 				; $FF: XX XX XX XX 
  1752 				; $F5: XX XX ## ## 
  1753
  1754 				; Char $47: ctrl-G 
  1755 4480 00 00 00 00 00 0C +   .BYTE $00,$00,$00,$00,$00,$0C,$3F,$FD
  1756 				; $00: .. .. .. .. 
  1757 				; $00: .. .. .. .. 
  1758 				; $00: .. .. .. .. 
  1759 				; $00: .. .. .. .. 
  1760 				; $00: .. .. .. .. 
  1761 				; $0C: .. .. XX .. 
  1762 				; $3F: .. XX XX XX 
  1763 				; $FD: XX XX XX ## 
  1764
  1765 				; Char $48: ctrl-H 
  1766 4488 00 00 00 00 00 03 +   .BYTE $00,$00,$00,$00,$00,$03,$FF,$FD
  1767 				; $00: .. .. .. .. 
  1768 				; $00: .. .. .. .. 
  1769 				; $00: .. .. .. .. 
  1770 				; $00: .. .. .. .. 
  1771 				; $00: .. .. .. .. 
  1772 				; $03: .. .. .. XX 
  1773 				; $FF: XX XX XX XX 
  1774 				; $FD: XX XX XX ## 
  1775
  1776
  1777 4490			RIGHT_BOAT_FRONT_ANIM ; 2 images, each used 4 times with one frame from RIGHT_BOAT_WATER_ANIM (16 bytes)
  1778 				; Char $73:   s    
  1779 4490 0A AA A8 A8 A0 C0 +   .BYTE $0A,$AA,$A8,$A8,$A0,$C0,$D4,$55
  1780 				; $0A: .. .. OO OO 
  1781 				; $AA: OO OO OO OO 
  1782 				; $A8: OO OO OO .. 
  1783 				; $A8: OO OO OO .. 
  1784 				; $A0: OO OO .. .. 
  1785 				; $C0: XX .. .. .. 
  1786 				; $D4: XX ## ## .. 
  1787 				; $55: ## ## ## ## 
  1788
  1789 				; Char $74:   t    
  1790 4498 0A AA A8 A8 A0 80 +   .BYTE $0A,$AA,$A8,$A8,$A0,$80,$D4,$55
  1791 				; $0A: .. .. OO OO 
  1792 				; $AA: OO OO OO OO 
  1793 				; $A8: OO OO OO .. 
  1794 				; $A8: OO OO OO .. 
  1795 				; $A0: OO OO .. .. 
  1796 				; $80: OO .. .. .. 
  1797 				; $D4: XX ## ## .. 
  1798 				; $55: ## ## ## ## 
  1799
  1800
  1801 44A0			RIGHT_BOAT_WATER_ANIM ; 8 frames, water waves at the front of the boat. (64 bytes)
  1802 				; Char $6A:   j    
  1803 44A0 00 0A AA AA AB AF +   .BYTE $00,$0A,$AA,$AA,$AB,$AF,$BF,$FF
  1804 				; $00: .. .. .. .. 
  1805 				; $0A: .. .. OO OO 
  1806 				; $AA: OO OO OO OO 
  1807 				; $AA: OO OO OO OO 
  1808 				; $AB: OO OO OO XX 
  1809 				; $AF: OO OO XX XX 
  1810 				; $BF: OO XX XX XX 
  1811 				; $FF: XX XX XX XX 
  1812
  1813 				; Char $6B:   k    
  1814 44A8 00 0A AA AA AA AB +   .BYTE $00,$0A,$AA,$AA,$AA,$AB,$BF,$FF
  1815 				; $00: .. .. .. .. 
  1816 				; $0A: .. .. OO OO 
  1817 				; $AA: OO OO OO OO 
  1818 				; $AA: OO OO OO OO 
  1819 				; $AA: OO OO OO OO 
  1820 				; $AB: OO OO OO XX 
  1821 				; $BF: OO XX XX XX 
  1822 				; $FF: XX XX XX XX 
  1823
  1824 				; Char $6C:   l    
  1825 44B0 00 0A AA AA AA AF +   .BYTE $00,$0A,$AA,$AA,$AA,$AF,$BF,$FF
  1826 				; $00: .. .. .. .. 
  1827 				; $0A: .. .. OO OO 
  1828 				; $AA: OO OO OO OO 
  1829 				; $AA: OO OO OO OO 
  1830 				; $AA: OO OO OO OO 
  1831 				; $AF: OO OO XX XX 
  1832 				; $BF: OO XX XX XX 
  1833 				; $FF: XX XX XX XX 
  1834
  1835 				; Char $6D:   m    
  1836 44B8 00 0A AA AA AA AA +   .BYTE $00,$0A,$AA,$AA,$AA,$AA,$BE,$FF
  1837 				; $00: .. .. .. .. 
  1838 				; $0A: .. .. OO OO 
  1839 				; $AA: OO OO OO OO 
  1840 				; $AA: OO OO OO OO 
  1841 				; $AA: OO OO OO OO 
  1842 				; $AA: OO OO OO OO 
  1843 				; $BE: OO XX XX OO 
  1844 				; $FF: XX XX XX XX 
  1845
  1846 				; Char $6E:   n    
  1847 44C0 00 0A AA AA AA AA +   .BYTE $00,$0A,$AA,$AA,$AA,$AA,$AA,$FF
  1848 				; $00: .. .. .. .. 
  1849 				; $0A: .. .. OO OO 
  1850 				; $AA: OO OO OO OO 
  1851 				; $AA: OO OO OO OO 
  1852 				; $AA: OO OO OO OO 
  1853 				; $AA: OO OO OO OO 
  1854 				; $AA: OO OO OO OO 
  1855 				; $FF: XX XX XX XX 
  1856
  1857 				; Char $6F:   o    
  1858 44C8 00 0A AA AA AA AA +   .BYTE $00,$0A,$AA,$AA,$AA,$AA,$AA,$AF
  1859 				; $00: .. .. .. .. 
  1860 				; $0A: .. .. OO OO 
  1861 				; $AA: OO OO OO OO 
  1862 				; $AA: OO OO OO OO 
  1863 				; $AA: OO OO OO OO 
  1864 				; $AA: OO OO OO OO 
  1865 				; $AA: OO OO OO OO 
  1866 				; $AF: OO OO XX XX 
  1867
  1868 				; Char $70:   p    
  1869 44D0 00 0A AA AA AA AA +   .BYTE $00,$0A,$AA,$AA,$AA,$AA,$AB,$AF
  1870 				; $00: .. .. .. .. 
  1871 				; $0A: .. .. OO OO 
  1872 				; $AA: OO OO OO OO 
  1873 				; $AA: OO OO OO OO 
  1874 				; $AA: OO OO OO OO 
  1875 				; $AA: OO OO OO OO 
  1876 				; $AB: OO OO OO XX 
  1877 				; $AF: OO OO XX XX 
  1878
  1879 				; Char $71:   q    
  1880 44D8 00 0A AA AA AA AB +   .BYTE $00,$0A,$AA,$AA,$AA,$AB,$AF,$BF
  1881 				; $00: .. .. .. .. 
  1882 				; $0A: .. .. OO OO 
  1883 				; $AA: OO OO OO OO 
  1884 				; $AA: OO OO OO OO 
  1885 				; $AA: OO OO OO OO 
  1886 				; $AB: OO OO OO XX 
  1887 				; $AF: OO OO XX XX 
  1888 				; $BF: OO XX XX XX 
  1889
  1890
  1891 44E0			RIGHT_BOAT_WAKE_ANIM ; 8 Frames, water behind the engines. (64 bytes)
  1892 				; Char $61:   a    
  1893 44E0 00 00 00 00 00 00 +   .BYTE $00,$00,$00,$00,$00,$00,$33,$5F
  1894 				; $00: .. .. .. .. 
  1895 				; $00: .. .. .. .. 
  1896 				; $00: .. .. .. .. 
  1897 				; $00: .. .. .. .. 
  1898 				; $00: .. .. .. .. 
  1899 				; $00: .. .. .. .. 
  1900 				; $33: .. XX .. XX 
  1901 				; $5F: ## ## XX XX 
  1902
  1903 				; Char $62:   b    
  1904 44E8 00 00 00 00 00 CC +   .BYTE $00,$00,$00,$00,$00,$CC,$FF,$5F
  1905 				; $00: .. .. .. .. 
  1906 				; $00: .. .. .. .. 
  1907 				; $00: .. .. .. .. 
  1908 				; $00: .. .. .. .. 
  1909 				; $00: .. .. .. .. 
  1910 				; $CC: XX .. XX .. 
  1911 				; $FF: XX XX XX XX 
  1912 				; $5F: ## ## XX XX 
  1913
  1914 				; Char $63:   c    
  1915 44F0 00 00 00 00 00 F0 +   .BYTE $00,$00,$00,$00,$00,$F0,$FC,$7F
  1916 				; $00: .. .. .. .. 
  1917 				; $00: .. .. .. .. 
  1918 				; $00: .. .. .. .. 
  1919 				; $00: .. .. .. .. 
  1920 				; $00: .. .. .. .. 
  1921 				; $F0: XX XX .. .. 
  1922 				; $FC: XX XX XX .. 
  1923 				; $7F: ## XX XX XX 
  1924
  1925 				; Char $64:   d    
  1926 44F8 00 00 00 00 00 C0 +   .BYTE $00,$00,$00,$00,$00,$C0,$FC,$7F
  1927 				; $00: .. .. .. .. 
  1928 				; $00: .. .. .. .. 
  1929 				; $00: .. .. .. .. 
  1930 				; $00: .. .. .. .. 
  1931 				; $00: .. .. .. .. 
  1932 				; $C0: XX .. .. .. 
  1933 				; $FC: XX XX XX .. 
  1934 				; $7F: ## XX XX XX 
  1935
  1936 				; Char $65:   e    
  1937 4500 00 00 00 00 00 C0 +   .BYTE $00,$00,$00,$00,$00,$C0,$F0,$5F
  1938 				; $00: .. .. .. .. 
  1939 				; $00: .. .. .. .. 
  1940 				; $00: .. .. .. .. 
  1941 				; $00: .. .. .. .. 
  1942 				; $00: .. .. .. .. 
  1943 				; $C0: XX .. .. .. 
  1944 				; $F0: XX XX .. .. 
  1945 				; $5F: ## ## XX XX 
  1946
  1947 				; Char $66:   f    
  1948 4508 00 00 00 00 00 CC +   .BYTE $00,$00,$00,$00,$00,$CC,$FF,$5F
  1949 				; $00: .. .. .. .. 
  1950 				; $00: .. .. .. .. 
  1951 				; $00: .. .. .. .. 
  1952 				; $00: .. .. .. .. 
  1953 				; $00: .. .. .. .. 
  1954 				; $CC: XX .. XX .. 
  1955 				; $FF: XX XX XX XX 
  1956 				; $5F: ## ## XX XX 
  1957
  1958 				; Char $67:   g    
  1959 4510 00 00 00 00 00 30 +   .BYTE $00,$00,$00,$00,$00,$30,$FC,$7F
  1960 				; $00: .. .. .. .. 
  1961 				; $00: .. .. .. .. 
  1962 				; $00: .. .. .. .. 
  1963 				; $00: .. .. .. .. 
  1964 				; $00: .. .. .. .. 
  1965 				; $30: .. XX .. .. 
  1966 				; $FC: XX XX XX .. 
  1967 				; $7F: ## XX XX XX 
  1968
  1969 				; Char $68:   h    
  1970 4518 00 00 00 00 00 C0 +   .BYTE $00,$00,$00,$00,$00,$C0,$FF,$7F
  1971 				; $00: .. .. .. .. 
  1972 				; $00: .. .. .. .. 
  1973 				; $00: .. .. .. .. 
  1974 				; $00: .. .. .. .. 
  1975 				; $00: .. .. .. .. 
  1976 				; $C0: XX .. .. .. 
  1977 				; $FF: XX XX XX XX 
  1978 				; $7F: ## XX XX XX 
  1979
   724
   725 4520				icl "Frogger03DisplayLists.asm" ; Aligns for display lists.
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03DisplayLists.asm
     1 				; ==========================================================================
     2 				; Pet Frogger
     3 				; (c) November 1983 by John C. Dale, aka Dalesoft
     4 				; for the Commodore Pet 4032
     5 				; ==========================================================================
     6 				; Ported (parodied) to Atari 8-bit computers
     7 				; by Ken Jennings (if this were 1983, aka FTR Enterprises)
     8 				; ==========================================================================
     9 				; Version 00, November 2018
    10 				; Version 01, December 2018
    11 				; Version 02, February 2019
    12 				; Version 03, August 2019
    13 				; ==========================================================================
    14
    15 				; ==========================================================================
    16 				; Display Lists.
    17 				;
    18 				; In Versions 00 through 02 the the custom Display lists make the Atari 
    19 				; impersonate the PET 4032's 40-column, 25 line display.  Version 03 now
    20 				; substitutes graphics for some uses of text modes, and uses different 
    21 				; sizes of blank lines to fill empty areas of the screen.  
    22 				; Due to requirements of the Game screen, the displays are now 202 
    23 				; scan lines, two taller than needed for the default, 25 text line 
    24 				; display used by the Pet.
    25 				;
    26 				; The Atari OS text printing is not being used, therefore the Atari screen
    27 				; editor's limitations are not an issue.
    28 				;
    29 				; ANTIC has a 1K boundary limit for Display Lists.  We do not need to align
    30 				; to 1K, because display lists are ordinarily short, and several will 
    31 				; easily fit in one page of memory.  So, the code can make due with 
    32 				; aligning to a page.  If they all stay in the page then they can't cross
    33 				; a 1K boundary.
    34 				; --------------------------------------------------------------------------
    35
    36
    37 4520				.align $0100
    38
    39
    40 				; Revised V03 Title Screen and Instructions:
    41 				;    +----------------------------------------+
    42 				; 1  |Score:00000000               00000000:Hi| SCORE_TXT
    43 				; 2  |Frogs:0       00000000000000000000:Saved| SCORE_TXT
    44 				; 3  |              PET FROGGER               | TITLE
    45 				; 4  |              PET FROGGER               | TITLE
    46 				; 5  |              PET FROGGER               | TITLE
    47 				; 6  |              --- -------               | TITLE
    48 				; 7  |                                        |
    49 				; 8  |Help the frogs escape evil Doc Hopper's | INSTXT_1
    50 				; 9  |Frog Legs Fast Food Franchise! But, the | INSTXT_1
    51 				; 10 |frogs must cross piranha-infested rivers| INSTXT_1
    52 				; 11 |to reach freedom. You have three chances| INSTXT_1
    53 				; 12 |to prove your frog management skills by | INSTXT_1
    54 				; 13 |directing frogs to jump on boats in the | INSTXT_1
    55 				; 14 |rivers. Land in the middle of the boats.| INSTXT_1
    56 				; 15 |Do not fall off or jump in the river.   | INSTXT_1
    57 				; 16 |                                        |
    58 				; 17 |Scoring:                                | INSTXT_2
    59 				; 18 |    10 points for each jump forward.    | INSTXT_2
    60 				; 19 |   500 points for each saved frog.      | INSTXT_2
    61 				; 20 |                                        |
    62 				; 21 |Use the joystick control to jump        | INSTXT_3
    63 				; 22 |forward, left, and right.               | INSTXT_3
    64 				; 23 |                                        |
    65 				; 24 | Press the joystick button to continue. | ANYBUTTON_MEM
    66 				; 25 |(c) November 1983 by DalesOft  Written b| SCROLLING CREDIT
    67 				;    +----------------------------------------+
    68
    69 				; ==========================================================================
    70 				; Give a display number below the VBI routine can set the Display List,
    71 				; and populate zero page pointers for other routines.
    72 				; --------------------------------------------------------------------------
    73
    74 = 0000			DISPLAY_TITLE = 0
    75 = 0001			DISPLAY_GAME  = 1
    76 = 0002			DISPLAY_WIN   = 2
    77 = 0003			DISPLAY_DEAD  = 3
    78 = 0004			DISPLAY_OVER  = 4
    79
    80 = 0005			MAX_DISPLAYS  = 5
    81
    82 				; Version 01, and 02  used graphics control characters in Antic Text 
    83 				; Mode 2 for the title.  Version 03 uses 6 lines of Map Mode 9 in place 
    84 				; of the 3 lines of Text Mode 2.  Real graphics ensue...
    85 				; Mode 9 requires only 10 bytes per line.  Therefore only 20 bytes 
    86 				; for 2 lines which cover the same screen real-estate (8 scan lines) 
    87 				; as the text line they replace.  The text line requires 40 bytes which 
    88 				; doesn't include the character set data needed for the Text mode.
    89 				; In V03 we're replacing the V02 scrolling with glitzier color 
    90 				; transitions as the Map mode allows full use of color and the 
    91 				; individual lines allow 6 easy transitions in this space instead 
    92 				; of 3 with the Text mode.  
    93 				; Also, the Title screen will add a flying frog demo, so that's the 
    94 				; eye candy for Version 03.
    95
    96 				; New DLI updates.....  
    97 				; Before score line 1, need to set all PM registers.
    98 				; After score line 1 need a minimal line to burn off the second entry in the tables.
    99 				; Need a line before gfx to set all the regular player's attributes.
   100 				; May need to insert some blanks between lines to allow more time. 
   101
   102
   103 4600			TITLE_DISPLAYLIST
   104 4600-46EB> 70 B0			.byte DL_BLANK_8, DL_BLANK_4|DL_DLI
   105 4602 20				.byte DL_BLANK_3                         ; 15 blank scan lines (instead of the usual 24).
   106 					;                                                    SCORE DLI 0/Score1 sets COLPF1, COLPF2/COLBK for score text, and PMG
   107 4603				mDL_LMS DL_TEXT_2|DL_DLI,SCORE_MEM1      ; (1-8)     Labels for scores 1.
Macro: MDL_LMS [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/ANTIC.asm]
     5 = 0002				MDL_TEMP=DL_TEXT_2|DL_DLI&$0F
    11 4603 C2				.byte DL_TEXT_2|DL_DLI|DL_LMS
    12 4604 00 4C			.word SCORE_MEM1   
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03DisplayLists.asm
   108 					;                                                    SCORE DLI 1/Score2 sets COLPF1, COLPF2/COLBK for score text, and PMG
   109 4606 00				.byte DL_BLANK_1                         ; (9)
   110
   111 4607				mDL_LMS DL_TEXT_2,SCORE_MEM2             ; (10-17)   Labels for Scores 2.
Macro: MDL_LMS [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/ANTIC.asm]
     5 = 0002				MDL_TEMP=DL_TEXT_2&$0F
    11 4607 42				.byte DL_TEXT_2|DL_LMS
    12 4608 28 4C			.word SCORE_MEM2   
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03DisplayLists.asm
   112
   113 460A A0				.byte DL_BLANK_3|DL_DLI                  ; (18-20)   Blank before Title graphics
   114 					;                                                    DLI 2/SPLASH_PMGSPECS2_DLI - Load PM Specs + COLPF0_COLBK_DLI
   115 					;                Title Graphics... HSCROL means to show all color clocks LMS must be -1, HSCROL 0
   116 = 460C			TT_LMS0 = [* + 1]                            ;           Plus 1 is the address of the display list LMS
   117 460B				mDL_LMS DL_MAP_9|DL_DLI|DL_HSCROLL,TITLE_START     ; (21-24)   DLI 3/COLPF0_COLBK_DLI Set COLPF0 for Line 2
Macro: MDL_LMS [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/ANTIC.asm]
     5 = 0089				MDL_TEMP=DL_MAP_9|DL_DLI|DL_HSCROLL&$0F
    11 460B D9				.byte DL_MAP_9|DL_DLI|DL_HSCROLL|DL_LMS
    12 460C 3F 48			.word TITLE_START   
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03DisplayLists.asm
   118 = 460F			TT_LMS1 = [* + 1]                            ;           Plus 1 is the address of the display list LMS
   119 460E				mDL_LMS DL_MAP_9|DL_DLI|DL_HSCROLL,TITLE_START+20  ; (25-28)   DLI 4/COLPF0_COLBK_DLI Set COLPF0 for Line 3
Macro: MDL_LMS [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/ANTIC.asm]
     5 = 0089				MDL_TEMP=DL_MAP_9|DL_DLI|DL_HSCROLL&$0F
    11 460E D9				.byte DL_MAP_9|DL_DLI|DL_HSCROLL|DL_LMS
    12 460F 53 48			.word TITLE_START+20   
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03DisplayLists.asm
   120 = 4612			TT_LMS2 = [* + 1]                            ;           Plus 1 is the address of the display list LMS
   121 4611				mDL_LMS DL_MAP_9|DL_DLI|DL_HSCROLL,TITLE_START+40  ; (29-32)   DLI 5/COLPF0_COLBK_DLI Set COLPF0 for Line 4
Macro: MDL_LMS [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/ANTIC.asm]
     5 = 0089				MDL_TEMP=DL_MAP_9|DL_DLI|DL_HSCROLL&$0F
    11 4611 D9				.byte DL_MAP_9|DL_DLI|DL_HSCROLL|DL_LMS
    12 4612 67 48			.word TITLE_START+40   
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03DisplayLists.asm
   122 = 4615			TT_LMS3 = [* + 1]                            ;           Plus 1 is the address of the display list LMS
   123 4614				mDL_LMS DL_MAP_9|DL_DLI|DL_HSCROLL,TITLE_START+60  ; (33-36)   DLI 6/COLPF0_COLBK_DLI Set COLPF0 for Line 5
Macro: MDL_LMS [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/ANTIC.asm]
     5 = 0089				MDL_TEMP=DL_MAP_9|DL_DLI|DL_HSCROLL&$0F
    11 4614 D9				.byte DL_MAP_9|DL_DLI|DL_HSCROLL|DL_LMS
    12 4615 7B 48			.word TITLE_START+60   
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03DisplayLists.asm
   124 = 4618			TT_LMS4 = [* + 1]                            ;           Plus 1 is the address of the display list LMS
   125 4617				mDL_LMS DL_MAP_9|DL_DLI|DL_HSCROLL,TITLE_START+80  ; (37-40)   DLI 7/COLPF0_COLBK_DLI Set COLPF0 for Line 6
Macro: MDL_LMS [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/ANTIC.asm]
     5 = 0089				MDL_TEMP=DL_MAP_9|DL_DLI|DL_HSCROLL&$0F
    11 4617 D9				.byte DL_MAP_9|DL_DLI|DL_HSCROLL|DL_LMS
    12 4618 8F 48			.word TITLE_START+80   
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03DisplayLists.asm
   126 = 461B			TT_LMS5 = [* + 1]                            ;           Plus 1 is the address of the display list LMS
   127 461A				mDL_LMS DL_MAP_9|DL_DLI|DL_HSCROLL,TITLE_START+100 ; (41-44)   DLI 8/COLPF0_COLBK_DLI Set COLPF0 for underlines
Macro: MDL_LMS [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/ANTIC.asm]
     5 = 0089				MDL_TEMP=DL_MAP_9|DL_DLI|DL_HSCROLL&$0F
    11 461A D9				.byte DL_MAP_9|DL_DLI|DL_HSCROLL|DL_LMS
    12 461B A3 48			.word TITLE_START+100   
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03DisplayLists.asm
   128
   129 461D 10				.byte   DL_BLANK_2                       ; (45-46)   An empty line.      2
   130 461E				mDL_LMS DL_MAP_9,TITLE_UNDERLINE         ; (47-50)   Underlines        + 4
Macro: MDL_LMS [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/ANTIC.asm]
     5 = 0009				MDL_TEMP=DL_MAP_9&$0F
    11 461E 49				.byte DL_MAP_9|DL_LMS
    12 461F B8 48			.word TITLE_UNDERLINE   
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03DisplayLists.asm
   131 4621 90				.byte   DL_BLANK_2|DL_DLI                ; (51-52)   An empty line.    + 2 = 8 
   132 					;                                                    DLI 9/TITLE_DLI_BLACKOUT set BLACK for COLBK.
   133
   134 4622 F0				.byte   DL_BLANK_8|DL_DLI                ; (53-60)   DLI 10/TITLE_DLI_TEXTBLOCK set AQUA for COLBK and COLPF2, and set COLPF1
   135
   136 					;                 Basic Instructions... 
   137 4623				mDL_LMS DL_TEXT_2|DL_DLI,INSTRUCT_MEM1   ; (61-68)   DLI 11/TITLE_DLI_TEXTBLOCK set COLPF1 text
Macro: MDL_LMS [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/ANTIC.asm]
     5 = 0002				MDL_TEMP=DL_TEXT_2|DL_DLI&$0F
    11 4623 C2				.byte DL_TEXT_2|DL_DLI|DL_LMS
    12 4624 68 49			.word INSTRUCT_MEM1   
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03DisplayLists.asm
   138 4626 82				.byte   DL_TEXT_2|DL_DLI                 ; (69-76)   DLI 12/TITLE_DLI_TEXTBLOCK set COLPF1 text
   139 4627 82				.byte   DL_TEXT_2|DL_DLI                 ; (77-84)   DLI 13/TITLE_DLI_TEXTBLOCK set COLPF1 text
   140 4628				mDL_LMS DL_TEXT_2|DL_DLI,INSTRUCT_MEM4   ; (85-92)   DLI 14/TITLE_DLI_TEXTBLOCK set COLPF1 text
Macro: MDL_LMS [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/ANTIC.asm]
     5 = 0002				MDL_TEMP=DL_TEXT_2|DL_DLI&$0F
    11 4628 C2				.byte DL_TEXT_2|DL_DLI|DL_LMS
    12 4629 00 4A			.word INSTRUCT_MEM4   
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03DisplayLists.asm
   141 462B 82				.byte   DL_TEXT_2|DL_DLI                 ; (93-100)  DLI 15/TITLE_DLI_TEXTBLOCK set COLPF1 text
   142 462C 82				.byte   DL_TEXT_2|DL_DLI                 ; (101-108) DLI 16/TITLE_DLI_TEXTBLOCK set COLPF1 text
   143 462D 82				.byte   DL_TEXT_2|DL_DLI                 ; (109-116) DLI 17/TITLE_DLI_TEXTBLOCK set COLPF1 text
   144 462E 82				.byte   DL_TEXT_2|DL_DLI                 ; (117-124) DLI 18/TITLE_DLI_BLACKOUT set BLACK for COLBK
   145
   146 462F F0				.byte   DL_BLANK_8|DL_DLI                ; (125-132) DLI 19/TITLE_DLI_TEXTBLOCK set ORANGE2 for COLBK and COLPF2, set COLPF1 text
   147
   148 					;                                        ; Scoring.
   149 4630 82				.byte   DL_TEXT_2|DL_DLI                 ; (133-140) DLI 20/TITLE_DLI_TEXTBLOCK set COLPF1 text
   150 4631				mDL_LMS DL_TEXT_2|DL_DLI,SCORING_MEM2    ; (141-148) DLI 21/TITLE_DLI_TEXTBLOCK set COLPF1 text
Macro: MDL_LMS [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/ANTIC.asm]
     5 = 0002				MDL_TEMP=DL_TEXT_2|DL_DLI&$0F
    11 4631 C2				.byte DL_TEXT_2|DL_DLI|DL_LMS
    12 4632 00 4B			.word SCORING_MEM2   
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03DisplayLists.asm
   151 4634 82				.byte   DL_TEXT_2|DL_DLI                 ; (149-156) DLI 22/TITLE_DLI_BLACKOUT set BLACK for COLBK
   152
   153 4635 F0				.byte   DL_BLANK_8|DL_DLI                ; (157-164) DLI 23/TITLE_DLI_TEXTBLOCK set PINK for COLBK and COLPF2, and set COLPF1 text
   154
   155 					;                 Game Controls...
   156 4636 82				.byte   DL_TEXT_2|DL_DLI                 ; (165-172) DLI 24/TITLE_DLI_TEXTBLOCK set COLPF1 text
   157 4637 82				.byte   DL_TEXT_2|DL_DLI                 ; (173-180) DLI 25/TITLE_DLI_BLACKOUT set BLACK for COLBK
   158
   159 4638 F0				.byte   DL_BLANK_8|DL_DLI                ; (181-188) DLI 26/SCP1 sets COLBK, COLPF2, COLPF1 colors. Then sets up for SPC2
   160 4639 00				.byte   DL_BLANK_1                       ; (189)     One extra to line up credit with the same line on the game screen 
   161
   162 463A				mDL_JMP BOTTOM_OF_DISPLAY                ; (190-197, 198, 199-206) End of display.  See Page 0 for this evil.
Macro: MDL_JMP [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/ANTIC.asm]
     6 463A 01				.byte DL_JUMP
     7 463B F2 00			.word BOTTOM_OF_DISPLAY   
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03DisplayLists.asm
   163
   164
   165 				; Revised V03 Main Game Play Screen:
   166 				; FYI: Old boats.
   167 				; 8  | [QQQQ>        [QQQQ>       [QQQQ>      | TEXT1_2
   168 				; 9  |      <QQQQ]        <QQQQ]    <QQQQ]    | TEXT1_2
   169 				; Old:  [QQQQ>
   170 				; New: [[QQQQQ>
   171
   172 				; New boats are larger to provide more safe surface for the larger 
   173 				; frog and to provide some additional graphics enhancement for 
   174 				; the boats.  Illustration below shows the lines with the 
   175 				; additional boat data needed for scrolling.
   176
   177 				; Line placement is jiggled about to add enough blank lines and 
   178 				; filler space to make the Display List Interrupts work, so the 
   179 				; gap at the  bottom of the illustration is not real -- its scan 
   180 				; lines are distributed between the other lines.
   181 				; Given the number of things that the Display List Interrupts must 
   182 				; reload between each line, and the fact that horizontal scrolling 
   183 				; lines results in variable DMA timing to the point where zero CPU 
   184 				; time is available, the DLIs on scrolling lines are moved to the 
   185 				; following line.  Consequently, in order to preserve the color 
   186 				; continuity after a boat line the line following the boat is not 
   187 				; a blank line.   It is a Mode C line filled with COLPF0 pixels. 
   188 				; This allows the DLIs to manage the color transition for the 
   189 				; Background color before it is needed, and delay the update to 
   190 				; COLPF0 until later.
   191
   192 				;    +----------------------------------------+
   193 				; 1  |Score:00000000               00000000:Hi| SCORE_TXT
   194 				; 2  |Frogs:0       00000000000000000000:Saved| SCORE_TXT
   195 				; 3  |                                        | 
   196 				; 4  |BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB| TEXT1_1
   197 				; 5  |[[QQQQQ>        [[QQQQQ>        [[QQQQQ>        [[QQQQQ>        | ; Boats Right
   198 				; 6  |<QQQQQ]]        <QQQQQ]]        <QQQQQ]]        <QQQQQ]]        | ; Boats Left
   199 				; 7  |BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB| TEXT1_2
   200 				; 8  |[[QQQQQ>        [[QQQQQ>        [[QQQQQ>        [[QQQQQ>        |
   201 				; 9  |<QQQQQ]]        <QQQQQ]]        <QQQQQ]]        <QQQQQ]]        |
   202 				; 10 |BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB| TEXT1_3
   203 				; 11 |[[QQQQQ>        [[QQQQQ>        [[QQQQQ>        [[QQQQQ>        |
   204 				; 12 |<QQQQQ]]        <QQQQQ]]        <QQQQQ]]        <QQQQQ]]        |
   205 				; 13 |BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB| TEXT1_4
   206 				; 14 |[[QQQQQ>        [[QQQQQ>        [[QQQQQ>        [[QQQQQ>        |
   207 				; 15 |<QQQQQ]]        <QQQQQ]]        <QQQQQ]]        <QQQQQ]]        |
   208 				; 16 |BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB| TEXT1_5
   209 				; 17 |[[QQQQQ>        [[QQQQQ>        [[QQQQQ>        [[QQQQQ>        |
   210 				; 18 |<QQQQQ]]        <QQQQQ]]        <QQQQQ]]        <QQQQQ]]        |
   211 				; 19 |BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB| TEXT1_6
   212 				; 20 |[[QQQQQ>        [[QQQQQ>        [[QQQQQ>        [[QQQQQ>        |
   213 				; 21 |<QQQQQ]]        <QQQQQ]]        <QQQQQ]]        <QQQQQ]]        |
   214 				; 22 |BBBBBBBBBBBBBBBBBBBOBBBBBBBBBBBBBBBBBBBB| TEXT2
   215 				; 23 |                                        |
   216 				; 24 |                                        |
   217 				; 25 |(c) November 1983 by DalesOft  Written b| SCROLLING CREDIT
   218 				;    +----------------------------------------+
   219
   220 				; New DLI updates.....  
   221 				; Before score line 1, need to set all PM registers.
   222 				; After score line 1 need to set everything for line 2.
   223 				; Need a line before gfx to set all the regular player's attributes.
   224 				; May need to insert some blanks between lines to allow more time. 
   225 				; Beach DLI may need to start earlier, run longer, and PM properties 
   226 				; may need to be setup first before playfield.
   227
   228 463D			GAME_DISPLAYLIST
   229 463D 70 B0			.byte DL_BLANK_8, DL_BLANK_4|DL_DLI
   230 463F 20				.byte DL_BLANK_3                                ; 15 blank scan lines.  
   231 					;                                                           SCORE DLI 0/Score1 sets COLPF1, COLPF2/COLBK for score text.
   232 					
   233 4640				mDL_LMS DL_TEXT_2|DL_DLI,SCORE_MEM1             ; (1-8)     Labels for scores 1. 
Macro: MDL_LMS [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/ANTIC.asm]
     5 = 0002				MDL_TEMP=DL_TEXT_2|DL_DLI&$0F
    11 4640 C2				.byte DL_TEXT_2|DL_DLI|DL_LMS
    12 4641 00 4C			.word SCORE_MEM1   
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03DisplayLists.asm
   234 					;                                                           SCORE DLI 1/Score2 sets COLPF1, COLPF2/COLBK for score text.
   235
   236 4643 00				.byte DL_BLANK_1                                ; (9)      
   237
   238 				; ========== Start
   239
   240 4644				mDL_LMS DL_TEXT_2|DL_DLI,SCORE_MEM2             ; (10-17)   Labels for Scores 2.
Macro: MDL_LMS [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/ANTIC.asm]
     5 = 0002				MDL_TEMP=DL_TEXT_2|DL_DLI&$0F
    11 4644 C2				.byte DL_TEXT_2|DL_DLI|DL_LMS
    12 4645 28 4C			.word SCORE_MEM2   
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03DisplayLists.asm
   241 					;                                                           DLI 2/BEACH0 sets COLPF0,1,2,3,BK for Beach. (row 18)
   242
   243 				; ========== 1
   244
   245 4647 30				.byte DL_BLANK_4                                ; (18-21)   Blank before Beach for time.
   246 					
   247 = 4649			PF_LMS0 = [* + 1]                                   ;           Plus 1 is the address of the display list LMS
   248 4648				mDL_LMS DL_TEXT_4|DL_DLI,PLAYFIELD_MEM0         ; (22-29)   Beach. 
Macro: MDL_LMS [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/ANTIC.asm]
     5 = 0004				MDL_TEMP=DL_TEXT_4|DL_DLI&$0F
    11 4648 C4				.byte DL_TEXT_4|DL_DLI|DL_LMS
    12 4649 A0 4B			.word PLAYFIELD_MEM0   
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03DisplayLists.asm
   249 					;                                                           DLI 3/BEACH2BOAT sets boats right (row 17) COLPF0,1,2,3,BK,HSCROLL.
   250 464B 00				.byte DL_BLANK_1                                ; (30)      One scan line 
   251
   252 = 464D			PF_LMS1 = [* + 1] ; Right
   253 464C				mDL_LMS DL_TEXT_4|DL_HSCROLL,PLAYFIELD_MEM1     ; (31-38)   Boats Right (row 17)
Macro: MDL_LMS [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/ANTIC.asm]
     5 = 0004				MDL_TEMP=DL_TEXT_4|DL_HSCROLL&$0F
    11 464C 54				.byte DL_TEXT_4|DL_HSCROLL|DL_LMS
    12 464D 00 48			.word PLAYFIELD_MEM1   
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03DisplayLists.asm
   254
   255 464F				mDL_LMS DL_MAP_C|DL_DLI,MODE_C_COLPF0           ; (39)      One scan line 
Macro: MDL_LMS [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/ANTIC.asm]
     5 = 000C				MDL_TEMP=DL_MAP_C|DL_DLI&$0F
    11 464F CC				.byte DL_MAP_C|DL_DLI|DL_LMS
    12 4650 50 4C			.word MODE_C_COLPF0   
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03DisplayLists.asm
   256 					;                                                           DLI 4/BOAT2BOAT sets boats left (row 16) COLPF0,1,2,3,BK,HSCROLL.
   257 4652 00				.byte DL_BLANK_1                                ; (40)      One scan line free time for DLI
   258
   259 = 4654			PF_LMS2 = [* + 1] ; Left
   260 4653				mDL_LMS DL_TEXT_4|DL_HSCROLL,PLAYFIELD_MEM2+8   ; (41-48)   Boats Left (row 16)
Macro: MDL_LMS [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/ANTIC.asm]
     5 = 0004				MDL_TEMP=DL_TEXT_4|DL_HSCROLL&$0F
    11 4653 54				.byte DL_TEXT_4|DL_HSCROLL|DL_LMS
    12 4654 08 49			.word PLAYFIELD_MEM2+8   
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03DisplayLists.asm
   261
   262 				; ========== 2
   263
   264 4656				mDL_LMS DL_MAP_C|DL_DLI,MODE_C_COLPF0           ; (49)      One scan line 
Macro: MDL_LMS [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/ANTIC.asm]
     5 = 000C				MDL_TEMP=DL_MAP_C|DL_DLI&$0F
    11 4656 CC				.byte DL_MAP_C|DL_DLI|DL_LMS
    12 4657 50 4C			.word MODE_C_COLPF0   
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03DisplayLists.asm
   265 					;                                                           DLI 5/BOAT2BEACH sets COLPF0,1,2,3,BK for Beach (row 15) 
   266
   267 = 465A			PF_LMS3 = [* + 1]                                   ;           Plus 1 is the address of the display list LMS
   268 4659				mDL_LMS DL_TEXT_4|DL_DLI,PLAYFIELD_MEM3         ; (50-57)   Beach. 
Macro: MDL_LMS [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/ANTIC.asm]
     5 = 0004				MDL_TEMP=DL_TEXT_4|DL_DLI&$0F
    11 4659 C4				.byte DL_TEXT_4|DL_DLI|DL_LMS
    12 465A C0 4B			.word PLAYFIELD_MEM3   
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03DisplayLists.asm
   269 					;                                                           DLI 6/BEACH2BOAT sets boats right (row 14) COLPF0,1,2,3,BK,HSCROLL.
   270 465C 00				.byte DL_BLANK_1                                ; (58)      One scan line 
   271
   272 = 465E			PF_LMS4 = [* + 1] ; Right
   273 465D				mDL_LMS DL_TEXT_4|DL_HSCROLL,PLAYFIELD_MEM4+4   ; (59-66)   Boats Right (row 14)
Macro: MDL_LMS [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/ANTIC.asm]
     5 = 0004				MDL_TEMP=DL_TEXT_4|DL_HSCROLL&$0F
    11 465D 54				.byte DL_TEXT_4|DL_HSCROLL|DL_LMS
    12 465E 04 48			.word PLAYFIELD_MEM4+4   
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03DisplayLists.asm
   274
   275 4660				mDL_LMS DL_MAP_C|DL_DLI,MODE_C_COLPF0           ; (67)      One scan line 
Macro: MDL_LMS [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/ANTIC.asm]
     5 = 000C				MDL_TEMP=DL_MAP_C|DL_DLI&$0F
    11 4660 CC				.byte DL_MAP_C|DL_DLI|DL_LMS
    12 4661 50 4C			.word MODE_C_COLPF0   
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03DisplayLists.asm
   276 					;                                                           DLI 7/BOAT2BOAT sets boats left (row 13) COLPF0,1,2,3,BK,HSCROLL.
   277 4663 00				.byte DL_BLANK_1                                ; (68)      One scan line free time for DLI
   278
   279 = 4665			PF_LMS5 = [* + 1] ; Left
   280 4664				mDL_LMS DL_TEXT_4|DL_HSCROLL,PLAYFIELD_MEM5+12  ; (69-76)   Boats Left (row 13)
Macro: MDL_LMS [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/ANTIC.asm]
     5 = 0004				MDL_TEMP=DL_TEXT_4|DL_HSCROLL&$0F
    11 4664 54				.byte DL_TEXT_4|DL_HSCROLL|DL_LMS
    12 4665 0C 49			.word PLAYFIELD_MEM5+12   
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03DisplayLists.asm
   281
   282 				; ========== 3
   283
   284 4667				mDL_LMS DL_MAP_C|DL_DLI,MODE_C_COLPF0           ; (77)      One scan line 
Macro: MDL_LMS [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/ANTIC.asm]
     5 = 000C				MDL_TEMP=DL_MAP_C|DL_DLI&$0F
    11 4667 CC				.byte DL_MAP_C|DL_DLI|DL_LMS
    12 4668 50 4C			.word MODE_C_COLPF0   
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03DisplayLists.asm
   285 					;                                                           DLI 8/BOAT2BEACH sets COLPF0,1,2,3,BK for Beach (row 12) 
   286
   287 = 466B			PF_LMS6 = [* + 1]                                   ;           Plus 1 is the address of the display list LMS
   288 466A				mDL_LMS DL_TEXT_4|DL_DLI,PLAYFIELD_MEM6         ; (78-85)   Beach. 
Macro: MDL_LMS [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/ANTIC.asm]
     5 = 0004				MDL_TEMP=DL_TEXT_4|DL_DLI&$0F
    11 466A C4				.byte DL_TEXT_4|DL_DLI|DL_LMS
    12 466B B4 4B			.word PLAYFIELD_MEM6   
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03DisplayLists.asm
   289 					;                                                           DLI 9/BEACH2BOAT sets boats right (row 11) COLPF0,1,2,3,BK,HSCROLL.
   290 466D 00				.byte DL_BLANK_1                                ; (86)      One scan line 
   291
   292 = 466F			PF_LMS7 = [* + 1] ; Right
   293 466E				mDL_LMS DL_TEXT_4|DL_HSCROLL,PLAYFIELD_MEM7+4   ; (87-94)   Boats Right (row 11)
Macro: MDL_LMS [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/ANTIC.asm]
     5 = 0004				MDL_TEMP=DL_TEXT_4|DL_HSCROLL&$0F
    11 466E 54				.byte DL_TEXT_4|DL_HSCROLL|DL_LMS
    12 466F 04 48			.word PLAYFIELD_MEM7+4   
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03DisplayLists.asm
   294
   295 4671				mDL_LMS DL_MAP_C|DL_DLI,MODE_C_COLPF0           ; (95)      One scan line 
Macro: MDL_LMS [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/ANTIC.asm]
     5 = 000C				MDL_TEMP=DL_MAP_C|DL_DLI&$0F
    11 4671 CC				.byte DL_MAP_C|DL_DLI|DL_LMS
    12 4672 50 4C			.word MODE_C_COLPF0   
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03DisplayLists.asm
   296 					;                                                           DLI 10/BOAT2BOAT sets boats left (row 10) COLPF0,1,2,3,BK,HSCROLL.
   297 4674 00				.byte DL_BLANK_1                                ; (96)      One scan line free time for DLI
   298
   299 = 4676			PF_LMS8 = [* + 1] ; Left
   300 4675				mDL_LMS DL_TEXT_4|DL_HSCROLL,PLAYFIELD_MEM8+12  ; (97-104)  Boats Left (row 10)
Macro: MDL_LMS [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/ANTIC.asm]
     5 = 0004				MDL_TEMP=DL_TEXT_4|DL_HSCROLL&$0F
    11 4675 54				.byte DL_TEXT_4|DL_HSCROLL|DL_LMS
    12 4676 0C 49			.word PLAYFIELD_MEM8+12   
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03DisplayLists.asm
   301
   302 				; ========== 4
   303
   304 4678				mDL_LMS DL_MAP_C|DL_DLI,MODE_C_COLPF0           ; (105)     One scan line 
Macro: MDL_LMS [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/ANTIC.asm]
     5 = 000C				MDL_TEMP=DL_MAP_C|DL_DLI&$0F
    11 4678 CC				.byte DL_MAP_C|DL_DLI|DL_LMS
    12 4679 50 4C			.word MODE_C_COLPF0   
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03DisplayLists.asm
   305 					;                                                           DLI 11/BOAT2BEACH sets COLPF0,1,2,3,BK for Beach (row 9) 
   306
   307 = 467C			PF_LMS9 = [* + 1]                                   ;           Plus 1 is the address of the display list LMS
   308 467B				mDL_LMS DL_TEXT_4|DL_DLI,PLAYFIELD_MEM9         ; (106-113) Beach. 
Macro: MDL_LMS [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/ANTIC.asm]
     5 = 0004				MDL_TEMP=DL_TEXT_4|DL_DLI&$0F
    11 467B C4				.byte DL_TEXT_4|DL_DLI|DL_LMS
    12 467C A7 4B			.word PLAYFIELD_MEM9   
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03DisplayLists.asm
   309 					;                                                           DLI 12/BEACH2BOAT sets boats right (row 8) COLPF0,1,2,3,BK,HSCROLL.
   310 467E 00				.byte DL_BLANK_1                                ; (114)     One scan line 
   311
   312 = 4680			PF_LMS10 = [* + 1] ; Right
   313 467F				mDL_LMS DL_TEXT_4|DL_HSCROLL,PLAYFIELD_MEM10+8  ; (115-122) Boats Right (row 8)
Macro: MDL_LMS [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/ANTIC.asm]
     5 = 0004				MDL_TEMP=DL_TEXT_4|DL_HSCROLL&$0F
    11 467F 54				.byte DL_TEXT_4|DL_HSCROLL|DL_LMS
    12 4680 08 48			.word PLAYFIELD_MEM10+8   
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03DisplayLists.asm
   314
   315 4682				mDL_LMS DL_MAP_C|DL_DLI,MODE_C_COLPF0           ; (123)     One scan line 
Macro: MDL_LMS [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/ANTIC.asm]
     5 = 000C				MDL_TEMP=DL_MAP_C|DL_DLI&$0F
    11 4682 CC				.byte DL_MAP_C|DL_DLI|DL_LMS
    12 4683 50 4C			.word MODE_C_COLPF0   
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03DisplayLists.asm
   316 					;                                                           DLI 13/BOAT2BOAT sets boats left (row 7) COLPF0,1,2,3,BK,HSCROLL.
   317 4685 00				.byte DL_BLANK_1                                ; (124)     One scan line free time for DLI
   318
   319 = 4687			PF_LMS11 = [* + 1] ; Left
   320 4686				mDL_LMS DL_TEXT_4|DL_HSCROLL,PLAYFIELD_MEM11+12 ; (125-132) Boats Left (row 7)
Macro: MDL_LMS [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/ANTIC.asm]
     5 = 0004				MDL_TEMP=DL_TEXT_4|DL_HSCROLL&$0F
    11 4686 54				.byte DL_TEXT_4|DL_HSCROLL|DL_LMS
    12 4687 0C 49			.word PLAYFIELD_MEM11+12   
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03DisplayLists.asm
   321
   322 				; ========== 5
   323
   324 4689				mDL_LMS DL_MAP_C|DL_DLI,MODE_C_COLPF0           ; (133)     One scan line 
Macro: MDL_LMS [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/ANTIC.asm]
     5 = 000C				MDL_TEMP=DL_MAP_C|DL_DLI&$0F
    11 4689 CC				.byte DL_MAP_C|DL_DLI|DL_LMS
    12 468A 50 4C			.word MODE_C_COLPF0   
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03DisplayLists.asm
   325 					;                                                           DLI 14/BOAT2BEACH sets COLPF0,1,2,3,BK for Beach (row 6) 
   326
   327 = 468D			PF_LMS12 = [* + 1]                                  ;           Plus 1 is the address of the display list LMS
   328 468C				mDL_LMS DL_TEXT_4|DL_DLI,PLAYFIELD_MEM12        ; (134-141) Beach. 
Macro: MDL_LMS [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/ANTIC.asm]
     5 = 0004				MDL_TEMP=DL_TEXT_4|DL_DLI&$0F
    11 468C C4				.byte DL_TEXT_4|DL_DLI|DL_LMS
    12 468D BD 4B			.word PLAYFIELD_MEM12   
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03DisplayLists.asm
   329 					;                                                           DLI 15/BEACH2BOAT sets boats right (row 5) COLPF0,1,2,3,BK,HSCROLL.
   330 468F 00				.byte DL_BLANK_1                                ; (142)     One scan line 
   331
   332 = 4691			PF_LMS13 = [* + 1] ; Right
   333 4690				mDL_LMS DL_TEXT_4|DL_HSCROLL,PLAYFIELD_MEM13    ; (143-150) Boats Right (row 5)
Macro: MDL_LMS [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/ANTIC.asm]
     5 = 0004				MDL_TEMP=DL_TEXT_4|DL_HSCROLL&$0F
    11 4690 54				.byte DL_TEXT_4|DL_HSCROLL|DL_LMS
    12 4691 00 48			.word PLAYFIELD_MEM13   
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03DisplayLists.asm
   334
   335 4693				mDL_LMS DL_MAP_C|DL_DLI,MODE_C_COLPF0           ; (151)     One scan line 
Macro: MDL_LMS [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/ANTIC.asm]
     5 = 000C				MDL_TEMP=DL_MAP_C|DL_DLI&$0F
    11 4693 CC				.byte DL_MAP_C|DL_DLI|DL_LMS
    12 4694 50 4C			.word MODE_C_COLPF0   
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03DisplayLists.asm
   336 					;                                                           DLI 16/BOAT2BOAT sets boats left (row 4) COLPF0,1,2,3,BK,HSCROLL.
   337 4696 00				.byte DL_BLANK_1                                ; (152)     One scan line free time for DLI
   338
   339 = 4698			PF_LMS14 = [* + 1] ; Left
   340 4697				mDL_LMS DL_TEXT_4|DL_HSCROLL,PLAYFIELD_MEM14+4  ; (153-160) Boats Left (row 4)
Macro: MDL_LMS [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/ANTIC.asm]
     5 = 0004				MDL_TEMP=DL_TEXT_4|DL_HSCROLL&$0F
    11 4697 54				.byte DL_TEXT_4|DL_HSCROLL|DL_LMS
    12 4698 04 49			.word PLAYFIELD_MEM14+4   
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03DisplayLists.asm
   341
   342 				; ========== 6
   343
   344 469A				mDL_LMS DL_MAP_C|DL_DLI,MODE_C_COLPF0           ; (161)     One scan line 
Macro: MDL_LMS [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/ANTIC.asm]
     5 = 000C				MDL_TEMP=DL_MAP_C|DL_DLI&$0F
    11 469A CC				.byte DL_MAP_C|DL_DLI|DL_LMS
    12 469B 50 4C			.word MODE_C_COLPF0   
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03DisplayLists.asm
   345 					;                                                           DLI 17/BOAT2BEACH sets COLPF0,1,2,3,BK for Beach (row 3) 
   346
   347 = 469E			PF_LMS15 = [* + 1]                                  ;           Plus 1 is the address of the display list LMS
   348 469D				mDL_LMS DL_TEXT_4|DL_DLI,PLAYFIELD_MEM15        ; (162-169) Beach. 
Macro: MDL_LMS [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/ANTIC.asm]
     5 = 0004				MDL_TEMP=DL_TEXT_4|DL_DLI&$0F
    11 469D C4				.byte DL_TEXT_4|DL_DLI|DL_LMS
    12 469E AE 4B			.word PLAYFIELD_MEM15   
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03DisplayLists.asm
   349 					;                                                           DLI 18/BEACH2BOAT sets boats right (row 2) COLPF0,1,2,3,BK,HSCROLL.
   350 46A0 00				.byte DL_BLANK_1                                ; (170)     One scan line 
   351
   352 = 46A2			PF_LMS16 = [* + 1] ; Right
   353 46A1				mDL_LMS DL_TEXT_4|DL_HSCROLL,PLAYFIELD_MEM16+8  ; (171-178) Boats Right (row 2)
Macro: MDL_LMS [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/ANTIC.asm]
     5 = 0004				MDL_TEMP=DL_TEXT_4|DL_HSCROLL&$0F
    11 46A1 54				.byte DL_TEXT_4|DL_HSCROLL|DL_LMS
    12 46A2 08 48			.word PLAYFIELD_MEM16+8   
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03DisplayLists.asm
   354
   355 46A4				mDL_LMS DL_MAP_C|DL_DLI,MODE_C_COLPF0           ; (179)     One scan line 
Macro: MDL_LMS [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/ANTIC.asm]
     5 = 000C				MDL_TEMP=DL_MAP_C|DL_DLI&$0F
    11 46A4 CC				.byte DL_MAP_C|DL_DLI|DL_LMS
    12 46A5 50 4C			.word MODE_C_COLPF0   
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03DisplayLists.asm
   356 					;                                                           DLI 19/BOAT2BOAT sets boats left (row 1) COLPF0,1,2,3,BK,HSCROLL.
   357 46A7 00				.byte DL_BLANK_1                                ; (180)     One scan line free time for DLI
   358
   359 = 46A9			PF_LMS17 = [* + 1] ; Left
   360 46A8				mDL_LMS DL_TEXT_4|DL_HSCROLL,PLAYFIELD_MEM17+12 ; (181-188) Boats Left (row 1)
Macro: MDL_LMS [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/ANTIC.asm]
     5 = 0004				MDL_TEMP=DL_TEXT_4|DL_HSCROLL&$0F
    11 46A8 54				.byte DL_TEXT_4|DL_HSCROLL|DL_LMS
    12 46A9 0C 49			.word PLAYFIELD_MEM17+12   
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03DisplayLists.asm
   361
   362 				; ========== End Beach 
   363
   364 46AB				mDL_LMS DL_MAP_C|DL_DLI,MODE_C_COLPF0           ; (189)     One scan line 
Macro: MDL_LMS [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/ANTIC.asm]
     5 = 000C				MDL_TEMP=DL_MAP_C|DL_DLI&$0F
    11 46AB CC				.byte DL_MAP_C|DL_DLI|DL_LMS
    12 46AC 50 4C			.word MODE_C_COLPF0   
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03DisplayLists.asm
   365 					;                                                           DLI 20/BOAT2BEACH sets COLPF0,1,2,3,BK for Beach (row 0) 
   366
   367 = 46AF			PF_LMS18 = [* + 1]                                  ;           Plus 1 is the address of the display list LMS
   368 46AE				mDL_LMS DL_TEXT_4|DL_DLI,PLAYFIELD_MEM18        ; (190-197) Beach. 
Macro: MDL_LMS [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/ANTIC.asm]
     5 = 0004				MDL_TEMP=DL_TEXT_4|DL_DLI&$0F
    11 46AE C4				.byte DL_TEXT_4|DL_DLI|DL_LMS
    12 46AF B7 4B			.word PLAYFIELD_MEM18   
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03DisplayLists.asm
   369 					;                                                           DLI 21/SPC2  then calls SPC2 to set COLPF2/COLBK Black
   370
   371 				; ========== End 2
   372
   373 46B1 00				.byte DL_BLANK_1                                ; (198)     One scan line 
   374
   375 46B2				mDL_JMP DL_SCROLLING_CREDIT                     ; (199-206) End of display. No prompt for button. See Page 0 for the evil.
Macro: MDL_JMP [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/ANTIC.asm]
     6 46B2 01				.byte DL_JUMP
     7 46B3 F6 00			.word DL_SCROLLING_CREDIT   
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03DisplayLists.asm
   376
   377
   378
   379 				; Until some other eye candy improvement is conceived, these 
   380 				; three  graphics Display Lists are nearly identical with 
   381 				; the only difference as the bitmap shown in the graphics 
   382 				; section (and the main code color manipulation routines.)
   383
   384 				; So, instead of three display lists, just use one.  The VBI
   385 				; will know which graphics memory address to use for the
   386 				; GFX_LMS in the display list.  And since all the bitmaps are
   387 				; in the same page only the LMS low byte needs to be updated.
   388
   389 				; FROG SAVED screen, 200 scan lines....:
   390 				;    80 scan lines = 20 blank lines (by 4 scan lines each) of color cycling.
   391 				; +  24 scan lines = 6 lines (by 4 scan lines each) of big text.
   392 				; +  80 scan lines = 20 blank lines (by 4 scan lines each) of color cycling.
   393 				; +   8 scan lines = Press A Button Line of text
   394 				; +   8 scan lines = infinitely scrolling credit. 
   395 				; = 200 scan lines.
   396
   397 46B5			FROGSAVED_DISPLAYLIST
   398 46B5			FROGDEAD_DISPLAYLIST
   399 46B5			GAMEOVER_DISPLAYLIST
   400 46B5 F0				.byte DL_BLANK_8|DL_DLI               ; Needed early to zero PM positions
   401 46B6 70				.byte DL_BLANK_8
   402 46B7 A0				.byte DL_BLANK_3|DL_DLI               ; 20 blank scan lines. DLI 0/0 Set COLBK color
   403
   404 					.rept 20                              ; an empty line. times 20
   405 						.BYTE DL_BLANK_4|DL_DLI           
   406 					.ENDR                                 
   406 					.endr                                 ;           DLI 1/19 COLBK Title, COLPF0 gfx
Source: REPT
   405 46B8 B0					.BYTE DL_BLANK_4|DL_DLI           
   405 46B9 B0					.BYTE DL_BLANK_4|DL_DLI           
   405 46BA B0					.BYTE DL_BLANK_4|DL_DLI           
   405 46BB B0					.BYTE DL_BLANK_4|DL_DLI           
   405 46BC B0					.BYTE DL_BLANK_4|DL_DLI           
   405 46BD B0					.BYTE DL_BLANK_4|DL_DLI           
   405 46BE B0					.BYTE DL_BLANK_4|DL_DLI           
   405 46BF B0					.BYTE DL_BLANK_4|DL_DLI           
   405 46C0 B0					.BYTE DL_BLANK_4|DL_DLI           
   405 46C1 B0					.BYTE DL_BLANK_4|DL_DLI           
   405 46C2 B0					.BYTE DL_BLANK_4|DL_DLI           
   405 46C3 B0					.BYTE DL_BLANK_4|DL_DLI           
   405 46C4 B0					.BYTE DL_BLANK_4|DL_DLI           
   405 46C5 B0					.BYTE DL_BLANK_4|DL_DLI           
   405 46C6 B0					.BYTE DL_BLANK_4|DL_DLI           
   405 46C7 B0					.BYTE DL_BLANK_4|DL_DLI           
   405 46C8 B0					.BYTE DL_BLANK_4|DL_DLI           
   405 46C9 B0					.BYTE DL_BLANK_4|DL_DLI           
   405 46CA B0					.BYTE DL_BLANK_4|DL_DLI           
   405 46CB B0					.BYTE DL_BLANK_4|DL_DLI           
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03DisplayLists.asm
   407
   408 = 46CD			GFX_LMS = [* + 1]                         ; Label the low byte of the LMS address.
   409 46CC				mDL_LMS DL_MAP_9|DL_DLI,FROGSAVE_MEM  ; (81-84)   DLI 1/20   COLPF0 gfx
Macro: MDL_LMS [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/ANTIC.asm]
     5 = 0009				MDL_TEMP=DL_MAP_9|DL_DLI&$0F
    11 46CC C9				.byte DL_MAP_9|DL_DLI|DL_LMS
    12 46CD 00 4D			.word FROGSAVE_MEM   
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03DisplayLists.asm
   410 46CF 89				.byte DL_MAP_9|DL_DLI                 ; (85-88)   DLI 1/21   COLPF0 gfx
   411 46D0 89				.byte DL_MAP_9|DL_DLI                 ; (89-92)   DLI 1/22   COLPF0 gfx
   412 46D1 89				.byte DL_MAP_9|DL_DLI                 ; (93-96)   DLI 1/23   COLPF0 gfx
   413 46D2 89				.byte DL_MAP_9|DL_DLI                 ; (97-100)  DLI 1/24   COLPF0 gfx
   414 46D3 89				.byte DL_MAP_9|DL_DLI                 ; (101-104) DLI 0/25   COLBK Black
   415
   416 					.rept 20                              ; an empty line. times 20
   417 						.BYTE DL_BLANK_4|DL_DLI           
   418 					.ENDR                                 
   418 					.endr                                 ;           DLI DLI SPC1/44 sets COLBK, COLPF2, COLPF1 colors.
Source: REPT
   417 46D4 B0					.BYTE DL_BLANK_4|DL_DLI           
   417 46D5 B0					.BYTE DL_BLANK_4|DL_DLI           
   417 46D6 B0					.BYTE DL_BLANK_4|DL_DLI           
   417 46D7 B0					.BYTE DL_BLANK_4|DL_DLI           
   417 46D8 B0					.BYTE DL_BLANK_4|DL_DLI           
   417 46D9 B0					.BYTE DL_BLANK_4|DL_DLI           
   417 46DA B0					.BYTE DL_BLANK_4|DL_DLI           
   417 46DB B0					.BYTE DL_BLANK_4|DL_DLI           
   417 46DC B0					.BYTE DL_BLANK_4|DL_DLI           
   417 46DD B0					.BYTE DL_BLANK_4|DL_DLI           
   417 46DE B0					.BYTE DL_BLANK_4|DL_DLI           
   417 46DF B0					.BYTE DL_BLANK_4|DL_DLI           
   417 46E0 B0					.BYTE DL_BLANK_4|DL_DLI           
   417 46E1 B0					.BYTE DL_BLANK_4|DL_DLI           
   417 46E2 B0					.BYTE DL_BLANK_4|DL_DLI           
   417 46E3 B0					.BYTE DL_BLANK_4|DL_DLI           
   417 46E4 B0					.BYTE DL_BLANK_4|DL_DLI           
   417 46E5 B0					.BYTE DL_BLANK_4|DL_DLI           
   417 46E6 B0					.BYTE DL_BLANK_4|DL_DLI           
   417 46E7 B0					.BYTE DL_BLANK_4|DL_DLI           
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03DisplayLists.asm
   419 					
   420 46E8 00				.byte DL_BLANK_1                      ; (191)     One scan line 
   421 					
   422 46E9				mDL_JMP BOTTOM_OF_DISPLAY             ; End of display.  See Page 0 for the evil.
Macro: MDL_JMP [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/ANTIC.asm]
     6 46E9 01				.byte DL_JUMP
     7 46EA F2 00			.word BOTTOM_OF_DISPLAY   
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03DisplayLists.asm
   423
   726
   727 46EC				icl "Frogger03ScreenMemory.asm" ; Aligns for screen memory
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03ScreenMemory.asm
     1 				; ==========================================================================
     2 				; Pet Frogger
     3 				; (c) November 1983 by John C. Dale, aka Dalesoft
     4 				; for the Commodore Pet 4032
     5 				; ==========================================================================
     6 				; Ported (parodied) to Atari 8-bit computers
     7 				; by Ken Jennings (if this were 1983, aka FTR Enterprises)
     8 				; ==========================================================================
     9 				; Version 00, November 2018
    10 				; Version 01, December 2018
    11 				; Version 02, February 2019
    12 				; Version 03, August 2019
    13 				; ==========================================================================
    14
    15 				; ==========================================================================
    16 				; Screen Memory
    17 				;
    18 				; The Atari OS text printing is not being used, therefore the Atari OS's
    19 				; screen editor's 24-line limitation is not an issue.  The game can be 
    20 				; 25 lines like the original Pet 4032 screen.  Or it can be more. 
    21 				; Sooooo, custom display list means do what we want.
    22 				;
    23 				; Prior versions used Mode 2 text lines exclusively to perpetuate the 
    24 				; flavor of the original's text-mode-based game.
    25 				; 
    26 				; However, Version 03 makes a few changes.  The chunky text used for the
    27 				; title and the dead/saved/game-over screens in V02 was built from Atari 
    28 				; graphics control characters.   Version 03 changes this to a graphics 
    29 				; mode that provides the same chunky-pixel size, but at only half the 
    30 				; memory for the same screen geometry.  Two lines of graphics is 
    31 				; vertically the same height as one line of text.  The V02 block 
    32 				; character patterns provide two apparent rows of pixels, so, everything 
    33 				; is equal.  
    34 				;
    35 				; Switching to a graphics mode for the big text allows:
    36 				; * Complete color expression for background and pixels. 
    37 				;   (Text mode 2 manages playfield and border colors differently.) 
    38 				; * Six lines of graphics in place of three lines of text makes it 
    39 				;   trivial to double the number of color changes in the big text.
    40 				;   Just a DLI for each line.
    41 				; * The background colors extend through the overscan area making 
    42 				;   a seemingly wider screen than the text mode with border. 
    43 				;  
    44 				; In Version 02 blank lines of mode 2 text were used and colored 
    45 				; to make animated prize displays.  Instead of using a text mode 
    46 				; we use actual blank lines instructions.  Again, since these display 
    47 				; background color into the overscan area the prize animations are 
    48 				; larger, filling the entire screen width.  Also, blanks smaller 
    49 				; than a text line allow more frequent color transitions.  Thus more 
    50 				; color on one display is more eye candy on one display.
    51 				;
    52 				; Remember, screen memory need not be contiguous from line to line.
    53 				; Therefore, we can re-think the declaration of screen contents and
    54 				; rearrange it in ways to benefit the code:
    55 				;
    56 				; 1) The first thing is that data declared for display on screen IS the
    57 				;    screen memory.  It is not something that must be copied to screen
    58 				;    memory.  Data properly placed in any memory makes it the actual
    59 				;    screen memory thanks to the Display List LMS instructions.
    60 				; 2) a) In the prior versions all the rows of boats moving left look 
    61 				;       the same, and all the rows moving right looked the same.  
    62 				;       Version 02 declared a copy of data for every line of boats.
    63 				;       This was necessary, because the frog was drawn in screen memory 
    64 				;       and must appear on every row.
    65 				;    b) But now, since the frog is a Player/Missile object there is no 
    66 				;       need to change the screen memory to draw the frog.   Therefore,
    67 				;       all the boat rows could be the same screen memory.  Declaring 
    68 				;       one row of left boats, and one row of right boats saves the 
    69 				;       contents of 10 more rows of the same.  This is actually a 
    70 				;       significant part of the executable size. 
    71 				;    c) Even if the same data is used for each type of boat, they do not 
    72 				;       need to appear identical on screen.   If each row has its own 
    73 				;       concept of current scroll value, then all the rows can be in 
    74 				;       different positions of scrolling, though using the same data.
    75 				; 3) Since scrolling is in effect the line width is whatever is needed 
    76 				;    to allow the boats to move from an original position to destination
    77 				;    and then return the the original scroll position.  If the boats 
    78 				;    and waves between them are identical then the entire line of boats 
    79 				;    does not need to be duplicated.  There only needs to be enough 
    80 				;    data to scroll from one boat position to the next boat's position.
    81 				; 3) Organizing the boats' row of graphics to sit within one page of data 
    82 				;    means scrolling updates and LMS math only need deal with the low
    83 				;    byte of addresses. 
    84 				; 3) To avoid wasting space the lines of data from other displays can be
    85 				;    dropped into the unused spaces between scrolling sections.
    86 				; --------------------------------------------------------------------------
    87
    88 = 0000			ATASCII_HEART  = $00 ; heart graphics
    89
    90 				; Atari uses different, "internal" values when writing to
    91 				; Screen RAM.  These are the internal codes for writing
    92 				; bytes directly to the screen:
    93 = 0010			INTERNAL_0        = $10 ; Number '0' for scores.
    94 = 0000			INTERNAL_SPACE    = $00 ; Blank space character.
    95
    96 = 0027			SIZEOF_LINE    = 39  ; That is, 40 - 1
    97 = 0077			SIZEOF_BIG_GFX = 119 ; That is, 120 - 1
    98
    99
   100 				; Display layouts and associated text blocks:
   101
   102 				; Original V00 Title Screen and Instructions:
   103 				;    +----------------------------------------+
   104 				; 1  |              PET FROGGER               | INSTXT_1
   105 				; 2  |              --- -------               | INSTXT_1
   106 				; 3  |     (c) November 1983 by DalesOft      | INSTXT_1
   107 				; 4  |                                        |
   108 				; 5  |All you have to do is to get as many of | INSTXT_2
   109 				; 6  |the frogs across the river without      | INSTXT_2
   110 				; 7  |drowning them. You have to leap onto a  | INSTXT_2
   111 				; 8  |boat like this :- <QQQ] and land on the | INSTXT_2
   112 				; 9  |seats ('Q'). You get 10 points for every| INSTXT_2
   113 				; 10 |jump forward and 500 points every time  | INSTXT_2
   114 				; 11 |you get a frog across the river.        | INSTXT_2
   115 				; 12 |                                        |
   116 				; 13 |                                        |
   117 				; 14 |                                        |
   118 				; 15 |The controls are :-                     | INSTXT_3
   119 				; 16 |                 S = Up                 | INSTXT_3
   120 				; 17 |  4 = left                   6 = right  | INSTXT_3
   121 				; 18 |                                        |
   122 				; 19 |                                        |
   123 				; 20 |     Hit any key to start the game.     | INSTXT_4
   124 				; 21 |                                        |
   125 				; 22 |                                        |
   126 				; 23 |                                        |
   127 				; 24 |                                        |
   128 				; 25 |Atari V00 port by Ken Jennings, Nov 2018| PORTBYTEXT
   129 				;    +----------------------------------------+
   130
   131 				;  Original V00 Main Game Play Screen:
   132 				;    +----------------------------------------+
   133 				; 1  |Successful Crossings =                  | SCORE_TXT
   134 				; 2  |Score = 00000000     Hi = 00000000  Lv:3| SCORE_TXT
   135 				; 3  |BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB| TEXT1_1
   136 				; 4  | [QQQQ>        [QQQQ>       [QQQQ>      | TEXT1_1
   137 				; 5  |      <QQQQ]        <QQQQ]    <QQQQ]    | TEXT1_1
   138 				; 6  |BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB| TEXT1_2
   139 				; 7  | [QQQQ>        [QQQQ>       [QQQQ>      | TEXT1_2
   140 				; 8  |      <QQQQ]        <QQQQ]    <QQQQ]    | TEXT1_2
   141 				; 9  |BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB| TEXT1_3
   142 				; 10 | [QQQQ>        [QQQQ>       [QQQQ>      | TEXT1_3
   143 				; 11 |      <QQQQ]        <QQQQ]    <QQQQ]    | TEXT1_3
   144 				; 12 |BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB| TEXT1_4
   145 				; 13 | [QQQQ>        [QQQQ>       [QQQQ>      | TEXT1_4
   146 				; 14 |      <QQQQ]        <QQQQ]    <QQQQ]    | TEXT1_4
   147 				; 15 |BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB| TEXT1_5
   148 				; 16 | [QQQQ>        [QQQQ>       [QQQQ>      | TEXT1_5
   149 				; 17 |      <QQQQ]        <QQQQ]    <QQQQ]    | TEXT1_5
   150 				; 18 |BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB| TEXT1_6
   151 				; 29 | [QQQQ>        [QQQQ>       [QQQQ>      | TEXT1_6
   152 				; 20 |      <QQQQ]        <QQQQ]    <QQQQ]    | TEXT1_6
   153 				; 21 |BBBBBBBBBBBBBBBBBBBOBBBBBBBBBBBBBBBBBBBB| TEXT2
   154 				; 22 |     (c) November 1983 by DalesOft      | TEXT2
   155 				; 23 |        Written by John C Dale          | TEXT2
   156 				; 24 |                                        |
   157 				; 25 |Atari V00 port by Ken Jennings, Nov 2018| PORTBYTEXT
   158 				;    +----------------------------------------+
   159
   160
   161
   162 				; Revised V01 Title Screen and Instructions:
   163 				;    +----------------------------------------+
   164 				; 1  |              PET FROGGER               | TITLE
   165 				; 2  |              --- -------               | TITLE
   166 				; 3  |     (c) November 1983 by DalesOft      | CREDIT
   167 				; 4  |        Written by John C Dale          | CREDIT
   168 				; 5  |Atari V01 port by Ken Jennings, Dec 2018| CREDIT
   169 				; 6  |                                        |
   170 				; 7  |Help the frogs escape from Doc Hopper's | INSTXT_1
   171 				; 8  |frog legs fast food franchise! But, the | INSTXT_1
   172 				; 9  |frogs must cross piranha-infested rivers| INSTXT_1
   173 				; 10 |to reach freedom. You have three chances| INSTXT_1
   174 				; 11 |to prove your frog management skills by | INSTXT_1
   175 				; 12 |directing frogs to jump on boats in the | INSTXT_1
   176 				; 13 |rivers like this:  <QQQQ]  Land only on | INSTXT_1
   177 				; 14 |the seats in the boats ('Q').           | INSTXT_1
   178 				; 15 |                                        |
   179 				; 16 |Scoring:                                | INSTXT_2
   180 				; 17 |    10 points for each jump forward.    | INSTXT_2
   181 				; 18 |   500 points for each rescued frog.    | INSTXT_2
   182 				; 19 |                                        |
   183 				; 20 |Game controls:                          | INSTXT_3
   184 				; 21 |                 S = Up                 | INSTXT_3
   185 				; 22 |      left = 4           6 = right      | INSTXT_3
   186 				; 23 |                                        |
   187 				; 24 |     Hit any key to start the game.     | INSTXT_4
   188 				; 25 |                                        |
   189 				;    +----------------------------------------+
   190
   191 				; Transition Title screen to Game Screen.
   192 				; Animate Credit lines down from Line 3 to Line 23.
   193
   194 				; Revised V01 Main Game Play Screen:
   195 				;    +----------------------------------------+
   196 				; 1  |Score:00000000               00000000:Hi| SCORE_TXT
   197 				; 2  |Frogs:0    Frogs Saved:OOOOOOOOOOOOOOOOO| SCORE_TXT
   198 				; 3  |BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB| TEXT1_1
   199 				; 4  | [QQQQ>        [QQQQ>       [QQQQ>      | TEXT1_1
   200 				; 5  |      <QQQQ]        <QQQQ]    <QQQQ]    | TEXT1_1
   201 				; 6  |BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB| TEXT1_2
   202 				; 7  | [QQQQ>        [QQQQ>       [QQQQ>      | TEXT1_2
   203 				; 8  |      <QQQQ]        <QQQQ]    <QQQQ]    | TEXT1_2
   204 				; 9  |BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB| TEXT1_3
   205 				; 10 | [QQQQ>        [QQQQ>       [QQQQ>      | TEXT1_3
   206 				; 11 |      <QQQQ]        <QQQQ]    <QQQQ]    | TEXT1_3
   207 				; 12 |BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB| TEXT1_4
   208 				; 13 | [QQQQ>        [QQQQ>       [QQQQ>      | TEXT1_4
   209 				; 14 |      <QQQQ]        <QQQQ]    <QQQQ]    | TEXT1_4
   210 				; 15 |BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB| TEXT1_5
   211 				; 16 | [QQQQ>        [QQQQ>       [QQQQ>      | TEXT1_5
   212 				; 17 |      <QQQQ]        <QQQQ]    <QQQQ]    | TEXT1_5
   213 				; 18 |BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB| TEXT1_6
   214 				; 19 | [QQQQ>        [QQQQ>       [QQQQ>      | TEXT1_6
   215 				; 20 |      <QQQQ]        <QQQQ]    <QQQQ]    | TEXT1_6
   216 				; 21 |BBBBBBBBBBBBBBBBBBBOBBBBBBBBBBBBBBBBBBBB| TEXT2
   217 				; 22 |                                        |
   218 				; 23 |     (c) November 1983 by DalesOft      | CREDIT
   219 				; 24 |        Written by John C Dale          | CREDIT
   220 				; 25 |Atari V01 port by Ken Jennings, Dec 2018| CREDIT
   221 				;    +----------------------------------------+
   222
   223
   224
   225 				; Revised V02 Title Screen and Instructions:
   226 				;    +----------------------------------------+
   227 				; 1  |Score:00000000               00000000:Hi| SCORE_TXT
   228 				; 2  |                                        |
   229 				; 3  |              PET FROGGER               | TITLE
   230 				; 4  |              PET FROGGER               | TITLE
   231 				; 5  |              PET FROGGER               | TITLE
   232 				; 6  |              --- -------               | TITLE
   233 				; 7  |                                        |
   234 				; 8  |Help the frogs escape from Doc Hopper's | INSTXT_1
   235 				; 9  |frog legs fast food franchise! But, the | INSTXT_1
   236 				; 10 |frogs must cross piranha-infested rivers| INSTXT_1
   237 				; 11 |to reach freedom. You have three chances| INSTXT_1
   238 				; 12 |to prove your frog management skills by | INSTXT_1
   239 				; 13 |directing frogs to jump on boats in the | INSTXT_1
   240 				; 14 |rivers like this:  <QQQQ]  Land only on | INSTXT_1
   241 				; 15 |the seats in the boats ('Q').           | INSTXT_1
   242 				; 16 |                                        |
   243 				; 17 |Scoring:                                | INSTXT_2
   244 				; 18 |    10 points for each jump forward.    | INSTXT_2
   245 				; 19 |   500 points for each rescued frog.    | INSTXT_2
   246 				; 20 |                                        |
   247 				; 21 |Use joystick control to jump forward,   | INSTXT_3
   248 				; 22 |left, and right.                        | INSTXT_3
   249 				; 23 |                                        |
   250 				; 24 |   Press joystick button to continue.   | ANYBUTTON_MEM
   251 				; 25 |(c) November 1983 by DalesOft  Written b| SCROLLING CREDIT
   252 				;    +----------------------------------------+
   253
   254 				; Revised V02 Main Game Play Screen:
   255 				;    +----------------------------------------+
   256 				; 1  |Score:00000000               00000000:Hi| SCORE_TXT
   257 				; 2  |Frogs:0    Frogs Saved:OOOOOOOOOOOOOOOOO| SCORE_TXT
   258 				; 3  |                                        |
   259 				; 4  |BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB| TEXT1_1
   260 				; 5  | [QQQQ>        [QQQQ>       [QQQQ>      | TEXT1_1
   261 				; 6  |      <QQQQ]        <QQQQ]    <QQQQ]    | TEXT1_1
   262 				; 7  |BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB| TEXT1_2
   263 				; 8  | [QQQQ>        [QQQQ>       [QQQQ>      | TEXT1_2
   264 				; 9  |      <QQQQ]        <QQQQ]    <QQQQ]    | TEXT1_2
   265 				; 10 |BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB| TEXT1_3
   266 				; 11 | [QQQQ>        [QQQQ>       [QQQQ>      | TEXT1_3
   267 				; 12 |      <QQQQ]        <QQQQ]    <QQQQ]    | TEXT1_3
   268 				; 13 |BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB| TEXT1_4
   269 				; 14 | [QQQQ>        [QQQQ>       [QQQQ>      | TEXT1_4
   270 				; 15 |      <QQQQ]        <QQQQ]    <QQQQ]    | TEXT1_4
   271 				; 16 |BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB| TEXT1_5
   272 				; 17 | [QQQQ>        [QQQQ>       [QQQQ>      | TEXT1_5
   273 				; 18 |      <QQQQ]        <QQQQ]    <QQQQ]    | TEXT1_5
   274 				; 19 |BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB| TEXT1_6
   275 				; 20 | [QQQQ>        [QQQQ>       [QQQQ>      | TEXT1_6
   276 				; 21 |      <QQQQ]        <QQQQ]    <QQQQ]    | TEXT1_6
   277 				; 22 |BBBBBBBBBBBBBBBBBBBOBBBBBBBBBBBBBBBBBBBB| TEXT2
   278 				; 23 |                                        |
   279 				; 24 |                                        |
   280 				; 25 |(c) November 1983 by DalesOft  Written b| SCROLLING CREDIT
   281 				;    +----------------------------------------+
   282
   283
   284
   285 				; Revised V03 Title Screen and Instructions:
   286 				;    +----------------------------------------+
   287 				; 1  |Score:00000000               00000000:Hi| SCORE_TXT
   288 				; 2  |Frogs:0       00000000000000000000:Saved| SCORE_TXT
   289 				; 3  |              PET FROGGER               | TITLE
   290 				; 4  |              PET FROGGER               | TITLE
   291 				; 5  |              PET FROGGER               | TITLE
   292 				; 6  |              --- -------               | TITLE
   293 				; 7  |                                        |
   294 				; 8  |Help the frogs escape evil Doc Hopper's | INSTXT_1
   295 				; 9  |Frog Legs Fast Food Franchise! But, the | INSTXT_1
   296 				; 10 |frogs must cross piranha-infested rivers| INSTXT_1
   297 				; 11 |to reach freedom. You have three chances| INSTXT_1
   298 				; 12 |to prove your frog management skills by | INSTXT_1
   299 				; 13 |directing frogs to jump on boats in the | INSTXT_1
   300 				; 14 |rivers. Land in the middle of the boats.| INSTXT_1
   301 				; 15 |Do not fall off or jump in the river.   | INSTXT_1
   302 				; 16 |                                        |
   303 				; 17 |Scoring:                                | INSTXT_2
   304 				; 18 |    10 points for each jump forward.    | INSTXT_2
   305 				; 19 |   500 points for each saved frog.      | INSTXT_2
   306 				; 20 |                                        |
   307 				; 21 |Use the joystick control to jump        | INSTXT_3
   308 				; 22 |forward, left, and right.               | INSTXT_3
   309 				; 23 |                                        |
   310 				; 24 | Press the joystick button to continue. | ANYBUTTON_MEM
   311 				; 25 |(c) November 1983 by DalesOft  Written b| SCROLLING CREDIT
   312 				;    +----------------------------------------+
   313
   314 				; Revised V03 Main Game Play Screen:
   315 				; FYI: Old boats.
   316 				; 8  | [QQQQ1        [QQQQ1       [QQQQ1      | TEXT1_2
   317 				; 9  |      <QQQQ0        <QQQQ0    <QQQQ0    | TEXT1_2
   318 				; New boats are larger to provide more safe surface for the larger 
   319 				; frog and to provide some additional graphics enhancement for 
   320 				; the boats.  Illustration below shows the entire memory needed 
   321 				; for scrolling.   Since boats on each row are identical, and 
   322 				; they are spaced equally, then scrolling only need move the 
   323 				; distance between two boats (16 chars), and then reset
   324 				; to the starting position. 
   325 				;    +----------------------------------------+
   326 				; 1  |Score:00000000               00000000:Hi| SCORE_TXT
   327 				; 2  |Frogs:0       00000000000000000000:Saved| SCORE_TXT
   328 				; 3  |                                        | 
   329 				; 4  |BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB| TEXT1_1
   330 				; 5  |[[QQQQQ>        [[QQQQQ>        [[QQQQQ>        [[QQQQQ>        | ; Boats Right
   331 				; 6  |<QQQQQ]]        <QQQQQ]]        <QQQQQ]]        <QQQQQ]]        | ; Boats Left
   332 				; 7  |BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB| TEXT1_2
   333 				; 8  |[[QQQQQ>        [[QQQQQ>        [[QQQQQ>        [[QQQQQ>        |
   334 				; 9  |<QQQQQ]]        <QQQQQ]]        <QQQQQ]]        <QQQQQ]]        |
   335 				; 10 |BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB| TEXT1_3
   336 				; 11 |[[QQQQQ>        [[QQQQQ>        [[QQQQQ>        [[QQQQQ>        |
   337 				; 12 |<QQQQQ]]        <QQQQQ]]        <QQQQQ]]        <QQQQQ]]        |
   338 				; 13 |BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB| TEXT1_4
   339 				; 14 |[[QQQQQ>        [[QQQQQ>        [[QQQQQ>        [[QQQQQ>        |
   340 				; 15 |<QQQQQ]]        <QQQQQ]]        <QQQQQ]]        <QQQQQ]]        |
   341 				; 16 |BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB| TEXT1_5
   342 				; 17 |[[QQQQQ>        [[QQQQQ>        [[QQQQQ>        [[QQQQQ>        |
   343 				; 18 |<QQQQQ]]        <QQQQQ]]        <QQQQQ]]        <QQQQQ]]        |
   344 				; 19 |BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB| TEXT1_6
   345 				; 20 |[[QQQQQ>        [[QQQQQ>        [[QQQQQ>        [[QQQQQ>        |
   346 				; 21 |<QQQQQ]]        <QQQQQ]]        <QQQQQ]]        <QQQQQ]]        |
   347 				; 22 |BBBBBBBBBBBBBBBBBBBOBBBBBBBBBBBBBBBBBBBB| TEXT2
   348 				; 23 |                                        |
   349 				; 24 |                                        |
   350 				; 25 |(c) November 1983 by DalesOft  Written b| SCROLLING CREDIT
   351 				;    +----------------------------------------+
   352
   353
   354 				; These things repeat four times.
   355 				; Let's just type it once and macro it elsewhere.
   356
   357 				; 5  |[[QQQQQ1        [[QQQQQ1        [[QQQQQ1        [[QQQQQ1        | ; Boats Right
   358 					.macro mBoatGoRight
   359 						.by I_BOAT_RBW+$80 I_BOAT_RB+$80 I_BOAT_EMPTY I_SEATS_R3 I_SEATS_R2 I_SEATS_R1 I_BOAT_RFW+$80 I_BOAT_RF+$80 ;   8
   360 						.by I_WATER1 I_WATER2 I_WATER3 I_WATER4 I_WATER1 I_WATER2 I_WATER3 I_WATER4                 ; + 8 = 16
   361 					.endm
   362
   363 					.macro mLineOfRightBoats
   364 						.rept 4
   365 							mBoatGoRight ; 16 ] 4 = 64
   366 						.endr
   367 					.endm
   368
   369
   370 				; 6  |<QQQQQ]]        <QQQQQ]]        <QQQQQ]]        <QQQQQ]]        | ; Boats Left
   371 					.macro mBoatGoLeft
   372 						.by I_BOAT_LF+$80 I_BOAT_LFW+$80 I_SEATS_L1 I_SEATS_L2 I_SEATS_L3 I_BOAT_EMPTY I_BOAT_LB+$80 I_BOAT_LBW+$80 ;   8
   373 						.by I_WATER1 I_WATER2 I_WATER3 I_WATER4 I_WATER1 I_WATER2 I_WATER3 I_WATER4                         ; + 8 = 16
   374 					.endm
   375
   376 					.macro mLineOfLeftBoats
   377 						.rept 4
   378 							mBoatGoLeft ; 16 ] 4 = 64
   379 						.endr
   380 					.endm
   381
   382
   383 				; ANTIC has a 4K boundary for screen memory.
   384 				;
   385 				; Visibly adjacent lines of screen data need not be contiguous 
   386 				; in memory.  The LMS in the Display List tells ANTIC where to 
   387 				; start reading screen memory.  Therefore we can declare lines 
   388 				; in any order. 
   389 				;
   390 				; Therefore, we can simply align screen data into 256 byte 
   391 				; pages only making sure a line doesn't cross the end of a 
   392 				; page.  This will prevent any line of displayed data from 
   393 				; crossing over a 4K boundary.
   394
   395
   396 46EC				.align $0100 ; Realign to next page.
   397
   398
   399 				; The Credit text.  Rather than three lines on the main
   400 				; and game screen let's make this a continuously scrolling
   401 				; line of text on all screens.  This requires two more blocks
   402 				; of blank text to space out the start and end of the text.
   403
   404 				; Originally:
   405 				; 3  |     (c) November 1983 by DalesOft      | CREDIT
   406 				; 4  |        Written by John C Dale          | CREDIT
   407 				; 5  |Atari V02 port by Ken Jennings, Nov 2018| CREDIT
   408 				; 6  |                                        |
   409
   410 				; Now:
   411 4700			SCROLLING_CREDIT   ; 40 * 6 == 240   + 8 == 248.
   412 				; Since fine scrolling buffers 4 characters, make sure the 
   413 				; credits string is padded to a multiple of 4 characters.
   414
   415 				; The perpetrators identified...
   416 4700-47F7> 30 25 34 00 + 	.sb "PET FROGGER (c) November 1983 by Dales" ATASCII_HEART "f" ; 40 
   417 4728 74 00 66 6F 72 00 + 	.sb "t for CBM PET 4032 written by John C. Da" ; 40 
   418 4750 6C 65 0E 00 21 74 + 	.sb "le. Atari 8-bit parody by Ken Jennings, " ; 40
   419 4778 36 10 13 0C 00 21 + 	.sb "V03, August 2019. Special thanks to test" ; 40
   420 47A0 65 72 73 00 0D 34 + 	.sb "ers -The Doctor-, Philsan, Mclaneinc, Fa" ; 40
   421 47C8 69 63 75 61 69 0E + 	.sb "icuai.  "                         ; 8
   422
   423 47D0			END_OF_CREDITS
   424 47D0 30 25 34 00 26 32 + 	.sb "PET FROGGER (c) November 1983 by Dales" ATASCII_HEART "f" ; 40 
   425
   426
   427 47F8				.align $0100 ; Realign to next page.
   428
   429
   430 				; The lines of scrolling boats.  Only one line of data for each 
   431 				; direction is declared.  Every other moving row can re-use the 
   432 				; same data for display.  Also, since the entire data fits within 
   433 				; one page, the coarse scrolling need only update the low byte of 
   434 				; the LMS instruction....
   435 				 
   436 				; 5  |[[QQQQQ1        [[QQQQQ1        [[QQQQQ1        [[QQQQQ1        | ; Boats Right ;   64
   437 				; Start Scroll position = LMS + 12 (decrement), HSCROL 0  (Increment)
   438 				; End   Scroll position = LMS + 0,              HSCROL 15
   439 4800			PLAYFIELD_MEM1
   440 4800			PLAYFIELD_MEM4
   441 4800			PLAYFIELD_MEM7
   442 4800			PLAYFIELD_MEM10
   443 4800			PLAYFIELD_MEM13
   444 4800			PLAYFIELD_MEM16
   445 4800				mLineOfRightBoats           ; + 64 == 64
Macro: MLINEOFRIGHTBOATS [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03ScreenMemory.asm]
     1 4800-483F> 9B 9C 0A 1E + 		.by I_BOAT_RBW+$80 I_BOAT_RB+$80 I_BOAT_EMPTY I_SEATS_R3 I_SEATS_R2 I_SEATS_R1 I_BOAT_RFW+$80 I_BOAT_RF+$80 ;   8
     2 4808 5A 5B 5C 5D 5A 5B + 		.by I_WATER1 I_WATER2 I_WATER3 I_WATER4 I_WATER1 I_WATER2 I_WATER3 I_WATER4                 ; + 8 = 16
     1 4810 9B 9C 0A 1E 46 47 + 		.by I_BOAT_RBW+$80 I_BOAT_RB+$80 I_BOAT_EMPTY I_SEATS_R3 I_SEATS_R2 I_SEATS_R1 I_BOAT_RFW+$80 I_BOAT_RF+$80 ;   8
     2 4818 5A 5B 5C 5D 5A 5B + 		.by I_WATER1 I_WATER2 I_WATER3 I_WATER4 I_WATER1 I_WATER2 I_WATER3 I_WATER4                 ; + 8 = 16
     1 4820 9B 9C 0A 1E 46 47 + 		.by I_BOAT_RBW+$80 I_BOAT_RB+$80 I_BOAT_EMPTY I_SEATS_R3 I_SEATS_R2 I_SEATS_R1 I_BOAT_RFW+$80 I_BOAT_RF+$80 ;   8
     2 4828 5A 5B 5C 5D 5A 5B + 		.by I_WATER1 I_WATER2 I_WATER3 I_WATER4 I_WATER1 I_WATER2 I_WATER3 I_WATER4                 ; + 8 = 16
     1 4830 9B 9C 0A 1E 46 47 + 		.by I_BOAT_RBW+$80 I_BOAT_RB+$80 I_BOAT_EMPTY I_SEATS_R3 I_SEATS_R2 I_SEATS_R1 I_BOAT_RFW+$80 I_BOAT_RF+$80 ;   8
     2 4838 5A 5B 5C 5D 5A 5B + 		.by I_WATER1 I_WATER2 I_WATER3 I_WATER4 I_WATER1 I_WATER2 I_WATER3 I_WATER4                 ; + 8 = 16
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03ScreenMemory.asm
   446
   447
   448 4840			TITLE_MEM1  ; "Blank" to support the animated dissolve in.
   449 = 4840				.ds 120  ; Code will clear it, so do not need to declare zeros.                                        ; + 120 == 184
   450
   451 				; Values for manipulating screen memory.
   452 = 4840			TITLE_LEFT  = TITLE_MEM1
   453 = 484A			TITLE_RIGHT = TITLE_MEM1+10
   454
   455 				; LMS values for scrolling.  A little different...
   456 = 483F			TITLE_START = TITLE_MEM1-1   ; Cheating. To show all color clocks from TITLE_MEM1 the LMS must be at * -1, and HSCROLL 0
   457 = 4849			TITLE_END   = TITLE_START+10
   458
   459
   460 48B8			TITLE_UNDERLINE
   461 				; 4  |--- --- ---  --- --- --- --- --- --- ---| TITLE underline are constant part of title.
   462
   463 48B8-48FD> FC FC FC 3F + 	.by %11111100 %11111100 %11111100 %00111111 %00111111 %00111111 %00111111 %00111111 %00111111 %00111111 ; + 10 == 194
   464
   465 				; Title text.  Bit-mapped version for Mode 9.
   466 				; Will not scroll these, so no need for individual labels and leading blanks.
   467 				; 60 bytes here instead of the 240 bytes used for the scrolling text version.
   468
   469 				; Graphics chars design, PET FROGGER
   470 				; |]]|]]|] |  |]]|]]|]]|  |]]|]]|]]|  |  |]]|]]|]]|  |]]|]]|] |  | ]|]]|] |  | ]|]]|]]|  | ]|]]|]]|  |]]|]]|]]|  |]]|]]|] |
   471 				; |]]|  |]]|  |]]|  |  |  |  |]]|  |  |  |]]|  |  |  |]]|  |]]|  |]]|  |]]|  |]]|  |  |  |]]|  |  |  |]]|  |  |  |]]|  |]]|
   472 				; |]]|  |]]|  |]]|]]|] |  |  |]]|  |  |  |]]|]]|] |  |]]|  |]]|  |]]|  |]]|  |]]|  |  |  |]]|  |  |  |]]|]]|] |  |]]|  |]]|
   473 				; |]]|]]|] |  |]]|  |  |  |  |]]|  |  |  |]]|  |  |  |]]|]]|] |  |]]|  |]]|  |]]| ]|]]|  |]]| ]|]]|  |]]|  |  |  |]]|]]|] |
   474 				; |]]|  |  |  |]]|  |  |  |  |]]|  |  |  |]]|  |  |  |]]| ]|] |  |]]|  |]]|  |]]|  |]]|  |]]|  |]]|  |]]|  |  |  |]]| ]|] |
   475 				; |]]|  |  |  |]]|]]|]]|  |  |]]|  |  |  |]]|  |  |  |]]|  |]]|  | ]|]]|] |  | ]|]]|]]|  | ]|]]|]]|  |]]|]]|]]|  |]]|  |]]|
   476
   477 48C2			TITLE_GFX  ; 
   478 48C2 F8 FC FC 3F 3E 1E + 	.by %11111000 %11111100 %11111100 %00111111 %00111110 %00011110 %00011111 %00011111 %00111111 %00111110
   479 48CC CC C0 30 30 33 33 + 	.by %11001100 %11000000 %00110000 %00110000 %00110011 %00110011 %00110000 %00110000 %00110000 %00110011
   480 48D6 CC F8 30 3E 33 33 + 	.by %11001100 %11111000 %00110000 %00111110 %00110011 %00110011 %00110000 %00110000 %00111110 %00110011
   481 48E0 F8 C0 30 30 3E 33 + 	.by %11111000 %11000000 %00110000 %00110000 %00111110 %00110011 %00110111 %00110111 %00110000 %00111110
   482 48EA C0 C0 30 30 36 33 + 	.by %11000000 %11000000 %00110000 %00110000 %00110110 %00110011 %00110011 %00110011 %00110000 %00110110
   483
   484 48F4 C0 FC 30 30 33 1E + 	.by %11000000 %11111100 %00110000 %00110000 %00110011 %00011110 %00011111 %00011111 %00111111 %00110011 ; + 60 == 254
   485
   486
   487 48FE				.align $0100
   488
   489
   490 				; 6  |<QQQQQ00        <QQQQQ00        <QQQQQ00        <QQQQQ00        | ; Boats Left ; + 64 
   491 				; Start Scroll position = LMS + 0 (increment), HSCROL 15  (Decrement)
   492 				; End   Scroll position = LMS + 12,            HSCROL 0
   493 4900			PLAYFIELD_MEM2
   494 4900			PLAYFIELD_MEM5
   495 4900			PLAYFIELD_MEM8
   496 4900			PLAYFIELD_MEM11
   497 4900			PLAYFIELD_MEM14
   498 4900			PLAYFIELD_MEM17
   499 4900				mLineOfLeftBoats                     ; + 64 == 64
Macro: MLINEOFLEFTBOATS [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03ScreenMemory.asm]
     1 4900-49DF> 82 83 04 05 + 		.by I_BOAT_LF+$80 I_BOAT_LFW+$80 I_SEATS_L1 I_SEATS_L2 I_SEATS_L3 I_BOAT_EMPTY I_BOAT_LB+$80 I_BOAT_LBW+$80 ;   8
     2 4908 5A 5B 5C 5D 5A 5B + 		.by I_WATER1 I_WATER2 I_WATER3 I_WATER4 I_WATER1 I_WATER2 I_WATER3 I_WATER4                         ; + 8 = 16
     1 4910 82 83 04 05 06 0A + 		.by I_BOAT_LF+$80 I_BOAT_LFW+$80 I_SEATS_L1 I_SEATS_L2 I_SEATS_L3 I_BOAT_EMPTY I_BOAT_LB+$80 I_BOAT_LBW+$80 ;   8
     2 4918 5A 5B 5C 5D 5A 5B + 		.by I_WATER1 I_WATER2 I_WATER3 I_WATER4 I_WATER1 I_WATER2 I_WATER3 I_WATER4                         ; + 8 = 16
     1 4920 82 83 04 05 06 0A + 		.by I_BOAT_LF+$80 I_BOAT_LFW+$80 I_SEATS_L1 I_SEATS_L2 I_SEATS_L3 I_BOAT_EMPTY I_BOAT_LB+$80 I_BOAT_LBW+$80 ;   8
     2 4928 5A 5B 5C 5D 5A 5B + 		.by I_WATER1 I_WATER2 I_WATER3 I_WATER4 I_WATER1 I_WATER2 I_WATER3 I_WATER4                         ; + 8 = 16
     1 4930 82 83 04 05 06 0A + 		.by I_BOAT_LF+$80 I_BOAT_LFW+$80 I_SEATS_L1 I_SEATS_L2 I_SEATS_L3 I_BOAT_EMPTY I_BOAT_LB+$80 I_BOAT_LBW+$80 ;   8
     2 4938 5A 5B 5C 5D 5A 5B + 		.by I_WATER1 I_WATER2 I_WATER3 I_WATER4 I_WATER1 I_WATER2 I_WATER3 I_WATER4                         ; + 8 = 16
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03ScreenMemory.asm
   500
   501
   502 4940			ANYBUTTON_MEM ; Prompt to start game.
   503 				; 24 |   Press joystick button to continue.   | INSTXT_4 
   504 4940 00 30 72 65 73 73 + 	.sb " Press the joystick button to continue. "                             ; +40 == 104
   505
   506
   507 4968			INSTRUCT_MEM1 ; Basic instructions...
   508 				; 6  |Help the frogs escape from Doc Hopper's | INSTXT_1
   509 4968 28 65 6C 70 00 74 + 	.sb "Help the frogs escape evil Doc Hopper's "                            ; + 40 == 144
   510
   511 4990			INSTRUCT_MEM2
   512 				; 7  |frog legs fast food franchise! But, the | INSTXT_1
   513 4990 26 72 6F 67 00 2C + 	.sb "Frog Legs Fast Food Franchise! But, the "                            ; + 40 == 184
   514
   515 49B8			INSTRUCT_MEM3
   516 				; 8  |frogs must cross piranha-infested rivers| INSTXT_1
   517 49B8 66 72 6F 67 73 00 + 	.sb "frogs must cross piranha-infested rivers"                            ; + 40 == 224
   518
   519
   520 49E0				.align $0100 ; Realign to next page.
   521
   522
   523 4A00			INSTRUCT_MEM4
   524 				; 9  |to reach freedom. You have three chances| INSTXT_1
   525 4A00-4AEF> 74 6F 00 72 + 	.sb "to reach freedom. You have three chances"                            ; + 40 == 40
   526
   527 4A28			INSTRUCT_MEM5
   528 				; 10 |to prove your frog management skills by | INSTXT_1
   529 4A28 74 6F 00 70 72 6F + 	.sb "to prove your frog management skills by "                            ; + 40 == 80
   530
   531 4A50			INSTRUCT_MEM6
   532 				; 11 |directing frogs to jump on boats in the | INSTXT_1
   533 4A50 64 69 72 65 63 74 + 	.sb "directing frogs to jump on boats in the "                            ; + 40 == 120
   534
   535 4A78			INSTRUCT_MEM7
   536 				; 12 |rivers like this:  <QQQQ00  Land only on| INSTXT_1
   537 4A78 72 69 76 65 72 73 + 	.sb "rivers. Land in the middle of the boats."                            ; + 40 == 160
   538
   539 4AA0			INSTRUCT_MEM8
   540 				; 13 |the seats in the boats.                 | INSTXT_1
   541 4AA0 24 6F 00 6E 6F 74 + 	.sb "Do not fall off or jump in the river.   "                            ; + 40 == 200
   542
   543 4AC8			SCORING_MEM1 ; Scoring
   544 				; 15 |Scoring:                                | INSTXT_2
   545 4AC8 33 63 6F 72 69 6E + 	.sb "Scoring:                                "                            ; + 40 == 240
   546
   547
   548 4AF0				.align $0100  ; Realign to next page.
   549
   550
   551 4B00			SCORING_MEM2
   552 				; 16 |    10 points for each jump forward.    | INSTXT_2
   553 4B00-4BEF> 00 00 00 00 + 	.sb "    10 points for each jump forward.    "                            ; + 40 == 40
   554
   555 4B28			SCORING_MEM3
   556 				; 17 |   500 points for each rescued frog.    | INSTXT_2
   557 4B28 00 00 00 15 10 10 + 	.sb "   500 points for each saved frog.      "                            ; + 40 == 80
   558
   559 4B50			CONTROLS_MEM1 ; Game Controls
   560 				; 19 |Use joystick control to jump forward,   | INSTXT_3
   561 4B50 35 73 65 00 74 68 + 	.sb "Use the joystick controller to move     "                            ; + 40 == 120
   562
   563 4B78			CONTROLS_MEM2
   564 				; 20 |left, and right.                        | INSTXT_3
   565 4B78 66 6F 72 77 61 72 + 	.sb "forward, left, and right.               "                            ; + 40 == 160
   566
   567 				; Defining one line of 80 characters of Beach decorations.
   568 				; Each of the beach lines shows a 40 character subset of the larger line.
   569 				; This eliminates 5 lines worth of data.
   570 				 
   571 4BA0			PLAYFIELD_MEM0 ; Default display of "Beach", for lack of any other description, and the two lines of Boats
   572 				; 3  |BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB| TEXT1_1
   573 4BA0 4C 4D 4E 4F 51 52 + 	.by I_BEACH1 I_BEACH2 I_BEACH3 I_BEACH4 I_BEACH5 I_BEACH6  I_BEACH7  I_BEACH8 
   574 4BA8 4C 4D 4E 4F 51 55 + 	.by I_BEACH1 I_BEACH2 I_BEACH3 I_BEACH4 I_BEACH5 I_ROCKS1L I_ROCKS1R I_BEACH8 
   575 4BB0 4C 4D 4E 4F 51 52 + 	.by I_BEACH1 I_BEACH2 I_BEACH3 I_BEACH4 I_BEACH5 I_BEACH6  I_ROCKS2  I_BEACH8 
   576 4BB8 4C 4D 4E 4F 51 52 + 	.by I_BEACH1 I_BEACH2 I_BEACH3 I_BEACH4 I_BEACH5 I_BEACH6  I_ROCKS3  I_BEACH8 
   577 4BC0 4C 4D 4E 4F 51 52 + 	.by I_BEACH1 I_BEACH2 I_BEACH3 I_BEACH4 I_BEACH5 I_BEACH6  I_ROCKS4  I_BEACH8
   578 4BC8 4C 4D 4E 4F 51 52 + 	.by I_BEACH1 I_BEACH2 I_BEACH3 I_BEACH4 I_BEACH5 I_BEACH6  I_BEACH7  I_BEACH8 
   579 4BD0 4C 4D 4E 4F 51 52 + 	.by I_BEACH1 I_BEACH2 I_BEACH3 I_BEACH4 I_BEACH5 I_BEACH6  I_ROCKS3  I_BEACH8 
   580 4BD8 4C 4D 4E 4F 51 55 + 	.by I_BEACH1 I_BEACH2 I_BEACH3 I_BEACH4 I_BEACH5 I_ROCKS1L I_ROCKS1R I_BEACH8 
   581 4BE0 4C 4D 4E 4F 51 52 + 	.by I_BEACH1 I_BEACH2 I_BEACH3 I_BEACH4 I_BEACH5 I_BEACH6  I_BEACH7  I_BEACH8 
   582 4BE8 4C 4D 4E 4F 51 52 + 	.by I_BEACH1 I_BEACH2 I_BEACH3 I_BEACH4 I_BEACH5 I_BEACH6  I_ROCKS4  I_BEACH8 ; "Beach"
   583
   584 = 4BC0			PLAYFIELD_MEM3 = PLAYFIELD_MEM0+32 ; Default display of "Beach", for lack of any other description.
   585
   586 = 4BB4			PLAYFIELD_MEM6 = PLAYFIELD_MEM0+20 ; Default display of "Beach", for lack of any other description.
   587
   588 = 4BA7			PLAYFIELD_MEM9 = PLAYFIELD_MEM0+7 ; Default display of "Beach", for lack of any other description.
   589
   590 = 4BBD			PLAYFIELD_MEM12 = PLAYFIELD_MEM0+29 ; Default display of "Beach", for lack of any other description.
   591
   592 = 4BAE			PLAYFIELD_MEM15 = PLAYFIELD_MEM0+14 ; Default display of "Beach", for lack of any other description.
   593
   594 = 4BB7			PLAYFIELD_MEM18 = PLAYFIELD_MEM0+23 ; One last line of Beach                   ; + 80 == 240
   595
   596
   597 4BF0				.align $0100  ; Realign to next page.
   598
   599 				; Labels for score, lives, etc are now done as Player/Missile graphics .
   600 				; The only thing left here are blanks as placeholders for the labels, 
   601 				; the score values and the color characters.
   602
   603 				; Top Score line for game score and Hi score.
   604
   605 4C00			SCORE_MEM1 ; Labels for scores                                                 ; + 40 == 40
   606 				; 1  |Score:00000000            00000000:Hi   | SCORE_TXT
   607 4C00-4C63> 00 00 00 00 + 	.sb "     " ; "SCORE"
   608 4C05 20				.by I_CO
   609 4C06			SCREEN_MYSCORE
   610 4C06 10 10 10 10 10 10 + 	.sb "00000000            " ; "HI"
   611 4C1A			SCREEN_HISCORE
   612 4C1A 10 10 10 10 10 10 + 	.sb "00000000"
   613 4C22 20				.by I_CO 
   614 4C23 00 00 00 00 00		.sb "     "
   615
   616 					
   617 4C28			SCORE_MEM2  ; Second line for lives, and frogs saved.              ; + 40 == 80
   618 				; 2  |Frogs:0    Frogs Saved:OOOOOOOOOOOOOOOOO| SCORE_TXT
   619 4C28 00 00 00 00 00		.sb "     " ; "FROGS"
   620 4C2D 20				.by I_CO
   621 4C2E			SCREEN_LIVES
   622 4C2E 00 00 00 00 00 00 + 	.sb"        "
   623 4C36			SCREEN_SAVED  ; 20 is waaaay more than a normal person can manage to rescue.
   624 4C36 00 00 00 00 00 00 + 	.sb "          "
   625 4C40 00 00 00 00 00 00 + 	.sb "          "
   626 4C4A 20				.by I_CO
   627 4C4B 00 00 00 00 00		.sb "     " ; "SAVED"
   628
   629
   630 				; Filler space for a Mode C line to show a line of COLPF0 between scrolling boat lines.
   631 4C50			MODE_C_COLPF0                                                      ; + 20 == 100
   632 					.rept 20
   633 						.BY %11111111
   634 					.ENDR
   634 					.endr
Source: REPT
   633 4C50 FF					.BY %11111111
   633 4C51 FF					.BY %11111111
   633 4C52 FF					.BY %11111111
   633 4C53 FF					.BY %11111111
   633 4C54 FF					.BY %11111111
   633 4C55 FF					.BY %11111111
   633 4C56 FF					.BY %11111111
   633 4C57 FF					.BY %11111111
   633 4C58 FF					.BY %11111111
   633 4C59 FF					.BY %11111111
   633 4C5A FF					.BY %11111111
   633 4C5B FF					.BY %11111111
   633 4C5C FF					.BY %11111111
   633 4C5D FF					.BY %11111111
   633 4C5E FF					.BY %11111111
   633 4C5F FF					.BY %11111111
   633 4C60 FF					.BY %11111111
   633 4C61 FF					.BY %11111111
   633 4C62 FF					.BY %11111111
   633 4C63 FF					.BY %11111111
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03ScreenMemory.asm
   635
   636
   637
   638 4C64				.align $0100
   639
   640
   641 				; FROG SAVED screen.
   642 				; Graphics chars design, SAVED!
   643 				; |  |]]|]]|  |  | ]|] |  | ]|] | ]|] | ]|]]|]]|] | ]|]]|] |  |  |]]|
   644 				; | ]|] |  |  |  |]]|]]|  | ]|] | ]|] | ]|] |  |  | ]|] |]]|  |  |]]|
   645 				; |  |]]|]]|  | ]|] | ]|] | ]|] | ]|] | ]|]]|]]|  | ]|] | ]|] |  |]]|
   646 				; |  |  | ]|] | ]|] | ]|] | ]|] | ]|] | ]|] |  |  | ]|] | ]|] |  |]]|
   647 				; |  |  | ]|] | ]|]]|]]|] |  |]]|]]|  | ]|] |  |  | ]|] |]]|  |  |  |
   648 				; |  |]]|]]|  | ]|] | ]|] |  | ]|] |  | ]|]]|]]|] | ]|]]|] |  |  |]]|
   649
   650 				; Graphics data, SAVED!  43 pixels.  To center: 40 - 21 == 19 blanks. 43 + 19 = 62. + 18 = 80
   651 				; Another benefit of using the bitmap is it makes the data much more obvious. 
   652 4D00			FROGSAVE_MEM                                            ; + 60 == 160
   653 4D00-4DB3> 00 00 0F 06 + 	.by %00000000 %00000000 %00001111 %00000110 %00011001 %10011111 %10011110 %00001100 %00000000 %00000000
   654 4D0A 00 00 18 0F 19 98 + 	.by %00000000 %00000000 %00011000 %00001111 %00011001 %10011000 %00011011 %00001100 %00000000 %00000000
   655 4D14 00 00 0F 19 99 9F + 	.by %00000000 %00000000 %00001111 %00011001 %10011001 %10011111 %00011001 %10001100 %00000000 %00000000
   656 4D1E 00 00 01 99 99 98 + 	.by %00000000 %00000000 %00000001 %10011001 %10011001 %10011000 %00011001 %10001100 %00000000 %00000000
   657 4D28 00 00 01 9F 8F 18 + 	.by %00000000 %00000000 %00000001 %10011111 %10001111 %00011000 %00011011 %00000000 %00000000 %00000000
   658 4D32 00 00 0F 19 86 1F + 	.by %00000000 %00000000 %00001111 %00011001 %10000110 %00011111 %10011110 %00001100 %00000000 %00000000
   659
   660
   661 				; FROG DEAD screen.
   662 				; Graphics chars design, DEAD FROG!
   663 				; | ]|]]|] |  | ]|]]|]]|] |  | ]|] |  | ]|]]|] |  |  |  |  | ]|]]|]]|] | ]|]]|]]|  |  |]]|]]|  |  |]]|]]|] |  |]]|
   664 				; | ]|] |]]|  | ]|] |  |  |  |]]|]]|  | ]|] |]]|  |  |  |  | ]|] |  |  | ]|] | ]|] | ]|] | ]|] | ]|] |  |  |  |]]|
   665 				; | ]|] | ]|] | ]|]]|]]|  | ]|] | ]|] | ]|] | ]|] |  |  |  | ]|]]|]]|  | ]|] | ]|] | ]|] | ]|] | ]|] |  |  |  |]]|
   666 				; | ]|] | ]|] | ]|] |  |  | ]|] | ]|] | ]|] | ]|] |  |  |  | ]|] |  |  | ]|]]|]]|  | ]|] | ]|] | ]|] |]]|] |  |]]|
   667 				; | ]|] |]]|  | ]|] |  |  | ]|]]|]]|] | ]|] |]]|  |  |  |  | ]|] |  |  | ]|] |]]|  | ]|] | ]|] | ]|] | ]|] |  |  |
   668 				; | ]|]]|] |  | ]|]]|]]|] | ]|] | ]|] | ]|]]|] |  |  |  |  | ]|] |  |  | ]|] | ]|] |  |]]|]]|  |  |]]|]]|] |  |]]|
   669
   670 				; Graphics data, DEAD FROG!  To center: (37) + 3 spaces.
   671 4D3C			FROGDEAD_MEM                                            ; + 60 == 120
   672 4D3C 0F 0F C3 0F 00 3F + 	.by %00001111 %00001111 %11000011 %00001111 %00000000 %00111111 %00111110 %00011110 %00011111 %00011000
   673 4D46 0D 8C 07 8D 80 30 + 	.by %00001101 %10001100 %00000111 %10001101 %10000000 %00110000 %00110011 %00110011 %00110000 %00011000
   674 4D50 0C CF 8C CC C0 3E + 	.by %00001100 %11001111 %10001100 %11001100 %11000000 %00111110 %00110011 %00110011 %00110000 %00011000
   675 4D5A 0C CC 0C CC C0 30 + 	.by %00001100 %11001100 %00001100 %11001100 %11000000 %00110000 %00111110 %00110011 %00110111 %00011000
   676 4D64 0D 8C 0F CD 80 30 + 	.by %00001101 %10001100 %00001111 %11001101 %10000000 %00110000 %00110110 %00110011 %00110011 %00000000
   677 4D6E 0F 0F CC CF 00 30 + 	.by %00001111 %00001111 %11001100 %11001111 %00000000 %00110000 %00110011 %00011110 %00011111 %00011000
   678
   679
   680 				; GAME OVER screen.
   681 				; Graphics chars design, GAME OVER
   682 				; |  |]]|]]|] |  | ]|] |  |]]|  | ]|] |]]|]]|]]|  |  |  |  |]]|]]|  | ]|] | ]|] | ]|]]|]]|] | ]|]]|]]|  |
   683 				; | ]|] |  |  |  |]]|]]|  |]]|] |]]|] |]]|  |  |  |  |  | ]|] | ]|] | ]|] | ]|] | ]|] |  |  | ]|] | ]|] |
   684 				; | ]|] |  |  | ]|] | ]|] |]]|]]|]]|] |]]|]]|] |  |  |  | ]|] | ]|] | ]|] | ]|] | ]|]]|]]|  | ]|] | ]|] |
   685 				; | ]|] |]]|] | ]|] | ]|] |]]| ]| ]|] |]]|  |  |  |  |  | ]|] | ]|] | ]|] | ]|] | ]|] |  |  | ]|]]|]]|  |
   686 				; | ]|] | ]|] | ]|]]|]]|] |]]|  | ]|] |]]|  |  |  |  |  | ]|] | ]|] |  |]]|]]|  | ]|] |  |  | ]|] |]]|  |
   687 				; |  |]]|]]|] | ]|] | ]|] |]]|  | ]|] |]]|]]|]]|  |  |  |  |]]|]]|  |  | ]|] |  | ]|]]|]]|] | ]|] | ]|] |
   688
   689 				; Graphics data, Game Over.  To center: (34) + 6 spaces.
   690 4D78			GAMEOVER_MEM                                            ; + 60 == 180
   691 4D78 00 F8 63 1B F0 0F + 	.by %00000000 %11111000 %01100011 %00011011 %11110000 %00001111 %00011001 %10011111 %10011111 %00000000
   692 4D82 01 80 F3 BB 00 19 + 	.by %00000001 %10000000 %11110011 %10111011 %00000000 %00011001 %10011001 %10011000 %00011001 %10000000
   693 4D8C 01 81 9B FB E0 19 + 	.by %00000001 %10000001 %10011011 %11111011 %11100000 %00011001 %10011001 %10011111 %00011001 %10000000
   694 4D96 01 B9 9B 5B 00 19 + 	.by %00000001 %10111001 %10011011 %01011011 %00000000 %00011001 %10011001 %10011000 %00011111 %00000000
   695 4DA0 01 99 FB 1B 00 19 + 	.by %00000001 %10011001 %11111011 %00011011 %00000000 %00011001 %10001111 %00011000 %00011011 %00000000
   696 4DAA 00 F9 9B 1B F0 0F + 	.by %00000000 %11111001 %10011011 %00011011 %11110000 %00001111 %00000110 %00011111 %10011001 %10000000
   697
   698
   699
   700 4DB4				.align $0100 ; Realign to next page.
   701
   702
   703
   704 4E00			TITLE_BACK_COLORS ; 26 entries 
   705 					; Mode 2 lines - text background (COLPF2) and border (COLBK). 
   706 					; Mode 9 lines - the Gfx (COLBK) background.
   707 4E00-4FC8> 00			.by 0 ; Entry 0 in the DLI list was indexed through by VBI to start the first entry. 
   708 4E01 00				.by COLOR_BLACK              ; Scores, and blank line
   709 4E02 00				.by COLOR_BLACK              ; Scores, and blank line
   710 4E03 70 62			.by COLOR_BLUE1        COLOR_PURPLE_BLUE+2      ; Title background colors.  Dark to light... 
   711 4E05 54 46			.by COLOR_PURPLE+4     COLOR_PINK+6             ; Title lines
   712 4E07 38 2A			.by COLOR_RED_ORANGE+8 COLOR_ORANGE2+10         ; Title lines
   713 4E09 1C				.by COLOR_ORANGE1+12                            ; Title lines
   714 4E0A 00				.by COLOR_BLACK                                 ; Space
   715 4E0B A0 A0 A0 A0			.by COLOR_AQUA COLOR_AQUA COLOR_AQUA COLOR_AQUA ; Instructions
   716 4E0F A0 A0 A0 A0			.by COLOR_AQUA COLOR_AQUA COLOR_AQUA COLOR_AQUA ; Instructions
   717 4E13 00				.by COLOR_BLACK                                 ; Space
   718 4E14 20 20 20			.by COLOR_ORANGE2 COLOR_ORANGE2 COLOR_ORANGE2   ; Scoring
   719 4E17 00				.by COLOR_BLACK                                 ; Space
   720 4E18 40 40			.by COLOR_PINK COLOR_PINK                       ; Controls
   721
   722 4E1A			TITLE_TEXT_COLORS ; 26 entries 
   723 					; Mode 2 lines - Text (COLPF1) luminance.  
   724 					; Mode 9 lines - the Gfx pixel (COLPF0) colors.
   725 4E1A 00				.by 0 ; Entry 0 in the DLI list was indexed through by VBI to start the first entry.
   726 4E1B 0E				.by $0E                               ; Scores, and blank line
   727 4E1C 0A				.by $0a                               ; Scores, and blank line
   728 4E1D			TITLE_PIXEL_COLORS
   729 4E1D EC DA C8 B6 A4 92		.by $EC $DA $C8 $B6 $A4 $92           ; title pixel colors. light to dark
   730 4E23			TITLE_UNDERLINE_COLOR
   731 4E23 C2				.by $C2                               ; title's underline.
   732 4E24 00				.by $00                               ; blank
   733 4E25 04 06 08 0A 0C 0A + 	.by $04 $06 $08 $0A $0C $0A $08 $06   ; Instructions
   734 4E2D 00				.by $00                               ; blank
   735 4E2E 06 08 0A			.by $06 $08 $0a                       ; Scoring
   736 4E31 00				.by $00                               ; blank
   737 4E32 08 0A			.by $08 $0A                           ; controls
   738
   739 4E34			TITLE_UNDERLINE_FADE ; Green to bright yellow transition when the SELECT/OPTION slide down occurs.  6 to 0
   740 4E34 1C CC CA C8 C6 C4 + 	.by COLOR_ORANGE1+12 COLOR_GREEN+12 COLOR_GREEN+10 COLOR_GREEN+8 COLOR_GREEN+6 COLOR_GREEN+4 COLOR_GREEN+2
   741
   742 4E3B			GAME_BACK_COLORS; 22 entries.
   743 4E3B 00				.by 0 ; Entry 0 in the DLI list was indexed through by VBI to start the first entry.
   744 4E3C 00				.by COLOR_BLACK       ; Scores
   745 4E3D 00				.by COLOR_BLACK       ; lives, saved frogs.
   746 					
   747 4E3E C6				.by COLOR_GREEN+6     ; Beach
   748 4E3F 92				.by COLOR_LITE_BLUE+2      ; Water for boats
   749 4E40 94				.by COLOR_LITE_BLUE+4      ; Water for boats. 
   750
   751 4E41 36				.by COLOR_RED_ORANGE+6
   752 4E42 72				.by COLOR_BLUE1+2     
   753 4E43 74				.by COLOR_BLUE1+4     ; Beach, boats, boats.
   754
   755 4E44 26				.by COLOR_ORANGE2+6   
   756 4E45 82				.by COLOR_BLUE2+2     
   757 4E46 84				.by COLOR_BLUE2+4     ; Beach, boats, boats.
   758
   759 4E47 36				.by COLOR_RED_ORANGE+6
   760 4E48 92				.by COLOR_LITE_BLUE+2 
   761 4E49 94				.by COLOR_LITE_BLUE+4 ; Beach, boats, boats.
   762
   763 4E4A 26				.by COLOR_ORANGE2+6   
   764 4E4B 72				.by COLOR_BLUE1+2     
   765 4E4C 74				.by COLOR_BLUE1+4     ; Beach, boats, boats.
   766
   767 4E4D C6				.by COLOR_GREEN+6 
   768 4E4E 82				.by COLOR_BLUE2+2      
   769 4E4F 84				.by COLOR_BLUE2+4      ; Beach, boats, boats.
   770
   771 4E50 26				.by COLOR_ORANGE2+6   ; one last Beach.
   772
   773 					
   774 4E51			GAME_COLPF0_COLORS; 22 entries
   775 4E51 00				.by 0 ; Entry 0 in the DLI list was indexed through by VBI to start the first entry.
   776 4E52 00				.by COLOR_BLACK       ; Scores
   777 4E53 00				.by COLOR_BLACK       ; lives, saved frogs.
   778
   779 4E54 70				.by COLOR_BLUE1       ; Beach sky
   780 4E55 94				.by COLOR_LITE_BLUE+4      ; Water top 1 with boats
   781 4E56 96				.by COLOR_LITE_BLUE+6      ; Water top 2 with boats
   782
   783 4E57 96				.by COLOR_LITE_BLUE+6      ; Beach sky (water)
   784 4E58 74				.by COLOR_BLUE1+4
   785 4E59 76				.by COLOR_BLUE1+6     
   786 					
   787 4E5A 76				.by COLOR_BLUE1+6     ; Beach sky (water)
   788 4E5B 84				.by COLOR_BLUE2+4    
   789 4E5C 86				.by COLOR_BLUE2+6    
   790 					
   791 4E5D 86				.by COLOR_BLUE2+6     ; Beach sky (water)
   792 4E5E 94				.by COLOR_LITE_BLUE+4
   793 4E5F 96				.by COLOR_LITE_BLUE+6 
   794 					
   795 4E60 96				.by COLOR_LITE_BLUE+6 ; Beach sky (water)
   796 4E61 74				.by COLOR_BLUE1+4    
   797 4E62 76				.by COLOR_BLUE1+6 
   798 					
   799 4E63 76				.by COLOR_BLUE1+6     ; Beach sky (water)
   800 4E64 84				.by COLOR_BLUE2+4
   801 4E65 86				.by COLOR_BLUE2+6      
   802 					
   803 4E66 86				.by COLOR_BLUE2+6      ; Beach sky (water)
   804
   805 				; beach color and the boats
   806 4E67			GAME_COLPF1_COLORS ; 22 entries
   807 4E67 00				.by 0 ; Entry 0 in the DLI list was indexed through by VBI to start the first entry.
   808 4E68 0E				.by COLOR_BLACK+$e       ; Scores
   809 4E69 0A				.by COLOR_BLACK+$a       ; lives, saved frogs.
   810 					
   811 4E6A C8				.by COLOR_GREEN+$8       ; beach 
   812 4E6B 4A				.by COLOR_PINK+$a        ; boat
   813 4E6C 5C				.by COLOR_PURPLE+$c      ; boat
   814 					
   815 4E6D 38				.by COLOR_RED_ORANGE+$8  ; beach
   816 4E6E 6A				.by COLOR_PURPLE_BLUE+$a
   817 4E6F BC				.by COLOR_BLUE_GREEN+$c
   818 					
   819 4E70 28				.by COLOR_ORANGE2+$8     ; beach
   820 4E71 CA				.by COLOR_GREEN+$a
   821 4E72 DC				.by COLOR_YELLOW_GREEN+$c
   822 					
   823 4E73 38				.by COLOR_RED_ORANGE+$8  ; beach
   824 4E74 EA				.by COLOR_ORANGE_GREEN+$a
   825 4E75 FC				.by COLOR_LITE_ORANGE+$c
   826 					
   827 4E76 28				.by COLOR_ORANGE2+$8     ; beach
   828 4E77 1A				.by COLOR_ORANGE1+$a
   829 4E78 2C				.by COLOR_ORANGE2+$c
   830 					
   831 4E79 C8				.by COLOR_GREEN+$8       ; beach
   832 4E7A 3A				.by COLOR_RED_ORANGE+$a
   833 4E7B 4C				.by COLOR_PINK+$c
   834 					
   835 4E7C 28				.by COLOR_ORANGE2+$8     ; Last beach
   836
   837 				; beach color, and the lines on the boat.
   838 4E7D			GAME_COLPF2_COLORS ; 22 entries.
   839 4E7D 00				.by 0 ; Entry 0 in the DLI list was indexed through by VBI to start the first entry.
   840 4E7E 00				.by COLOR_BLACK            ; Scores
   841 4E7F 00				.by COLOR_BLACK            ; lives, saved frogs.
   842 					
   843 4E80 C2				.by COLOR_GREEN+2          ; beach
   844 4E81 44				.by COLOR_PINK+$4          ; boat lines
   845 4E82 54				.by COLOR_PURPLE+$4        ; boat lines
   846 					
   847 4E83 32				.by COLOR_RED_ORANGE+2     ; beach
   848 4E84 64				.by COLOR_PURPLE_BLUE+$4
   849 4E85 B4				.by COLOR_BLUE_GREEN+$4
   850 					
   851 4E86 22				.by COLOR_ORANGE2+2        ; beach
   852 4E87 C4				.by COLOR_GREEN+$4
   853 4E88 D4				.by COLOR_YELLOW_GREEN+$4
   854 					
   855 4E89 32				.by COLOR_RED_ORANGE+2     ; beach
   856 4E8A E4				.by COLOR_ORANGE_GREEN+$4
   857 4E8B F4				.by COLOR_LITE_ORANGE+$4
   858 					
   859 4E8C 22				.by COLOR_ORANGE2+2        ; beach
   860 4E8D 14				.by COLOR_ORANGE1+$4
   861 4E8E 24				.by COLOR_ORANGE2+$4
   862 					
   863 4E8F C2				.by COLOR_GREEN+2          ; beach
   864 4E90 34				.by COLOR_RED_ORANGE+$4
   865 4E91 44				.by COLOR_PINK+$4
   866 					
   867 4E92 22				.by COLOR_ORANGE2+2        ; last beach
   868
   869
   870 4E93			GAME_COLPF3_COLORS ; 22 entries.  Arg!  Tried to avoid this, but it is needed 
   871 				                   ; in order to do the fade/wipe.
   872 4E93 00				.by 0 ; Entry 0 in the DLI list was indexed through by VBI to start the first entry.
   873 4E94 0E				.by COLOR_BLACK+$E ; Scores
   874 4E95 0E				.by COLOR_BLACK+$E ; lives, saved frogs.
   875
   876 4E96 0E				.by COLOR_BLACK+$E ; beach
   877 4E97 0E				.by COLOR_BLACK+$E
   878 4E98 0E				.by COLOR_BLACK+$E
   879 					
   880 4E99 0E				.by COLOR_BLACK+$E ; beach
   881 4E9A 0E				.by COLOR_BLACK+$E
   882 4E9B 0E				.by COLOR_BLACK+$E
   883
   884 4E9C 0E				.by COLOR_BLACK+$E ; beach
   885 4E9D 0E				.by COLOR_BLACK+$E
   886 4E9E 0E				.by COLOR_BLACK+$E
   887
   888 4E9F 0E				.by COLOR_BLACK+$E ; beach
   889 4EA0 0E				.by COLOR_BLACK+$E
   890 4EA1 0E				.by COLOR_BLACK+$E
   891
   892 4EA2 0E				.by COLOR_BLACK+$E ; beach
   893 4EA3 0E				.by COLOR_BLACK+$E
   894 4EA4 0E				.by COLOR_BLACK+$E
   895
   896 4EA5 0E				.by COLOR_BLACK+$E ; beach
   897 4EA6 0E				.by COLOR_BLACK+$E
   898 4EA7 0E				.by COLOR_BLACK+$E
   899
   900 4EA8 0E				.by COLOR_BLACK+$E ; Last beach
   901
   902
   903
   904 				; This stuff is supposed to set starting state for colors on the displays.
   905 				; This could use some major optimizations.  It should not need all these
   906 				; multiple blocks of 0 color.   Animated displays should animate themselves 
   907 				; naturally from a blank/black background.  Most of this should not be 
   908 				; needed beyond the colors for text, and the background for the text.
   909
   910 4EA9			DEAD_BACK_COLORS ; 48 entries.  Gfx background colors.
   911 4EA9 00				.by 0 ; Entry 0 in the DLI list was indexed through by VBI to start the first entry. ; 0
   912 4EAA 00				.by 0 ; Entry needed for PM/graphics reset                                           ; 1
   913
   914 4EAB 00 02 04 06			.by COLOR_BLACK+0  COLOR_BLACK+2  COLOR_BLACK+4  COLOR_BLACK+6  ; 2...5
   915 4EAF 08 0A 0C 0E			.by COLOR_BLACK+8  COLOR_BLACK+10 COLOR_BLACK+12 COLOR_BLACK+14 ; 6...9
   916 4EB3 00 02 04 06			.by COLOR_BLACK+0  COLOR_BLACK+2  COLOR_BLACK+4  COLOR_BLACK+6  ; 10..13
   917 4EB7 08 0A 0C 0E			.by COLOR_BLACK+8  COLOR_BLACK+10 COLOR_BLACK+12 COLOR_BLACK+14 ; 14..17
   918 4EBB 00 02 04			.by COLOR_BLACK+0  COLOR_BLACK+2  COLOR_BLACK+4                 ; 18..20
   919 					
   920 4EBE 00				.by $00 ; 21
   921
   922 4EBF C0 C2 C4 C6 C8 CA		.by COLOR_GREEN COLOR_GREEN+2 COLOR_GREEN+4 COLOR_GREEN+6 COLOR_GREEN+8 COLOR_GREEN+10 ; 22..27
   923
   924 4EC5 00				.by $00 ; 28
   925 					
   926 4EC6 0A 0C 0E		 	.by COLOR_BLACK+10 COLOR_BLACK+12 COLOR_BLACK+14                ; 29..31
   927 4EC9 00 02 04 06			.by COLOR_BLACK+0  COLOR_BLACK+2  COLOR_BLACK+4  COLOR_BLACK+6  ; 32..35
   928 4ECD 08 0A 0C 0E			.by COLOR_BLACK+8  COLOR_BLACK+10 COLOR_BLACK+12 COLOR_BLACK+14 ; 36..39
   929 4ED1 00 02 04 06			.by COLOR_BLACK+0  COLOR_BLACK+2  COLOR_BLACK+4  COLOR_BLACK+6  ; 40..43
   930 4ED5 08 0A 0C 0E			.by COLOR_BLACK+8  COLOR_BLACK+10 COLOR_BLACK+12 COLOR_BLACK+14 ; 44..47
   931
   932
   933
   934 4ED9			DEAD_COLPF0_COLORS ; 48 entries.  Gfx pixel colors.
   935 4ED9 00				.by 0 ; Entry 0 in the DLI list was indexed through by VBI to start the first entry.
   936 4EDA 00				.by 0 ; Entry needed for PM/graphics reset
   937 					
   938 					.rept 20
   939 						.BY $00                                     
   940 					.ENDR
   940 					.endr
Source: REPT
   939 4EDB 00					.BY $00                                     
   939 4EDC 00					.BY $00                                     
   939 4EDD 00					.BY $00                                     
   939 4EDE 00					.BY $00                                     
   939 4EDF 00					.BY $00                                     
   939 4EE0 00					.BY $00                                     
   939 4EE1 00					.BY $00                                     
   939 4EE2 00					.BY $00                                     
   939 4EE3 00					.BY $00                                     
   939 4EE4 00					.BY $00                                     
   939 4EE5 00					.BY $00                                     
   939 4EE6 00					.BY $00                                     
   939 4EE7 00					.BY $00                                     
   939 4EE8 00					.BY $00                                     
   939 4EE9 00					.BY $00                                     
   939 4EEA 00					.BY $00                                     
   939 4EEB 00					.BY $00                                     
   939 4EEC 00					.BY $00                                     
   939 4EED 00					.BY $00                                     
   939 4EEE 00					.BY $00                                     
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03ScreenMemory.asm
   941
   942 4EEF 4C 4A 48 46 44 42		.by COLOR_PINK+$0C COLOR_PINK+$0A COLOR_PINK+$08 COLOR_PINK+$06 COLOR_PINK+$04 COLOR_PINK+$02
   943
   944 					.rept 20
   945 						.BY $00                                     
   946 					.ENDR
   946 					.endr
Source: REPT
   945 4EF5 00					.BY $00                                     
   945 4EF6 00					.BY $00                                     
   945 4EF7 00					.BY $00                                     
   945 4EF8 00					.BY $00                                     
   945 4EF9 00					.BY $00                                     
   945 4EFA 00					.BY $00                                     
   945 4EFB 00					.BY $00                                     
   945 4EFC 00					.BY $00                                     
   945 4EFD 00					.BY $00                                     
   945 4EFE 00					.BY $00                                     
   945 4EFF 00					.BY $00                                     
   945 4F00 00					.BY $00                                     
   945 4F01 00					.BY $00                                     
   945 4F02 00					.BY $00                                     
   945 4F03 00					.BY $00                                     
   945 4F04 00					.BY $00                                     
   945 4F05 00					.BY $00                                     
   945 4F06 00					.BY $00                                     
   945 4F07 00					.BY $00                                     
   945 4F08 00					.BY $00                                     
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03ScreenMemory.asm
   947
   948
   949 4F09			WIN_BACK_COLORS ; 48 entries.  Gfx background colors.
   950 4F09 00				.by 0 ; Entry 0 in the DLI list was indexed through by VBI to start the first entry.
   951 4F0A 00				.by 0 ; Entry needed for PM/graphics reset
   952 					; Do not use $0x or $Fx for base color.
   953 					.rept 20
   954 						.BY $00                                     
   955 					.ENDR
   955 					.endr
Source: REPT
   954 4F0B 00					.BY $00                                     
   954 4F0C 00					.BY $00                                     
   954 4F0D 00					.BY $00                                     
   954 4F0E 00					.BY $00                                     
   954 4F0F 00					.BY $00                                     
   954 4F10 00					.BY $00                                     
   954 4F11 00					.BY $00                                     
   954 4F12 00					.BY $00                                     
   954 4F13 00					.BY $00                                     
   954 4F14 00					.BY $00                                     
   954 4F15 00					.BY $00                                     
   954 4F16 00					.BY $00                                     
   954 4F17 00					.BY $00                                     
   954 4F18 00					.BY $00                                     
   954 4F19 00					.BY $00                                     
   954 4F1A 00					.BY $00                                     
   954 4F1B 00					.BY $00                                     
   954 4F1C 00					.BY $00                                     
   954 4F1D 00					.BY $00                                     
   954 4F1E 00					.BY $00                                     
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03ScreenMemory.asm
   956
   957 4F1F 02 04 06 08 0A 0C		.by $02 $04 $06 $08 $0a $0C ; Static white background
   958
   959 					.rept 20
   960 						.BY $00                                     
   961 					.ENDR
   961 					.endr
Source: REPT
   960 4F25 00					.BY $00                                     
   960 4F26 00					.BY $00                                     
   960 4F27 00					.BY $00                                     
   960 4F28 00					.BY $00                                     
   960 4F29 00					.BY $00                                     
   960 4F2A 00					.BY $00                                     
   960 4F2B 00					.BY $00                                     
   960 4F2C 00					.BY $00                                     
   960 4F2D 00					.BY $00                                     
   960 4F2E 00					.BY $00                                     
   960 4F2F 00					.BY $00                                     
   960 4F30 00					.BY $00                                     
   960 4F31 00					.BY $00                                     
   960 4F32 00					.BY $00                                     
   960 4F33 00					.BY $00                                     
   960 4F34 00					.BY $00                                     
   960 4F35 00					.BY $00                                     
   960 4F36 00					.BY $00                                     
   960 4F37 00					.BY $00                                     
   960 4F38 00					.BY $00                                     
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03ScreenMemory.asm
   962
   963
   964 4F39			WIN_COLPF0_COLORS ; 48 entries.  Gfx pixel colors.
   965 4F39 00				.by 0 ; Entry 0 in the DLI list was indexed through by VBI to start the first entry.
   966 4F3A 00				.by 0 ; Entry needed for PM/graphics reset
   967 					
   968 					.rept 20
   969 						.BY $00                                     
   970 					.ENDR
   970 					.endr
Source: REPT
   969 4F3B 00					.BY $00                                     
   969 4F3C 00					.BY $00                                     
   969 4F3D 00					.BY $00                                     
   969 4F3E 00					.BY $00                                     
   969 4F3F 00					.BY $00                                     
   969 4F40 00					.BY $00                                     
   969 4F41 00					.BY $00                                     
   969 4F42 00					.BY $00                                     
   969 4F43 00					.BY $00                                     
   969 4F44 00					.BY $00                                     
   969 4F45 00					.BY $00                                     
   969 4F46 00					.BY $00                                     
   969 4F47 00					.BY $00                                     
   969 4F48 00					.BY $00                                     
   969 4F49 00					.BY $00                                     
   969 4F4A 00					.BY $00                                     
   969 4F4B 00					.BY $00                                     
   969 4F4C 00					.BY $00                                     
   969 4F4D 00					.BY $00                                     
   969 4F4E 00					.BY $00                                     
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03ScreenMemory.asm
   971 					; EOR first color of WIN_BACK+$80 (but not $0x or $Fx)
   972 4F4F AE AC AA A8 A6 A4		.by $AE $AC $AA $A8 $A6 $A4
   973
   974 					.rept 20
   975 						.BY $00                                     
   976 					.ENDR
   976 					.endr
Source: REPT
   975 4F55 00					.BY $00                                     
   975 4F56 00					.BY $00                                     
   975 4F57 00					.BY $00                                     
   975 4F58 00					.BY $00                                     
   975 4F59 00					.BY $00                                     
   975 4F5A 00					.BY $00                                     
   975 4F5B 00					.BY $00                                     
   975 4F5C 00					.BY $00                                     
   975 4F5D 00					.BY $00                                     
   975 4F5E 00					.BY $00                                     
   975 4F5F 00					.BY $00                                     
   975 4F60 00					.BY $00                                     
   975 4F61 00					.BY $00                                     
   975 4F62 00					.BY $00                                     
   975 4F63 00					.BY $00                                     
   975 4F64 00					.BY $00                                     
   975 4F65 00					.BY $00                                     
   975 4F66 00					.BY $00                                     
   975 4F67 00					.BY $00                                     
   975 4F68 00					.BY $00                                     
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03ScreenMemory.asm
   977
   978
   979 4F69			OVER_BACK_COLORS  ; 48 entries.  Gfx background colors.
   980 4F69 00				.by 0 ; Entry 0 in the DLI list was indexed through by VBI to start the first entry.
   981 4F6A 00				.by 0 ; Entry needed for PM/graphics reset
   982 					
   983 					.rept 20
   984 						.BY $00                                     
   985 					.ENDR
   985 					.endr
Source: REPT
   984 4F6B 00					.BY $00                                     
   984 4F6C 00					.BY $00                                     
   984 4F6D 00					.BY $00                                     
   984 4F6E 00					.BY $00                                     
   984 4F6F 00					.BY $00                                     
   984 4F70 00					.BY $00                                     
   984 4F71 00					.BY $00                                     
   984 4F72 00					.BY $00                                     
   984 4F73 00					.BY $00                                     
   984 4F74 00					.BY $00                                     
   984 4F75 00					.BY $00                                     
   984 4F76 00					.BY $00                                     
   984 4F77 00					.BY $00                                     
   984 4F78 00					.BY $00                                     
   984 4F79 00					.BY $00                                     
   984 4F7A 00					.BY $00                                     
   984 4F7B 00					.BY $00                                     
   984 4F7C 00					.BY $00                                     
   984 4F7D 00					.BY $00                                     
   984 4F7E 00					.BY $00                                     
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03ScreenMemory.asm
   986
   987 4F7F 00 00 00 00 00 00		.by  $00 $00 $00 $00 $00 $00 
   988
   989 					.rept 20
   990 						.BY $00                                     
   991 					.ENDR
   991 					.endr
Source: REPT
   990 4F85 00					.BY $00                                     
   990 4F86 00					.BY $00                                     
   990 4F87 00					.BY $00                                     
   990 4F88 00					.BY $00                                     
   990 4F89 00					.BY $00                                     
   990 4F8A 00					.BY $00                                     
   990 4F8B 00					.BY $00                                     
   990 4F8C 00					.BY $00                                     
   990 4F8D 00					.BY $00                                     
   990 4F8E 00					.BY $00                                     
   990 4F8F 00					.BY $00                                     
   990 4F90 00					.BY $00                                     
   990 4F91 00					.BY $00                                     
   990 4F92 00					.BY $00                                     
   990 4F93 00					.BY $00                                     
   990 4F94 00					.BY $00                                     
   990 4F95 00					.BY $00                                     
   990 4F96 00					.BY $00                                     
   990 4F97 00					.BY $00                                     
   990 4F98 00					.BY $00                                     
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03ScreenMemory.asm
   992
   993 4F99			OVER_COLPF0_COLORS ; 48 entries.  Gfx pixel colors.
   994 4F99 00				.by 0 ; Entry 0 in the DLI list was indexed through by VBI to start the first entry.
   995 4F9A 00				.by 0 ; Entry needed for PM/graphics reset
   996 					
   997 					.rept 20
   998 						.BY $00                                     
   999 					.ENDR
   999 					.endr
Source: REPT
   998 4F9B 00					.BY $00                                     
   998 4F9C 00					.BY $00                                     
   998 4F9D 00					.BY $00                                     
   998 4F9E 00					.BY $00                                     
   998 4F9F 00					.BY $00                                     
   998 4FA0 00					.BY $00                                     
   998 4FA1 00					.BY $00                                     
   998 4FA2 00					.BY $00                                     
   998 4FA3 00					.BY $00                                     
   998 4FA4 00					.BY $00                                     
   998 4FA5 00					.BY $00                                     
   998 4FA6 00					.BY $00                                     
   998 4FA7 00					.BY $00                                     
   998 4FA8 00					.BY $00                                     
   998 4FA9 00					.BY $00                                     
   998 4FAA 00					.BY $00                                     
   998 4FAB 00					.BY $00                                     
   998 4FAC 00					.BY $00                                     
   998 4FAD 00					.BY $00                                     
   998 4FAE 00					.BY $00                                     
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03ScreenMemory.asm
  1000
  1001 4FAF 0E 0C 0A 08 06 04		.by $0E $0C $0A $08 $06 $04
  1002
  1003 					.rept 20
  1004 						.BY $00                                     
  1005 					.ENDR
  1005 					.endr
Source: REPT
  1004 4FB5 00					.BY $00                                     
  1004 4FB6 00					.BY $00                                     
  1004 4FB7 00					.BY $00                                     
  1004 4FB8 00					.BY $00                                     
  1004 4FB9 00					.BY $00                                     
  1004 4FBA 00					.BY $00                                     
  1004 4FBB 00					.BY $00                                     
  1004 4FBC 00					.BY $00                                     
  1004 4FBD 00					.BY $00                                     
  1004 4FBE 00					.BY $00                                     
  1004 4FBF 00					.BY $00                                     
  1004 4FC0 00					.BY $00                                     
  1004 4FC1 00					.BY $00                                     
  1004 4FC2 00					.BY $00                                     
  1004 4FC3 00					.BY $00                                     
  1004 4FC4 00					.BY $00                                     
  1004 4FC5 00					.BY $00                                     
  1004 4FC6 00					.BY $00                                     
  1004 4FC7 00					.BY $00                                     
  1004 4FC8 00					.BY $00                                     
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03ScreenMemory.asm
  1006
  1007
  1008 4FC9				.align $0100 ; Realign to next page.
  1009
  1010
  1011 				; ==========================================================================
  1012 				; Tables listing pointers, etc .
  1013 				; --------------------------------------------------------------------------
  1014
  1015 				; All Display lists fit in one page, so only only byte update is needed.
  1016 5000			DISPLAYLIST_LO_TABLE  
  1017 5000-5083> 00			.byte <TITLE_DISPLAYLIST
  1018 5001 3D				.byte <GAME_DISPLAYLIST
  1019 5002 B5				.byte <FROGSAVED_DISPLAYLIST
  1020 5003 B5				.byte <FROGDEAD_DISPLAYLIST
  1021 5004 B5				.byte <GAMEOVER_DISPLAYLIST
  1022
  1023 5005			DISPLAYLIST_HI_TABLE
  1024 5005 46				.byte >TITLE_DISPLAYLIST
  1025 5006 46				.byte >GAME_DISPLAYLIST
  1026 5007 46				.byte >FROGSAVED_DISPLAYLIST
  1027 5008 46				.byte >FROGDEAD_DISPLAYLIST
  1028 5009 46				.byte >GAMEOVER_DISPLAYLIST
  1029
  1030 500A			DISPLAYLIST_GFXLMS_TABLE
  1031 500A 00 00			.byte $00, $00  ; no gfx pointer for title and game screen.
  1032 500C 00				.byte <FROGSAVE_MEM
  1033 500D 3C				.byte <FROGDEAD_MEM
  1034 500E 78				.byte <GAMEOVER_MEM
  1035
  1036 500F			DLI_LO_TABLE  ; Address of table pointing to chained DLI for  each screen.
  1037 500F 23				.byte <TITLE_DLI_CHAIN_TABLE ; DLI (0) -- Set colors for Scores.
  1038 5010 3E				.byte <GAME_DLI_CHAIN_TABLE
  1039 5011 54				.byte <SPLASH_DLI_CHAIN_TABLE ; FROGSAVED_DLI
  1040 5012 54				.byte <SPLASH_DLI_CHAIN_TABLE ; FROGDEAD_DLI
  1041 5013 54				.byte <SPLASH_DLI_CHAIN_TABLE ; GAMEOVER_DLI
  1042
  1043 5014			DLI_HI_TABLE
  1044 5014 50				.byte >TITLE_DLI_CHAIN_TABLE  ; DLI sets COLPF1, COLPF2, COLBK for score text. 
  1045 5015 50				.byte >GAME_DLI_CHAIN_TABLE   ; DLI sets COLPF1, COLPF2, COLBK for score text. 
  1046 5016 50				.byte >SPLASH_DLI_CHAIN_TABLE ; FROGSAVED_DLI
  1047 5017 50				.byte >SPLASH_DLI_CHAIN_TABLE ; FROGDEAD_DLI
  1048 5018 50				.byte >SPLASH_DLI_CHAIN_TABLE ; GAMEOVER_DLI
  1049
  1050 					; GTIA GPRIOR varies by Display for the player object.
  1051 					; The VBI will manage the values based on the current Display List.
  1052 					; Tell GTIA the various Player/Missile options and color controls
  1053 					; Turn on 5th Player (Missiles COLPF3), Multicolor players, and 
  1054 					; Priority bits %0001 put 5th Player below regular Players. 
  1055 5019			GPRIOR_TABLE
  1056 5019 21				.byte GTIA_MODE_DEFAULT|MULTICOLOR_PM|%0001              ; Title Screen ; Frog is Multi-color PM
  1057 501A 21				.byte GTIA_MODE_DEFAULT|MULTICOLOR_PM|%0001              ; Game Screen ; (Frog again) and uses P3/M3 as black left and right borders
  1058 501B 00				.byte 0                                                  ; Splash screen SAVED, no P/M
  1059 501C 00				.byte 0                                                  ; Splash screen DEAD, no P/M
  1060 501D 31				.byte GTIA_MODE_DEFAULT|FIFTH_PLAYER|MULTICOLOR_PM|%0001 ; Splash screen GAMEOVER - needs P5 
  1061
  1062 501E			DISPLAY_NEEDS_BORDERS_TABLE ; I thought it may get used more than once. :-(
  1063 501E 00				.byte 0 ; Title, no.
  1064 501F 01				.byte 1 ; Game, Yes.
  1065 5020 00				.byte 0 ; Saved, No.
  1066 5021 00				.byte 0 ; Dead, No.
  1067 5022 00				.byte 0 ; Over, No.
  1068
  1069 5023			TITLE_DLI_CHAIN_TABLE ; Low byte update to next DLI from the title display
  1070 5023 2B				.byte <Score1_DLI           ; DLI 0   SCORES   - COLBK,                 COLPF1
  1071 5024 43				.byte <Score2_DLI           ; DLI 1   SCORES   - COLBK,                 COLPF1
  1072 5025 A1				.byte <SPLASH_PMGSPECS2_DLI ; DLI 2   Table - Load PM Specs + COLPF0_COLBK_DLI
  1073 5026 9B				.byte <COLPF0_COLBK_DLI     ; DLI 3   Table - COLBK, Pixels - COLPF0
  1074 5027 9B				.byte <COLPF0_COLBK_DLI     ; DLI 4   Table - COLBK, Pixels - COLPF0
  1075 5028 9B				.byte <COLPF0_COLBK_DLI     ; DLI 5   Table - COLBK, Pixels - COLPF0
  1076 5029 9B				.byte <COLPF0_COLBK_DLI     ; DLI 6   Table - COLBK, Pixels - COLPF0
  1077 502A 9B				.byte <COLPF0_COLBK_DLI     ; DLI 7   Table - COLBK, Pixels - COLPF0
  1078 502B 9B				.byte <COLPF0_COLBK_DLI     ; DLI 8   Table - COLBK, Pixels - COLPF0
  1079 502C 00				.byte <TITLE_DLI_BLACKOUT   ; DLI 9   Black - COLBK COLPF2
  1080 502D 13				.byte <TITLE_DLI_TEXTBLOCK  ; DLI 10  Text - COLPF1, Table - COLBK COLPF2. - start instructions
  1081 502E 13				.byte <TITLE_DLI_TEXTBLOCK  ; DLI 11  Text - COLPF1
  1082 502F 13				.byte <TITLE_DLI_TEXTBLOCK  ; DLI 12  Text - COLPF1
  1083 5030 13				.byte <TITLE_DLI_TEXTBLOCK  ; DLI 13  Text - COLPF1
  1084 5031 13				.byte <TITLE_DLI_TEXTBLOCK  ; DLI 14  Text - COLPF1
  1085 5032 13				.byte <TITLE_DLI_TEXTBLOCK  ; DLI 15  Text - COLPF1
  1086 5033 13				.byte <TITLE_DLI_TEXTBLOCK  ; DLI 16  Text - COLPF1
  1087 5034 13				.byte <TITLE_DLI_TEXTBLOCK  ; DLI 17  Text - COLPF1 - end instructions.
  1088 5035 00				.byte <TITLE_DLI_BLACKOUT   ; DLI 18  Black - COLBK COLPF2
  1089 5036 13				.byte <TITLE_DLI_TEXTBLOCK  ; DLI 19  Text - COLPF1, Table - COLBK COLPF2. - start scoring
  1090 5037 13				.byte <TITLE_DLI_TEXTBLOCK  ; DLI 20  Text - COLPF1
  1091 5038 13				.byte <TITLE_DLI_TEXTBLOCK  ; DLI 21  Text - COLPF1 - end scoring
  1092 5039 00				.byte <TITLE_DLI_BLACKOUT   ; DLI 22  Black - COLBK COLPF2
  1093 503A 13				.byte <TITLE_DLI_TEXTBLOCK  ; DLI 23  Text - COLPF1, Table - COLBK COLPF2. - start controls
  1094 503B 13				.byte <TITLE_DLI_TEXTBLOCK  ; DLI 24  Text - COLPF1 - end controls
  1095 503C 00				.byte <TITLE_DLI_BLACKOUT   ; DLI 25  Black - COLBK COLPF2
  1096 503D AF				.byte <DLI_SPC1             ; DLI 26 Special DLI for Press Button Prompt will go to DLI SPC2 for Scrolling text.	
  1097 				;	.byte <TITLE_DLI_SPC2       ; DLI 27 
  1098
  1099
  1100 503E			GAME_DLI_CHAIN_TABLE    ; Low byte update to next DLI from the title display
  1101 503E 2B				.byte <Score1_DLI            ; DLI (0)   SCORES   - COLBK,                 COLPF1
  1102 503F 43				.byte <Score2_DLI            ; DLI (1)   SCORES   - COLBK,                 COLPF1
  1103 					
  1104 5040 58				.byte <GAME_DLI_BEACH0      ; DLI (2)   Beach 18 - COLBK,         COLPF0, COLPF1, COLPF2, COLPF3.
  1105 5041 74				.byte <GAME_DLI_BEACH2BOAT  ; DLI (3)   Boats 17 - COLBK, HSCROL, COLPF0, COLPF1, COLPF2, COLPF3
  1106 5042 74				.byte <GAME_DLI_BOAT2BOAT   ; DLI (4)   Boats 16 - COLBK, HSCROL, COLPF0, COLPF1, COLPF2, COLPF3
  1107 					
  1108 5043 8B				.byte <GAME_DLI_BOAT2BEACH  ; DLI (5)   Beach 15 - COLBK,         COLPF0, COLPF1, COLPF2, COLPF3
  1109 5044 74				.byte <GAME_DLI_BEACH2BOAT  ; DLI (6)   Boats 14 - COLBK, HSCROL, COLPF0, COLPF1, COLPF2, COLPF3
  1110 5045 74				.byte <GAME_DLI_BOAT2BOAT   ; DLI (7)   Boats 13 - COLBK, HSCROL, COLPF0, COLPF1, COLPF2, COLPF3
  1111
  1112 5046 8B				.byte <GAME_DLI_BOAT2BEACH  ; DLI (8)   Beach 12 - COLBK,         COLPF0, COLPF1, COLPF2, COLPF3.
  1113 5047 74				.byte <GAME_DLI_BEACH2BOAT  ; DLI (9)   Boats 11 - COLBK, HSCROL, COLPF0, COLPF1, COLPF2, COLPF3
  1114 5048 74				.byte <GAME_DLI_BOAT2BOAT   ; DLI (10)  Boats 10 - COLBK, HSCROL, COLPF0, COLPF1, COLPF2, COLPF3
  1115
  1116 5049 8B				.byte <GAME_DLI_BOAT2BEACH  ; DLI (11)  Beach 09 - COLBK,         COLPF0, COLPF1, COLPF2, COLPF3.
  1117 504A 74				.byte <GAME_DLI_BEACH2BOAT  ; DLI (12)  Boats 08 - COLBK, HSCROL, COLPF0, COLPF1, COLPF2, COLPF3
  1118 504B 74				.byte <GAME_DLI_BOAT2BOAT   ; DLI (13)  Boats 07 - COLBK, HSCROL, COLPF0, COLPF1, COLPF2, COLPF3
  1119
  1120 504C 8B				.byte <GAME_DLI_BOAT2BEACH  ; DLI (14)  Beach 06 - COLBK,         COLPF0, COLPF1, COLPF2, COLPF3.
  1121 504D 74				.byte <GAME_DLI_BEACH2BOAT  ; DLI (15)  Boats 05 - COLBK, HSCROL, COLPF0, COLPF1, COLPF2, COLPF3
  1122 504E 74				.byte <GAME_DLI_BOAT2BOAT   ; DLI (16)  Boats 04 - COLBK, HSCROL, COLPF0, COLPF1, COLPF2, COLPF3
  1123
  1124 504F 8B				.byte <GAME_DLI_BOAT2BEACH  ; DLI (17)  Beach 03 - COLBK,         COLPF0, COLPF1, COLPF2, COLPF3.
  1125 5050 74				.byte <GAME_DLI_BEACH2BOAT  ; DLI (18)  Boats 02 - COLBK, HSCROL, COLPF0, COLPF1, COLPF2, COLPF3
  1126 5051 74				.byte <GAME_DLI_BOAT2BOAT   ; DLI (19)  Boats 01 - COLBK, HSCROL, COLPF0, COLPF1, COLPF2, COLPF3
  1127
  1128 5052 8B				.byte <GAME_DLI_BOAT2BEACH   ; DLI (20)  Beach 00 - COLBK,         COLPF0, COLPF1, COLPF2, COLPF3.
  1129 5053 CC				.byte <DLI_SPC2   ; DLI (21)  Credits  - Set scrolling credits HSCROL.  Set colors.
  1130
  1131
  1132 				; All three graphics screens use the same list.
  1133 				; Basically, the background color is updated per every line
  1134 5054			SPLASH_DLI_CHAIN_TABLE ; Low byte update to next DLI from the title display
  1135 5054 9E				.byte <SPLASH_PMGZERO_DLI ; DLI (0)  ; VBI uses 0 for initializing DLI.
  1136 5055 9B				.byte <COLPF0_COLBK_DLI
  1137 5056 9B				.byte <COLPF0_COLBK_DLI ; DLI (1)  1
  1138 5057 9B				.byte <COLPF0_COLBK_DLI     ; DLI (2)  2
  1139 5058 9B				.byte <COLPF0_COLBK_DLI     ; DLI (3)  3
  1140 5059 A1				.byte <SPLASH_PMGSPECS2_DLI ; DLI (4)  4 Load PM Specs + COLPF0_COLBK_DLI
  1141 505A 9B				.byte <COLPF0_COLBK_DLI     ; DLI (5)  5
  1142 505B 9B				.byte <COLPF0_COLBK_DLI     ; DLI (6)  6 ; And position players
  1143 505C 9B				.byte <COLPF0_COLBK_DLI     ; DLI (7)  7
  1144 505D 9B				.byte <COLPF0_COLBK_DLI     ; DLI (8)  8
  1145 505E 9B				.byte <COLPF0_COLBK_DLI     ; DLI (9)  9
  1146 505F 9B				.byte <COLPF0_COLBK_DLI     ; DLI (10) 10
  1147 5060 9B				.byte <COLPF0_COLBK_DLI     ; DLI (11) 11
  1148 5061 9B				.byte <COLPF0_COLBK_DLI     ; DLI (12) 12
  1149 5062 9B				.byte <COLPF0_COLBK_DLI     ; DLI (13) 13
  1150 5063 9B				.byte <COLPF0_COLBK_DLI     ; DLI (14) 14
  1151 5064 9B				.byte <COLPF0_COLBK_DLI     ; DLI (15) 15
  1152 5065 9B				.byte <COLPF0_COLBK_DLI     ; DLI (16) 16
  1153 5066 9B				.byte <COLPF0_COLBK_DLI     ; DLI (17) 17
  1154 5067 9B				.byte <COLPF0_COLBK_DLI     ; DLI (18) 18
  1155 5068 9B				.byte <COLPF0_COLBK_DLI     ; DLI (19) 19
  1156 5069 9B				.byte <COLPF0_COLBK_DLI     ; DLI (20) 20
  1157
  1158 506A 9B				.byte <COLPF0_COLBK_DLI     ; DLI (21) 1 Splash Graphics
  1159 506B 9B				.byte <COLPF0_COLBK_DLI     ; DLI (22) 2 Splash Graphics
  1160 506C 9B				.byte <COLPF0_COLBK_DLI     ; DLI (23) 3 Splash Graphics
  1161 506D 9B				.byte <COLPF0_COLBK_DLI     ; DLI (24) 4 Splash Graphics
  1162 506E 9B				.byte <COLPF0_COLBK_DLI     ; DLI (25) 5 Splash Graphics
  1163 506F 9B				.byte <COLPF0_COLBK_DLI     ; DLI (26) 6 Splash Graphics
  1164
  1165 5070 9B				.byte <COLPF0_COLBK_DLI     ; DLI (27) 20 
  1166 5071 9B				.byte <COLPF0_COLBK_DLI     ; DLI (28) 19 
  1167 5072 9B				.byte <COLPF0_COLBK_DLI     ; DLI (29) 18 
  1168 5073 9B				.byte <COLPF0_COLBK_DLI     ; DLI (30) 17 
  1169 5074 9B				.byte <COLPF0_COLBK_DLI     ; DLI (31) 16 
  1170 5075 9B				.byte <COLPF0_COLBK_DLI     ; DLI (32) 15 
  1171 5076 9B				.byte <COLPF0_COLBK_DLI     ; DLI (33) 14
  1172 5077 9B				.byte <COLPF0_COLBK_DLI     ; DLI (34) 13
  1173 5078 9B				.byte <COLPF0_COLBK_DLI     ; DLI (35) 12
  1174 5079 9B				.byte <COLPF0_COLBK_DLI     ; DLI (36) 11
  1175 507A 9B				.byte <COLPF0_COLBK_DLI     ; DLI (37) 10
  1176 507B 9B				.byte <COLPF0_COLBK_DLI     ; DLI (38) 9
  1177 507C 9B				.byte <COLPF0_COLBK_DLI     ; DLI (39) 8
  1178 507D 9B				.byte <COLPF0_COLBK_DLI     ; DLI (40) 7
  1179 507E 9B				.byte <COLPF0_COLBK_DLI     ; DLI (41) 6
  1180 507F 9B				.byte <COLPF0_COLBK_DLI     ; DLI (42) 5
  1181 5080 9B				.byte <COLPF0_COLBK_DLI     ; DLI (43) 4
  1182 5081 9B				.byte <COLPF0_COLBK_DLI     ; DLI (44) 3
  1183 5082 9B				.byte <COLPF0_COLBK_DLI     ; DLI (45) 2
  1184
  1185 5083 AF				.byte <DLI_SPC1             ; DLI 47 - Special DLI for Press Button Prompt will go to the next DLI for Scrolling text.
  1186 				;	.byte <DLI_SPC2             ; DLI 48 - Set black background and white text for scrolling credits
  1187
  1188
  1189 				; Color tables must be big enough to contain data up to the maximum DLI index that
  1190 				; occurs of all the screens. 
  1191 				; COLPF3 is white all the time.
  1192
  1193 5084			COLBK_TABLE ; Must be big enough to do splash screens. +1 for entry 0
  1194 = 5084				.ds 49
  1195
  1196 50B5			COLPF0_TABLE ; Must be big enough to do splash screens. +1 for entry 0
  1197 = 50B5				.ds 49
  1198
  1199 50E6			COLPF1_TABLE ; Must be big enough to do Title screen. 
  1200 = 50E6				.ds 49
  1201
  1202 5117			COLPF2_TABLE ; Must be big enough to do Title screen.
  1203 = 5117				.ds 49
  1204
  1205 5148			COLPF3_TABLE ; Must be big enough to do Game screen. (22 entries.)
  1206 5148-5359> 0E 0E 0E 0E + 	.by $0E $0E $0E $0E $0E
  1207 514D 0E 0E 0E 0E 0E		.by $0E $0E $0E $0E $0E
  1208 5152 0E 0E 0E 0E 0E		.by $0E $0E $0E $0E $0E
  1209 5157 0E 0E 0E 0E 0E		.by $0E $0E $0E $0E $0E
  1210 515C 0E 0E			.by $0E $0E ; Should end here at 22.   
  1211 					; But, In case of generic clear code, continue to 49
  1212 515E 0E 0E 0E			.by $0E $0E $0E
  1213 5161 0E 0E 0E 0E 0E		.by $0E $0E $0E $0E $0E
  1214 5166 0E 0E 0E 0E 0E		.by $0E $0E $0E $0E $0E
  1215 516B 0E 0E 0E 0E 0E		.by $0E $0E $0E $0E $0E
  1216 5170 0E 0E 0E 0E 0E		.by $0E $0E $0E $0E $0E
  1217 5175 0E 0E 0E 0E			.by $0E $0E $0E $0E 
  1218
  1219 5179			HSCROL_TABLE ; Must be big enough to do Game screen up to  last boat row. (21 entries)
  1220 5179 00				.by 0 ; Entry 0 in the DLI list was indexed through by VBI to start the first entry.
  1221 517A 00 00 00			.by 0 0 0 ; Top, scores, beach
  1222 517D 00 0E			.by 0 14
  1223 517F 00				.by 0 ; beach
  1224 5180 02 0C			.by 2 12
  1225 5182 00				.by 0 ; beach
  1226 5183 04 0A			.by 4 10
  1227 5185 00				.by 0 ; beach
  1228 5186 06 08			.by 6 8
  1229 5188 00				.by 0 ; beach
  1230 5189 08 06			.by 8 6
  1231 518B 00				.by 0 ; beach
  1232 518C 0A 04			.by 10 4
  1233
  1234
  1235 				; The current display uses the following values for Players/missiles 
  1236 				; which are sliced by DLIs into three parts on the screen.
  1237 				; 1) the Top score line labels.
  1238 				; 2) the lives and saved frogs line of text labels.
  1239 				; 3) The animated object.  Frog on the Title and game screen.  Tomb on the Game over.
  1240 				; Some displays do not show all the components.
  1241
  1242 518E			PLAYER_MISSILE_BASE_SPECS
  1243
  1244 518E 00 00 00		COLPM0_TABLE   .by $00 $00 $00 ; Each row: Scores, Lives, Animated object
  1245 5191 00 00 00		COLPM1_TABLE   .by $00 $00 $00 ; Each row: Scores, Lives, Animated object
  1246 5194 00 00 00		COLPM2_TABLE   .by $00 $00 $00 ; Each row: Scores, Lives, Animated object
  1247 5197 00 00 00		COLPM3_TABLE   .by $00 $00 $00 ; Each row: Scores, Lives, Animated object
  1248
  1249 519A 00 00 00		SIZEP0_TABLE   .by $00 $00 $00 ; Each row: Scores, Lives, Animated object
  1250 519D 00 00 00		SIZEP1_TABLE   .by $00 $00 $00 ; Each row: Scores, Lives, Animated object
  1251 51A0 00 00 00		SIZEP2_TABLE   .by $00 $00 $00 ; Each row: Scores, Lives, Animated object
  1252 51A3 00 00 00		SIZEP3_TABLE   .by $00 $00 $00 ; Each row: Scores, Lives, Animated object
  1253 51A6 00 00 00		SIZEM_TABLE    .by $00 $00 $00 ; Each row: Scores, Lives, Animated object
  1254
  1255 51A9 00 00 00		HPOSP0_TABLE   .by $00 $00 $00 ; Each row: Scores, Lives, Animated object
  1256 51AC 00 00 00		HPOSP1_TABLE   .by $00 $00 $00 ; Each row: Scores, Lives, Animated object
  1257 51AF 00 00 00		HPOSP2_TABLE   .by $00 $00 $00 ; Each row: Scores, Lives, Animated object
  1258 51B2 00 00 00		HPOSP3_TABLE   .by $00 $00 $00 ; Each row: Scores, Lives, Animated object
  1259
  1260 51B5 00 00 00		HPOSM0_TABLE   .by $00 $00 $00 ; Each row: Scores, Lives, Animated object
  1261 51B8 00 00 00		HPOSM1_TABLE   .by $00 $00 $00 ; Each row: Scores, Lives, Animated object
  1262 51BB 00 00 00		HPOSM2_TABLE   .by $00 $00 $00 ; Each row: Scores, Lives, Animated object
  1263 51BE 00 00 00		HPOSM3_TABLE   .by $00 $00 $00 ; Each row: Scores, Lives, Animated object
  1264
  1265 51C1 00 00 00		PRIOR_TABLE    .by $00 $00 $00 ; Each row: Scores, Lives, Animated object
  1266
  1267
  1268 				; Given a Display number, these are the values for the Player/Missiles 
  1269 				; tables above.  Multiply Display number (0 to 4) times sizeof the pile 
  1270 				; of table entries (54 bytes).  Or maybe just look it up from a table.
  1271
  1272 51C4			TITLE_BASE_PMG_TABLE ; Each row: Scores, Lives, Animated object
  1273 51C4 86 56 C4			.by COLOR_BLUE2+STATUS_LUMA COLOR_PURPLE+STATUS_LUMA COLOR_GREEN+$4 ; COLPM0_TABLE 
  1274 51C7 86 56 C2			.by COLOR_BLUE2+STATUS_LUMA COLOR_PURPLE+STATUS_LUMA COLOR_GREEN+$2 ; COLPM1_TABLE 
  1275 51CA 46 C6 0E			.by COLOR_PINK+STATUS_LUMA  COLOR_GREEN+STATUS_LUMA  COLOR_BLACK+$E ; COLPM2_TABLE 
  1276 51CD 00 C6 00			.by $00                     COLOR_GREEN+STATUS_LUMA  COLOR_BLACK    ; COLPM3_TABLE 
  1277 					
  1278 51D0 00 00 00			.by PM_SIZE_NORMAL PM_SIZE_NORMAL PM_SIZE_NORMAL ; SIZEP0_TABLE 
  1279 51D3 00 00 00			.by PM_SIZE_NORMAL PM_SIZE_NORMAL PM_SIZE_NORMAL ; SIZEP1_TABLE 
  1280 51D6 00 00 00			.by PM_SIZE_NORMAL PM_SIZE_NORMAL PM_SIZE_NORMAL ; SIZEP2_TABLE 
  1281 51D9 00 00 00			.by PM_SIZE_NORMAL PM_SIZE_NORMAL PM_SIZE_NORMAL ; SIZEP3_TABLE 
  1282 51DC 00 00 00			.by PM_SIZE_NORMAL PM_SIZE_NORMAL PM_SIZE_NORMAL ; SIZEM_TABLE 
  1283 					
  1284 51DF 30 30 00			.by PLAYFIELD_LEFT_EDGE_NORMAL       PLAYFIELD_LEFT_EDGE_NORMAL       $00 ; HPOSP0_TABLE 
  1285 51E2 38 38 00			.by [PLAYFIELD_LEFT_EDGE_NORMAL+8]   [PLAYFIELD_LEFT_EDGE_NORMAL+8]   $00 ; HPOSP1_TABLE 
  1286 51E5 BC BC 00			.by [PLAYFIELD_RIGHT_EDGE_NORMAL-19] [PLAYFIELD_RIGHT_EDGE_NORMAL-19] $00 ; HPOSP2_TABLE 
  1287 51E8 00 C4 00			.by $00                              [PLAYFIELD_RIGHT_EDGE_NORMAL-11] $00 ; HPOSP3_TABLE 
  1288 					
  1289 51EB 42 42 00			.by [PLAYFIELD_LEFT_EDGE_NORMAL+18] [PLAYFIELD_LEFT_EDGE_NORMAL+18]  $00 ; HPOSM0_TABLE 
  1290 51EE 40 40 00			.by [PLAYFIELD_LEFT_EDGE_NORMAL+16] [PLAYFIELD_LEFT_EDGE_NORMAL+16]  $00 ; HPOSM1_TABLE 
  1291 51F1 00 CE 00			.by $00                             [PLAYFIELD_RIGHT_EDGE_NORMAL-1]  $00 ; HPOSM2_TABLE 
  1292 51F4 00 CC 00			.by $00                             [PLAYFIELD_RIGHT_EDGE_NORMAL-3]  $00 ; HPOSM3_TABLE
  1293
  1294 51F7 01 01 21			.by [GTIA_MODE_DEFAULT|%0001] [GTIA_MODE_DEFAULT|%0001] [GTIA_MODE_DEFAULT|MULTICOLOR_PM|%0001] ; PRIOR_TABLE 
  1295
  1296 51FA			GAME_BASE_PMG_TABLE
  1297 51FA 86 56 C4			.by COLOR_BLUE2+STATUS_LUMA COLOR_PURPLE+STATUS_LUMA COLOR_GREEN+$4 ; COLPM0_TABLE 
  1298 51FD 86 56 C2			.by COLOR_BLUE2+STATUS_LUMA COLOR_PURPLE+STATUS_LUMA COLOR_GREEN+$2 ; COLPM1_TABLE 
  1299 5200 46 C6 0E			.by COLOR_PINK+STATUS_LUMA  COLOR_GREEN+STATUS_LUMA  COLOR_BLACK+$E ; COLPM2_TABLE 
  1300 5203 00 C6 00			.by $00                     COLOR_GREEN+STATUS_LUMA  COLOR_BLACK    ; COLPM3_TABLE 
  1301 					
  1302 5206 00 00 00			.by PM_SIZE_NORMAL PM_SIZE_NORMAL PM_SIZE_NORMAL ; SIZEP0_TABLE 
  1303 5209 00 00 00			.by PM_SIZE_NORMAL PM_SIZE_NORMAL PM_SIZE_NORMAL ; SIZEP1_TABLE 
  1304 520C 00 00 00			.by PM_SIZE_NORMAL PM_SIZE_NORMAL PM_SIZE_NORMAL ; SIZEP2_TABLE 
  1305 520F 00 00 03			.by PM_SIZE_NORMAL PM_SIZE_NORMAL PM_SIZE_QUAD   ; SIZEP3_TABLE ; Borders
  1306 5212 00 00 C0			.by PM_SIZE_NORMAL PM_SIZE_NORMAL %11000000      ; SIZEM_TABLE  ; Borders
  1307 					
  1308 5215 30 30 00			.by PLAYFIELD_LEFT_EDGE_NORMAL       PLAYFIELD_LEFT_EDGE_NORMAL       $00 ; HPOSP0_TABLE 
  1309 5218 38 38 00			.by [PLAYFIELD_LEFT_EDGE_NORMAL+8]   [PLAYFIELD_LEFT_EDGE_NORMAL+8]   $00 ; HPOSP1_TABLE 
  1310 521B BC BC 00			.by [PLAYFIELD_RIGHT_EDGE_NORMAL-19] [PLAYFIELD_RIGHT_EDGE_NORMAL-19] $00 ; HPOSP2_TABLE 
  1311 521E 00 C4 D0			.by $00                              [PLAYFIELD_RIGHT_EDGE_NORMAL-11] [PLAYFIELD_RIGHT_EDGE_NORMAL+1] ; HPOSP3_TABLE 
  1312 					
  1313 5221 42 42 00			.by [PLAYFIELD_LEFT_EDGE_NORMAL+18] [PLAYFIELD_LEFT_EDGE_NORMAL+18] $00 ; HPOSM0_TABLE 
  1314 5224 40 40 00			.by [PLAYFIELD_LEFT_EDGE_NORMAL+16] [PLAYFIELD_LEFT_EDGE_NORMAL+16] $00 ; HPOSM1_TABLE 
  1315 5227 00 CE 00			.by $00                             [PLAYFIELD_RIGHT_EDGE_NORMAL-1] $00 ; HPOSM2_TABLE 
  1316 522A 00 CC 28			.by $00                             [PLAYFIELD_RIGHT_EDGE_NORMAL-3] [PLAYFIELD_LEFT_EDGE_NORMAL-8] ; HPOSM3_TABLE
  1317
  1318 522D 01 01 21			.by [GTIA_MODE_DEFAULT|%0001] [GTIA_MODE_DEFAULT|%0001] [GTIA_MODE_DEFAULT|MULTICOLOR_PM|%0001] ; PRIOR_TABLE 
  1319
  1320 5230			WIN_BASE_PMG_TABLE ; Each row: Scores, Lives, Animated object
  1321 5230 00 00 C4			.by $00 $00 COLOR_GREEN+$4 ; COLPM0_TABLE 
  1322 5233 00 00 C2			.by $00 $00 COLOR_GREEN+$2 ; COLPM1_TABLE 
  1323 5236 00 00 0E			.by $00 $00 COLOR_BLACK+$E ; COLPM2_TABLE 
  1324 5239 00 00 00			.by $00 $00 COLOR_BLACK    ; COLPM3_TABLE 
  1325 					
  1326 523C 00 00 00			.by PM_SIZE_NORMAL PM_SIZE_NORMAL PM_SIZE_NORMAL ; SIZEP0_TABLE 
  1327 523F 00 00 00			.by PM_SIZE_NORMAL PM_SIZE_NORMAL PM_SIZE_NORMAL ; SIZEP1_TABLE 
  1328 5242 00 00 00			.by PM_SIZE_NORMAL PM_SIZE_NORMAL PM_SIZE_NORMAL ; SIZEP2_TABLE 
  1329 5245 00 00 00			.by PM_SIZE_NORMAL PM_SIZE_NORMAL PM_SIZE_NORMAL ; SIZEP3_TABLE 
  1330 5248 00 00 03			.by PM_SIZE_NORMAL PM_SIZE_NORMAL PM_SIZE_QUAD   ; SIZEM_TABLE 
  1331
  1332 524B 00 00 00			.by $00 $00 $00 ; HPOSP0_TABLE ; After switching to Win Display, restore Frog HPOS
  1333 524E 00 00 00			.by $00 $00 $00 ; HPOSP1_TABLE 
  1334 5251 00 00 00			.by $00 $00 $00 ; HPOSP2_TABLE 
  1335 5254 00 00 00			.by $00 $00 $00 ; HPOSP3_TABLE 
  1336 					
  1337 5257 00 00 00			.by $00 $00 $00 ; HPOSM0_TABLE 
  1338 525A 00 00 00			.by $00 $00 $00 ; HPOSM1_TABLE 
  1339 525D 00 00 00			.by $00 $00 $00 ; HPOSM2_TABLE 
  1340 5260 00 00 00			.by $00 $00 $00 ; HPOSM3_TABLE
  1341
  1342 5263 01 01 21			.by [GTIA_MODE_DEFAULT|%0001] [GTIA_MODE_DEFAULT|%0001] [GTIA_MODE_DEFAULT|MULTICOLOR_PM|%0001] ; PRIOR_TABLE 
  1343
  1344 5266			DEAD_BASE_PMG_TABLE ; Each row: Scores, Lives, Animated object (nothing on screen)
  1345 5266 00 00 00			.by $00 $00 $00 ; COLPM0_TABLE 
  1346 5269 00 00 00			.by $00 $00 $00 ; COLPM1_TABLE 
  1347 526C 00 00 00			.by $00 $00 $00 ; COLPM2_TABLE 
  1348 526F 00 00 00			.by $00 $00 $00 ; COLPM3_TABLE 
  1349 					
  1350 5272 00 00 00			.by PM_SIZE_NORMAL PM_SIZE_NORMAL PM_SIZE_NORMAL ; SIZEP0_TABLE 
  1351 5275 00 00 00			.by PM_SIZE_NORMAL PM_SIZE_NORMAL PM_SIZE_NORMAL ; SIZEP1_TABLE 
  1352 5278 00 00 00			.by PM_SIZE_NORMAL PM_SIZE_NORMAL PM_SIZE_NORMAL ; SIZEP2_TABLE 
  1353 527B 00 00 00			.by PM_SIZE_NORMAL PM_SIZE_NORMAL PM_SIZE_NORMAL ; SIZEP3_TABLE 
  1354 527E 00 00 00			.by PM_SIZE_NORMAL PM_SIZE_NORMAL PM_SIZE_NORMAL ; SIZEM_TABLE 
  1355 					
  1356 5281 00 00 00			.by $00 $00 $00 ; HPOSP0_TABLE ; After switching to Win Display, restore Frog HPOS
  1357 5284 00 00 00			.by $00 $00 $00 ; HPOSP1_TABLE 
  1358 5287 00 00 00			.by $00 $00 $00 ; HPOSP2_TABLE 
  1359 528A 00 00 00			.by $00 $00 $00 ; HPOSP3_TABLE 
  1360 					
  1361 528D 00 00 00			.by $00 $00 $00 ; HPOSM0_TABLE 
  1362 5290 00 00 00			.by $00 $00 $00 ; HPOSM1_TABLE 
  1363 5293 00 00 00			.by $00 $00 $00 ; HPOSM2_TABLE 
  1364 5296 00 00 00			.by $00 $00 $00 ; HPOSM3_TABLE
  1365
  1366 5299 01 01 01			.by [GTIA_MODE_DEFAULT|%0001] [GTIA_MODE_DEFAULT|%0001] [GTIA_MODE_DEFAULT|%0001] ; PRIOR_TABLE 
  1367
  1368 529C			OVER_BASE_PMG_TABLE ; Each row: Scores, Lives, Animated object
  1369 529C 00 00 02			.by $00 $00 COLOR_BLACK+$2 ; COLPM0_TABLE 
  1370 529F 00 00 0E			.by $00 $00 COLOR_BLACK+$e ; COLPM1_TABLE 
  1371 52A2 00 00 00			.by $00 $00 COLOR_BLACK+$0 ; COLPM2_TABLE 
  1372 52A5 00 00 00			.by $00 $00 COLOR_BLACK+$0 ; COLPM3_TABLE 
  1373 					
  1374 52A8 00 00 00			.by PM_SIZE_NORMAL PM_SIZE_NORMAL PM_SIZE_NORMAL ; SIZEP0_TABLE 
  1375 52AB 00 00 00			.by PM_SIZE_NORMAL PM_SIZE_NORMAL PM_SIZE_NORMAL ; SIZEP1_TABLE 
  1376 52AE 00 00 00			.by PM_SIZE_NORMAL PM_SIZE_NORMAL PM_SIZE_NORMAL ; SIZEP2_TABLE 
  1377 52B1 00 00 00			.by PM_SIZE_NORMAL PM_SIZE_NORMAL PM_SIZE_NORMAL ; SIZEP3_TABLE 
  1378 52B4 00 00 03			.by PM_SIZE_NORMAL PM_SIZE_NORMAL PM_SIZE_QUAD   ; SIZEM_TABLE 
  1379
  1380 52B7 00 00 00			.by $00 $00 $00 ; HPOSP0_TABLE ; After switching to Win Display, restore Frog HPOS
  1381 52BA 00 00 00			.by $00 $00 $00 ; HPOSP1_TABLE 
  1382 52BD 00 00 00			.by $00 $00 $00 ; HPOSP2_TABLE 
  1383 52C0 00 00 00			.by $00 $00 $00 ; HPOSP3_TABLE 
  1384 					
  1385 52C3 00 00 00			.by $00 $00 $00 ; HPOSM0_TABLE 
  1386 52C6 00 00 00			.by $00 $00 $00 ; HPOSM1_TABLE 
  1387 52C9 00 00 00			.by $00 $00 $00 ; HPOSM2_TABLE 
  1388 52CC 00 00 00			.by $00 $00 $00 ; HPOSM3_TABLE
  1389
  1390 52CF			OVER_BASE_PRIOR
  1391 52CF 01 01 31			.by [GTIA_MODE_DEFAULT|%0001] [GTIA_MODE_DEFAULT|%0001] [GTIA_MODE_DEFAULT|FIFTH_PLAYER|MULTICOLOR_PM|%0001] ; PRIOR_TABLE 
  1392
  1393
  1394 52D2			MANAGE_SCORE_COLORS_TABLE  ; For each #DISPLAY, are the scores visible?
  1395 52D2 01 01 00 00 00		.by 1 1 0 0 0 
  1396
  1397 52D7			MANAGE_LIVES_COLORS_TABLE  ; For each #DISPLAY, are the Lives visible?
  1398 52D7 01 01 00 00 00		.by 1 1 0 0 0 
  1399
  1400
  1401 				; On changing a display load up the Player/Missile tables 
  1402 				; from the bulk value at these pointers:
  1403
  1404 52DC			BASE_PMG_LO_TABLE
  1405 52DC C4				.byte <TITLE_BASE_PMG_TABLE
  1406 52DD FA				.byte <GAME_BASE_PMG_TABLE
  1407 52DE 30				.byte <WIN_BASE_PMG_TABLE
  1408 52DF 66				.byte <DEAD_BASE_PMG_TABLE
  1409 52E0 9C				.byte <OVER_BASE_PMG_TABLE
  1410
  1411 52E1			BASE_PMG_HI_TABLE
  1412 52E1 51				.byte >TITLE_BASE_PMG_TABLE
  1413 52E2 51				.byte >GAME_BASE_PMG_TABLE
  1414 52E3 52				.byte >WIN_BASE_PMG_TABLE
  1415 52E4 52				.byte >DEAD_BASE_PMG_TABLE
  1416 52E5 52				.byte >OVER_BASE_PMG_TABLE
  1417
  1418 52E6			COLOR_BACK_LO_TABLE
  1419 52E6 00				.byte <TITLE_BACK_COLORS
  1420 52E7 3B				.byte <GAME_BACK_COLORS
  1421 52E8 09				.byte <WIN_BACK_COLORS
  1422 52E9 A9				.byte <DEAD_BACK_COLORS
  1423 52EA 69				.byte <OVER_BACK_COLORS
  1424
  1425 52EB			COLOR_BACK_HI_TABLE
  1426 52EB 4E				.byte >TITLE_BACK_COLORS
  1427 52EC 4E				.byte >GAME_BACK_COLORS
  1428 52ED 4F				.byte >WIN_BACK_COLORS
  1429 52EE 4E				.byte >DEAD_BACK_COLORS
  1430 52EF 4F				.byte >OVER_BACK_COLORS
  1431
  1432 52F0			COLOR_TEXT_LO_TABLE
  1433 52F0 1A				.byte <TITLE_TEXT_COLORS
  1434 52F1 67				.byte <GAME_COLPF1_COLORS
  1435 52F2 39				.byte <WIN_COLPF0_COLORS
  1436 52F3 D9				.byte <DEAD_COLPF0_COLORS
  1437 52F4 99				.byte <OVER_COLPF0_COLORS
  1438
  1439 52F5			COLOR_TEXT_HI_TABLE
  1440 52F5 4E				.byte >TITLE_TEXT_COLORS
  1441 52F6 4E				.byte >GAME_COLPF1_COLORS
  1442 52F7 4F				.byte >WIN_COLPF0_COLORS
  1443 52F8 4E				.byte >DEAD_COLPF0_COLORS
  1444 52F9 4F				.byte >OVER_COLPF0_COLORS
  1445
  1446
  1447 				; List of pointers to the animation character shapes for the boats.
  1448
  1449 				; R I G H T 
  1450
  1451 52FA			RIGHT_BOAT_WATER_LOW ; Front wave of boat
  1452 52FA A0				.byte <[RIGHT_BOAT_WATER_ANIM]
  1453 52FB A8				.byte <[RIGHT_BOAT_WATER_ANIM+8]
  1454 52FC B0				.byte <[RIGHT_BOAT_WATER_ANIM+16]
  1455 52FD B8				.byte <[RIGHT_BOAT_WATER_ANIM+24]
  1456 52FE C0				.byte <[RIGHT_BOAT_WATER_ANIM+32]
  1457 52FF C8				.byte <[RIGHT_BOAT_WATER_ANIM+40]
  1458 5300 D0				.byte <[RIGHT_BOAT_WATER_ANIM+48]
  1459 5301 D8				.byte <[RIGHT_BOAT_WATER_ANIM+56]
  1460
  1461 5302			RIGHT_BOAT_WATER_HIGH
  1462 5302 44				.byte >[RIGHT_BOAT_WATER_ANIM]
  1463 5303 44				.byte >[RIGHT_BOAT_WATER_ANIM+8]
  1464 5304 44				.byte >[RIGHT_BOAT_WATER_ANIM+16]
  1465 5305 44				.byte >[RIGHT_BOAT_WATER_ANIM+24]
  1466 5306 44				.byte >[RIGHT_BOAT_WATER_ANIM+32]
  1467 5307 44				.byte >[RIGHT_BOAT_WATER_ANIM+40]
  1468 5308 44				.byte >[RIGHT_BOAT_WATER_ANIM+48]
  1469 5309 44				.byte >[RIGHT_BOAT_WATER_ANIM+56]
  1470
  1471 530A			RIGHT_BOAT_FRONT_LOW ; Front of Boat.
  1472 530A 90				.byte <[RIGHT_BOAT_FRONT_ANIM]   
  1473 530B 90				.byte <[RIGHT_BOAT_FRONT_ANIM]
  1474 530C 98				.byte <[RIGHT_BOAT_FRONT_ANIM+8] ; switch on 2
  1475 530D 98				.byte <[RIGHT_BOAT_FRONT_ANIM+8]
  1476 530E 98				.byte <[RIGHT_BOAT_FRONT_ANIM+8]
  1477 530F 98				.byte <[RIGHT_BOAT_FRONT_ANIM+8]
  1478 5310 90				.byte <[RIGHT_BOAT_FRONT_ANIM]  ; switch on 6
  1479 5311 90				.byte <[RIGHT_BOAT_FRONT_ANIM]
  1480
  1481 5312			RIGHT_BOAT_FRONT_HIGH
  1482 5312 44				.byte >[RIGHT_BOAT_FRONT_ANIM]
  1483 5313 44				.byte >[RIGHT_BOAT_FRONT_ANIM]
  1484 5314 44				.byte >[RIGHT_BOAT_FRONT_ANIM+8]
  1485 5315 44				.byte >[RIGHT_BOAT_FRONT_ANIM+8]
  1486 5316 44				.byte >[RIGHT_BOAT_FRONT_ANIM+8]
  1487 5317 44				.byte >[RIGHT_BOAT_FRONT_ANIM+8]
  1488 5318 44				.byte >[RIGHT_BOAT_FRONT_ANIM]
  1489 5319 44				.byte >[RIGHT_BOAT_FRONT_ANIM]
  1490
  1491 531A			RIGHT_BOAT_WAKE_LOW
  1492 531A E0				.byte <[RIGHT_BOAT_WAKE_ANIM]
  1493 531B E8				.byte <[RIGHT_BOAT_WAKE_ANIM+8]
  1494 531C F0				.byte <[RIGHT_BOAT_WAKE_ANIM+16]
  1495 531D F8				.byte <[RIGHT_BOAT_WAKE_ANIM+24]
  1496 531E 00				.byte <[RIGHT_BOAT_WAKE_ANIM+32]
  1497 531F 08				.byte <[RIGHT_BOAT_WAKE_ANIM+40]
  1498 5320 10				.byte <[RIGHT_BOAT_WAKE_ANIM+48]
  1499 5321 18				.byte <[RIGHT_BOAT_WAKE_ANIM+56]
  1500
  1501 5322			RIGHT_BOAT_WAKE_HIGH
  1502 5322 44				.byte >[RIGHT_BOAT_WAKE_ANIM]
  1503 5323 44				.byte >[RIGHT_BOAT_WAKE_ANIM+8]
  1504 5324 44				.byte >[RIGHT_BOAT_WAKE_ANIM+16]
  1505 5325 44				.byte >[RIGHT_BOAT_WAKE_ANIM+24]
  1506 5326 45				.byte >[RIGHT_BOAT_WAKE_ANIM+32]
  1507 5327 45				.byte >[RIGHT_BOAT_WAKE_ANIM+40]
  1508 5328 45				.byte >[RIGHT_BOAT_WAKE_ANIM+48]
  1509 5329 45				.byte >[RIGHT_BOAT_WAKE_ANIM+56]
  1510
  1511 				; L E F T 
  1512
  1513 532A			LEFT_BOAT_WATER_LOW
  1514 532A 10				.byte <[LEFT_BOAT_WATER_ANIM]
  1515 532B 18				.byte <[LEFT_BOAT_WATER_ANIM+8]
  1516 532C 20				.byte <[LEFT_BOAT_WATER_ANIM+16]
  1517 532D 28				.byte <[LEFT_BOAT_WATER_ANIM+24]
  1518 532E 30				.byte <[LEFT_BOAT_WATER_ANIM+32]
  1519 532F 38				.byte <[LEFT_BOAT_WATER_ANIM+40]
  1520 5330 40				.byte <[LEFT_BOAT_WATER_ANIM+48]
  1521 5331 48				.byte <[LEFT_BOAT_WATER_ANIM+56]
  1522
  1523 5332			LEFT_BOAT_WATER_HIGH
  1524 5332 44				.byte >[LEFT_BOAT_WATER_ANIM]
  1525 5333 44				.byte >[LEFT_BOAT_WATER_ANIM+8]
  1526 5334 44				.byte >[LEFT_BOAT_WATER_ANIM+16]
  1527 5335 44				.byte >[LEFT_BOAT_WATER_ANIM+24]
  1528 5336 44				.byte >[LEFT_BOAT_WATER_ANIM+32]
  1529 5337 44				.byte >[LEFT_BOAT_WATER_ANIM+40]
  1530 5338 44				.byte >[LEFT_BOAT_WATER_ANIM+48]
  1531 5339 44				.byte >[LEFT_BOAT_WATER_ANIM+56]
  1532 					
  1533 533A			LEFT_BOAT_FRONT_LOW
  1534 533A 00				.byte <[LEFT_BOAT_FRONT_ANIM]
  1535 533B 00				.byte <[LEFT_BOAT_FRONT_ANIM]
  1536 533C 08				.byte <[LEFT_BOAT_FRONT_ANIM+8] ; switch on 2
  1537 533D 08				.byte <[LEFT_BOAT_FRONT_ANIM+8]
  1538 533E 08				.byte <[LEFT_BOAT_FRONT_ANIM+8]
  1539 533F 08				.byte <[LEFT_BOAT_FRONT_ANIM+8]
  1540 5340 00				.byte <[LEFT_BOAT_FRONT_ANIM]  ; switch on 6
  1541 5341 00				.byte <[LEFT_BOAT_FRONT_ANIM]
  1542
  1543 5342			LEFT_BOAT_FRONT_HIGH
  1544 5342 44				.byte >[LEFT_BOAT_FRONT_ANIM]
  1545 5343 44				.byte >[LEFT_BOAT_FRONT_ANIM]
  1546 5344 44				.byte >[LEFT_BOAT_FRONT_ANIM+8]
  1547 5345 44				.byte >[LEFT_BOAT_FRONT_ANIM+8]
  1548 5346 44				.byte >[LEFT_BOAT_FRONT_ANIM+8]
  1549 5347 44				.byte >[LEFT_BOAT_FRONT_ANIM+8]
  1550 5348 44				.byte >[LEFT_BOAT_FRONT_ANIM]
  1551 5349 44				.byte >[LEFT_BOAT_FRONT_ANIM]
  1552
  1553 534A			LEFT_BOAT_WAKE_LOW
  1554 534A 50				.byte <[LEFT_BOAT_WAKE_ANIM]
  1555 534B 58				.byte <[LEFT_BOAT_WAKE_ANIM+8]
  1556 534C 60				.byte <[LEFT_BOAT_WAKE_ANIM+16]
  1557 534D 68				.byte <[LEFT_BOAT_WAKE_ANIM+24]
  1558 534E 70				.byte <[LEFT_BOAT_WAKE_ANIM+32]
  1559 534F 78				.byte <[LEFT_BOAT_WAKE_ANIM+40]
  1560 5350 80				.byte <[LEFT_BOAT_WAKE_ANIM+48]
  1561 5351 88				.byte <[LEFT_BOAT_WAKE_ANIM+56]
  1562
  1563 5352			LEFT_BOAT_WAKE_HIGH
  1564 5352 44				.byte >[LEFT_BOAT_WAKE_ANIM]
  1565 5353 44				.byte >[LEFT_BOAT_WAKE_ANIM+8]
  1566 5354 44				.byte >[LEFT_BOAT_WAKE_ANIM+16]
  1567 5355 44				.byte >[LEFT_BOAT_WAKE_ANIM+24]
  1568 5356 44				.byte >[LEFT_BOAT_WAKE_ANIM+32]
  1569 5357 44				.byte >[LEFT_BOAT_WAKE_ANIM+40]
  1570 5358 44				.byte >[LEFT_BOAT_WAKE_ANIM+48]
  1571 5359 44				.byte >[LEFT_BOAT_WAKE_ANIM+56]
  1572
  1573
  1574 				; ==========================================================================
  1575 				; PLAYER/MISSILE GRAPHICS
  1576 				;
  1577 				; --------------------------------------------------------------------------
  1578 				; VBI manages moving Frog around, so there's never any visible tearing.
  1579 				; Also, its best to evaluate the P/M collisions when the display is not active.
  1580
  1581 = 0030			MIN_FROGX = PLAYFIELD_LEFT_EDGE_NORMAL    ; Left edge of frog movement
  1582 = 00C7			MAX_FROGX = PLAYFIELD_RIGHT_EDGE_NORMAL-8 ; right edge of frog movement
  1583 = 007B			MID_FROGX = [MIN_FROGX+MAX_FROGX]/2       ; Middle of screen, starting position.
  1584
  1585 = 00D0			MAX_FROGY = PM_1LINE_NORMAL_BOTTOM-15     ; starting position for frog at bottom of screen
  1586
  1587 = 0054			OFF_FROGX = 84                            ; Offset for frog X coordinates on title animation.
  1588 = 004B			OFF_FROGY = 75                            ; Offset for frog Y coordinates on title animation.
  1589 = 0054			OFF_TOMBX = 84                            ; Offset for tomb X coordinates on game over animation.
  1590 = 004B			OFF_TOMBY = 75                            ; Offset for tomb Y coordinates on game over animation.
  1591
  1592 				; List of Player/Missile shapes.
  1593 = 0000			SHAPE_OFF   = 0
  1594 = 0001			SHAPE_FROG  = 1
  1595 = 0002			SHAPE_SPLAT = 2
  1596 = 0003			SHAPE_TOMB  = 3
  1597
  1598
  1599 535A				.align $0800 ; single line P/M needs 2K boundary.
  1600
  1601 5800			PMADR
  1602
  1603 = 5B00			MISSILEADR = PMADR+$300
  1604 = 5C00			PLAYERADR0 = PMADR+$400
  1605 = 5D00			PLAYERADR1 = PMADR+$500
  1606 = 5E00			PLAYERADR2 = PMADR+$600
  1607 = 5F00			PLAYERADR3 = PMADR+$700
  1608
  1609
  1610 				; The first three pages of P/M memory are free, so plenty of space
  1611 				; to lay out the simple and mostly un-animated frog stuff.
  1612
  1613 				; P0 = Left part of Frog.
  1614 				; P1 = Right part of frog, mouth, and the eyeballs.
  1615 				; P2 = Whites of the eyes.
  1616
  1617 				; P3/M3 = Black (On game screen the left and right masks.)
  1618 				;               (On Dead screen the "RIP" on the tomb)
  1619 				;               (unused on Main, Win, and GameOver.)
  1620
  1621 				; HPOS changes:
  1622 				; P0 == X
  1623 				; P1 == X+1
  1624 				; P2 == X+1
  1625
  1626 				; . - ] + . - ] + .
  1627 				; . - ] ] ] ] ] + .
  1628 				; - W W W ] W W W +
  1629 				; - W B W ] W B W +
  1630 				; - W W W ] W W W +
  1631 				; - ] ] ] ] ] ] ] +
  1632 				; . - ] ] ] ] ] + .
  1633 				; . - ] + + + ] + .
  1634 				; . - ] ] ] ] ] + .
  1635 				; . . - ] ] ] + . .
  1636 				; . . . - ] + . . .
  1637
  1638 				; Players 0, 1 Are the greens of the Frog.
  1639 				; P0                 P1
  1640 				; . 0 0 . . 0 0 .    . 1 1 . . 1 1 .  - 0   66  66
  1641 				; 0 0 0 0 0 0 0 .    . 1 1 1 1 1 1 1  - 1   FE  7F
  1642 				; 0 . . . 0 . . .    . . . 1 . . . 1  - 2   88  11
  1643 				; 0 . . . 0 . . .    . . . 1 . . . 1  - 3   88  11
  1644 				; 0 . . . 0 . . .    . . . 1 . . . 1  - 4   88  11
  1645 				; 0 0 0 0 0 0 0 0    1 1 1 1 1 1 1 1  - 5   FF  FF
  1646 				; 0 0 0 0 0 0 0 0    1 1 1 1 1 1 1 1  - 6   FF  FF
  1647 				; 0 0 . . . . . 0    1 1 1 1 1 1 1 1  - 7   C1  FF
  1648 				; 0 0 0 . . . 0 0    1 1 1 1 1 1 1 1  - 8   E3  FF
  1649 				; . 0 0 0 0 0 0 .    . 1 1 1 1 1 1 .  - 9   7E  7E
  1650 				; . . 0 0 0 0 . .    . . 1 1 1 1 . .  - 10  3C  3C
  1651
  1652 5800			PLAYER0_FROG_DATA 
  1653 5800-5914> 66 FE 88 88 + 	.by $66 $FE $88 $88 $88 $FF $FF $C1 $E3 $7E $3c
  1654
  1655 580B			PLAYER1_FROG_DATA
  1656 580B 66 7F 11 11 11 FF + 	.by $66 $7F $11 $11 $11 $FF $FF $FF $FF $7E $3C
  1657
  1658 				; Player 2 is the white eyes.
  1659 				; 2 2 2 . 2 2 2 . 
  1660 5816			PLAYER2_FROG_DATA  ; at Y+2 to Y+4
  1661 5816 00 00 EE EE EE 00 + 	.by $00 $00 $ee $ee $ee $00 $00 $00 $00 $00 $00
  1662
  1663 					
  1664 				; Using 4 bytes here instead of 3 to eliminate another address lookup table.
  1665 				; The 4th byte is the same for all instances.
  1666 				; Eye positions:
  1667 				;  - 3 -
  1668 				;  0 1 2
  1669 				;  - - -
  1670
  1671 				; 0 . . . 0 . . .    . . . 1 . . . 1  - 3   88  11
  1672 				; 0 . . . 0 . . .    1 . . 1 1 . . 1  - 2   88  99
  1673 				; 0 . . . 0 . . .    . . . 1 . . . 1  - 4   88  11
  1674 				; 0 0 0 0 0 0 0 .    1 1 1 1 1 1 1 1  - 5   FE  FF  
  1675
  1676 				; 0 . . . 0 . . .    . . . 1 . . . 1  - 2   88  11
  1677 				; 0 . . . 0 . . .    . 1 . 1 . 1 . 1  - 3   88  55
  1678 				; 0 . . . 0 . . .    . . . 1 . . . 1  - 4   88  11
  1679 				; 0 0 0 0 0 0 0 .    1 1 1 1 1 1 1 1  - 5   FE  FF  
  1680
  1681 				; 0 . . . 0 . . .    . . . 1 . . . 1  - 3   88  11
  1682 				; 0 . . . 0 . . .    . . 1 1 . . 1 1  - 2   88  33
  1683 				; 0 . . . 0 . . .    . . . 1 . . . 1  - 4   88  11
  1684 				; 0 0 0 0 0 0 0 .    1 1 1 1 1 1 1 1  - 5   FE  FF  
  1685
  1686 				; 0 . . . 0 . . .    . 1 . 1 . 1 . 1  - 2   88  55
  1687 				; 0 . . . 0 . . .    . . . 1 . . . 1  - 3   88  11
  1688 				; 0 . . . 0 . . .    . . . 1 . . . 1  - 4   88  11
  1689 				; 0 0 0 0 0 0 0 .    1 1 1 1 1 1 1 1  - 5   FE  FF  
  1690
  1691 5821			PLAYER1_EYE_DATA
  1692 5821 11 99 11 FF			.by $11 $99 $11 $FF
  1693 5825 11 55 11 FF			.by $11 $55 $11 $FF
  1694 5829 11 33 11 FF			.by $11 $33 $11 $FF
  1695 582D 55 11 11 FF			.by $55 $11 $11 $FF
  1696
  1697
  1698
  1699 				; Splatty Frog
  1700 				; P0                 P1
  1701 				; . 0 0 .  . . 0 0    . 1 1 .  . . 1 1  - 0
  1702 				; 0 0 0 0  . 0 0 0    1 1 1 1  . 1 1 1  - 1
  1703 				; 0 0 0 0  . 0 0 0    1 1 1 1  . 1 1 1  - 2
  1704 				; . 0 0 0  . 0 0 .    . 1 1 1  . 1 1 .  - 3
  1705 				; . . . 0  0 0 . .    . . . 1  1 1 . .  - 4
  1706 				; 0 0 . 0  0 0 0 0    1 1 . 1  1 1 1 1  - 5
  1707 				; . 0 0 0  0 0 . .    . 1 1 1  1 1 . .  - 6
  1708 				; . 0 0 0  0 0 . .    . 1 1 1  1 1 . .  - 7
  1709 				; 0 0 0 .  . 0 0 .    1 1 1 .  . 1 1 .  - 8 
  1710 				; 0 0 0 .  . 0 0 0    1 1 1 .  . 1 1 1  - 9 
  1711 				; . . . .  . 0 0 .    . . . .  . 1 1 .  - 10
  1712
  1713 5831			PLAYER0_SPLATTER_DATA
  1714 5831 63 F7 F7 76 1C DF + 	.by $63 $F7 $F7 $76 $1C $DF $7C $7C $E6 $E7 $06
  1715
  1716 583C			PLAYER1_SPLATTER_DATA
  1717 583C 63 F7 F7 76 1C DF + 	.by $63 $F7 $F7 $76 $1C $DF $7C $7C $E6 $E7 $06
  1718
  1719
  1720 				; HPOS changes:
  1721 				; P0 == X
  1722 				; P1 == X+7
  1723 				; P2 == X+5
  1724 				; P3 == X+4
  1725 				; M0 == X+2
  1726
  1727 				; Interred Frog for Game Over
  1728 				; . . . . . . . . ~ . . . . . .  - 1
  1729 				; . . . . . . . ~ ~ ~ . . . . .  - 2
  1730 				; . . . . . . . . ~ . . . . . .  - 3
  1731 				; . . . . . . . . ~ . . . . . .  - 4
  1732 				; . . . > > > > > ~ . . . . . .  - 5 
  1733 				; . . > > > > ~ ~ ~ ~ ~ . . . .  - 6
  1734 				; . > > > > ~ ~ ~ ~ ~ ~ ~ . . .  - 7
  1735 				; . > > > ~ ~ ~ ~ ~ ~ ~ ~ ~ . .  - 8
  1736 				; > > > ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ .  - 9
  1737 				; > > > ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ .  - 10
  1738 				; > > ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~  - 11
  1739 				; > > ~ ~ ] ] ~ ~ ] ~ ] ] ~ ~ ~  - 12
  1740 				; > > ~ ~ ] ~ ] ~ ] ~ ] ~ ] ~ ~  - 13
  1741 				; > > ~ ~ ] ] ~ ~ ] ~ ] ] ~ ~ ~  - 14
  1742 				; > > ~ ~ ] ] ~ ~ ] ~ ] ~ ~ ~ ~  - 15
  1743 				; > > ~ ~ ] ~ ] ~ ] ~ ] ~ ~ ~ ~  - 16
  1744 				; > > ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~  - 17
  1745 				; > > ~ ~ ~ ~ ] ] ] ] ] ~ ~ ~ ~  - 18
  1746 				; > > ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~  - 19
  1747 				; > > ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~  - 20 
  1748 				; > > ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~  - 21
  1749 				; . > ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~  - 22
  1750 				; . . ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~  - 23
  1751
  1752 				; P0 - Darker grey shadow.
  1753 				; | . . . . | . . . . . . . . . . .  - 1  $00
  1754 				; | . . . . | . . . . . . . . . . .  - 2  $00
  1755 				; | . . . . | . . . . . . . . . . .  - 3  $00
  1756 				; | . . . . | . . . . . . . . . . .  - 4  $00
  1757 				; | . . . > | > > > > . . . . . . .  - 5  $1F
  1758 				; | . . > > | > > . . . . . . . . .  - 6  $3C
  1759 				; | . > > > | > . . . . . . . . . .  - 7  $78
  1760 				; | . > > > | . . . . . . . . . . .  - 8  $70
  1761 				; | > > > . | . . . . . . . . . . .  - 9  $E0
  1762 				; | > > > . | . . . . . . . . . . .  - 10 $E0
  1763 				; | > > . . | . . . . . . . . . . .  - 11 $C0
  1764 				; | > > . . | . . . . . . . . . . .  - 12 $C0
  1765 				; | > > . . | . . . . . . . . . . .  - 13 $C0
  1766 				; | > > . . | . . . . . . . . . . .  - 14 $C0
  1767 				; | > > . . | . . . . . . . . . . .  - 15 $C0
  1768 				; | > > . . | . . . . . . . . . . .  - 16 $C0
  1769 				; | > > . . | . . . . . . . . . . .  - 17 $C0
  1770 				; | > > . . | . . . . . . . . . . .  - 18 $C0
  1771 				; | > > . . | . . . . . . . . . . .  - 19 $C0
  1772 				; | > > . . | . . . . . . . . . . .  - 20 $C0
  1773 				; | > > . . | . . . . . . . . . . .  - 21 $C0
  1774 				; | . > . . | . . . . . . . . . . .  - 22 $40
  1775 				; | . . . . | . . . . . . . . . . .  - 23 $00
  1776
  1777 5847			PLAYER0_GRAVE_DATA
  1778 5847 00 00 00 00 1F 3C + 	.by $00 $00 $00 $00 $1F $3C $78 $70
  1779 584F E0 E0 C0 C0 C0 C0 + 	.by $E0 $E0 $C0 $C0 $C0 $C0 $C0 $C0 
  1780 5857 C0 C0 C0 C0 C0 40 + 	.by $C0 $C0 $C0 $C0 $C0 $40 $00
  1781
  1782 				; P1 - Detail right side
  1783 				; . . . . . . . | . ~ . . | . . . .  - 1  $40
  1784 				; . . . . . . . | ~ ~ ~ . | . . . .  - 2  $E0
  1785 				; . . . . . . . | . ~ . . | . . . .  - 3  $40
  1786 				; . . . . . . . | . ~ . . | . . . .  - 4  $40
  1787 				; . . . . . . . | . ~ . . | . . . .  - 5  $40
  1788 				; . . . . . . . | ~ ~ ~ ~ | . . . .  - 6  $F0
  1789 				; . . . . . . . | ~ ~ ~ ~ | ~ . . .  - 7  $F8
  1790 				; . . . . . . . | ~ ~ ~ ~ | ~ ~ . .  - 8  $FC
  1791 				; . . . . . . . | ~ ~ ~ ~ | ~ ~ ~ .  - 9  $FE
  1792 				; . . . . . . . | ~ ~ ~ ~ | ~ ~ ~ .  - 10 $FE
  1793 				; . . . . . . . | ~ ~ ~ ~ | ~ ~ ~ ~  - 11 $FF
  1794 				; . . . . . . . | ~ . ~ . | . ~ ~ ~  - 12 $A7
  1795 				; . . . . . . . | ~ . ~ . | ~ . ~ ~  - 13 $AB
  1796 				; . . . . . . . | ~ . ~ . | . ~ ~ ~  - 14 $A7
  1797 				; . . . . . . . | ~ . ~ . | ~ ~ ~ ~  - 15 $AF
  1798 				; . . . . . . . | ~ . ~ . | ~ ~ ~ ~  - 16 $AF
  1799 				; . . . . . . . | ~ ~ ~ ~ | ~ ~ ~ ~  - 17 $FF
  1800 				; . . . . . . . | . . . . | ~ ~ ~ ~  - 18 $0F
  1801 				; . . . . . . . | ~ ~ ~ ~ | ~ ~ ~ ~  - 19 $FF
  1802 				; . . . . . . . | ~ ~ ~ ~ | ~ ~ ~ ~  - 20 $FF
  1803 				; . . . . . . . | ~ ~ ~ ~ | ~ ~ ~ ~  - 21 $FF
  1804 				; . . . . . . . | ~ ~ ~ ~ | ~ ~ ~ ~  - 22 $FF
  1805 				; . . . . . . . | ~ ~ ~ ~ | ~ ~ ~ ~  - 23 $FF
  1806
  1807 585E			PLAYER1_GRAVE_DATA
  1808 585E 40 E0 40 40 40 F0 + 	.by $40 $E0 $40 $40 $40 $F0 $F8 $FC
  1809 5866 FE FE FF A7 AB A7 + 	.by $FE $FE $FF $A7 $AB $A7 $AF $AF
  1810 586E FF 0F FF FF FF FF + 	.by $FF $0F $FF $FF $FF $FF $FF
  1811
  1812
  1813 				; P2 + P3 - Black RIP 
  1814 				; . . . . | . | . . . . | . . . . . .  - 1  $00 $00
  1815 				; . . . . | . | . . . . | . . . . . .  - 2  $00 $00
  1816 				; . . . . | . | . . . . | . . . . . .  - 3  $00 $00
  1817 				; . . . . | . | . . . . | . . . . . .  - 4  $00 $00
  1818 				; . . . . | . | . . . . | . . . . . .  - 5  $00 $00
  1819 				; . . . . | . | . . . . | . . . . . .  - 6  $00 $00
  1820 				; . . . . | . | . . . . | . . . . . .  - 7  $00 $00
  1821 				; . . . . | . | . . . . | . . . . . .  - 8  $00 $00
  1822 				; . . . . | . | . . . . | . . . . . .  - 9  $00 $00
  1823 				; . . . . | . | . . . . | . . . . . .  - 10 $00 $00
  1824 				; . . . . | . | . . . . | . . . . . .  - 11 $00 $00
  1825 				; . . . . | 3 | 2 . . 2 | . 2 2 . . .  - 12 $80 $96
  1826 				; . . . . | 3 | . 2 . 2 | . 2 . 2 . .  - 13 $80 $55
  1827 				; . . . . | 3 | 2 . . 2 | . 2 2 . . .  - 14 $80 $96
  1828 				; . . . . | 3 | 2 . . 2 | . 2 . . . .  - 15 $80 $94
  1829 				; . . . . | 3 | . 2 . 2 | . 2 . . . .  - 16 $80 $54
  1830 				; . . . . | . | . . . . | . . . . . .  - 17 $00 $00
  1831 				; . . . . | . | . 2 2 2 | 2 2 . . . .  - 18 $00 $7C
  1832 				; . . . . | . | . . . . | . . . . . .  - 19 $00 $00
  1833 				; . . . . | . | . . . . | . . . . . .  - 20 $00 $00
  1834 				; . . . . | . | . . . . | . . . . . .  - 21 $00 $00
  1835 				; . . . . | . | . . . . | . . . . . .  - 22 $00 $00
  1836 				; . . . . | . | . . . . | . . . . . .  - 23 $00 $00
  1837
  1838 5875			PLAYER2_GRAVE_DATA
  1839 5875 00 00 00 00 00 00 + 	.by $00 $00 $00 $00 $00 $00 $00 $00 
  1840 587D 00 00 00 96 55 96 + 	.by $00 $00 $00 $96 $55 $96 $94 $54
  1841 5885 00 7C 00 00 00 00 + 	.by $00 $7C $00 $00 $00 $00 $00
  1842
  1843 588C			PLAYER3_GRAVE_DATA
  1844 588C 00 00 00 00 00 00 + 	.by $00 $00 $00 $00 $00 $00 $00 $00
  1845 5894 00 00 00 80 80 80 + 	.by $00 $00 $00 $80 $80 $80 $80 $80
  1846 589C 00 00 00 00 00 00 + 	.by $00 $00 $00 $00 $00 $00 $00
  1847
  1848
  1849 				; FYI, remaining left detail...
  1850 				; . . . . . . . . . . . . . . .  - 1
  1851 				; . . . . . . . . . . . . . . .  - 2
  1852 				; . . . . . . . . . . . . . . .  - 3
  1853 				; . . . . . . . . . . . . . . .  - 4
  1854 				; . . . . . . . . . . . . . . .  - 5 
  1855 				; . . . . . . ~ . . . . . . . .  - 6
  1856 				; . . . . . ~ ~ . . . . . . . .  - 7
  1857 				; . . . . ~ ~ ~ . . . . . . . .  - 8
  1858 				; . . . ~ ~ ~ ~ . . . . . . . .  - 9
  1859 				; . . . ~ ~ ~ ~ . . . . . . . .  - 10
  1860 				; . . ~ ~ ~ ~ ~ . . . . . . . .  - 11
  1861 				; . . ~ ~ . . ~ . . . . . . . .  - 12
  1862 				; . . ~ ~ . ~ . . . . . . . . .  - 13
  1863 				; . . ~ ~ . . ~ . . . . . . . .  - 14
  1864 				; . . ~ ~ . . ~ . . . . . . . .  - 15
  1865 				; . . ~ ~ . ~ . . . . . . . . .  - 16
  1866 				; . . ~ ~ ~ ~ ~ . . . . . . . .  - 17
  1867 				; . . ~ ~ ~ ~ . . . . . . . . .  - 18
  1868 				; . . ~ ~ ~ ~ ~ . . . . . . . .  - 19
  1869 				; . . ~ ~ ~ ~ ~ . . . . . . . .  - 20 
  1870 				; . . ~ ~ ~ ~ ~ . . . . . . . .  - 21
  1871 				; . . ~ ~ ~ ~ ~ . . . . . . . .  - 22
  1872 				; . . ~ ~ ~ ~ ~ . . . . . . . .  - 23
  1873
  1874 				; Masking 
  1875 				; M0 (p5) - left detail - quad width lowest priority.
  1876 				; Upper section masked by shadow (P0) and this is 
  1877 				; also lower priority than P2 and P3 displaying text.
  1878 				 
  1879 				; . ~  - 6   ; $01
  1880 				; ~ ~  - 7   ; $03
  1881 				; ~ ~  - 7   ; $03
  1882 				; ~ ~  - 7   ; $03
  1883 				; . . .
  1884 				; ~ ~  - 22  ; $03 
  1885 				; ~ ~  - 23  ; $03
  1886
  1887 				; . . . . . . . . . . . . . . .  - 1  $00
  1888 				; . . . . . . . . . . . . . . .  - 2  $00
  1889 				; . . . . . . . . . . . . . . .  - 3  $00
  1890 				; . . . . . . . . . . . . . . .  - 4  $00
  1891 				; . . . . . . . . . . . . . . .  - 5  $00
  1892 				; . . . . . . ~ ~ ~ ~ . . . . .  - 6  $01
  1893 				; . . ~ ~ ~ ~ ~ ~ ~ ~ . . . . .  - 7  $03
  1894 				; . . ~ ~ ~ ~ ~ ~ ~ ~ . . . . .  - 8  $03
  1895 				; . . ~ ~ ~ ~ ~ ~ ~ ~ . . . . .  - 9  $03
  1896 				; . . ~ ~ ~ ~ ~ ~ ~ ~ . . . . .  - 10 $03
  1897 				; . . ~ ~ ~ ~ ~ ~ ~ ~ . . . . .  - 11 $03
  1898 				; . . ~ ~ ~ ~ ~ ~ ~ ~ . . . . .  - 12 $03
  1899 				; . . ~ ~ ~ ~ ~ ~ ~ ~ . . . . .  - 13 $03
  1900 				; . . ~ ~ ~ ~ ~ ~ ~ ~ . . . . .  - 14 $03
  1901 				; . . ~ ~ ~ ~ ~ ~ ~ ~ . . . . .  - 15 $03
  1902 				; . . ~ ~ ~ ~ ~ ~ ~ ~ . . . . .  - 16 $03
  1903 				; . . ~ ~ ~ ~ ~ ~ ~ ~ . . . . .  - 17 $03
  1904 				; . . ~ ~ ~ ~ ~ ~ ~ ~ . . . . .  - 18 $03
  1905 				; . . ~ ~ ~ ~ ~ ~ ~ ~ . . . . .  - 19 $03
  1906 				; . . ~ ~ ~ ~ ~ ~ ~ ~ . . . . .  - 20 $03
  1907 				; . . ~ ~ ~ ~ ~ ~ ~ ~ . . . . .  - 21 $03
  1908 				; . . ~ ~ ~ ~ ~ ~ ~ ~ . . . . .  - 22 $03
  1909 				; . . ~ ~ ~ ~ ~ ~ ~ ~ . . . . .  - 23 $03
  1910
  1911 58A3			PLAYER5_GRAVE_DATA; Missile 0
  1912 58A3 00 00 00 00 00 01 + 	.by $00 $00 $00 $00 $00 $01 $03 $03
  1913 58AB 03 03 03 03 03 03 + 	.by $03 $03 $03 $03 $03 $03 $03 $03
  1914 58B3 03 03 03 03 03 03 + 	.by $03 $03 $03 $03 $03 $03 $03
  1915
  1916
  1917 58BA			BASE_PMCOLORS_TABLE ; When "off", and so multiplication for frog = 1 works.
  1918 58BA 00 00 00 00			.by 0 0 0 0
  1919
  1920 58BE			FROG_PMCOLORS_TABLE ; 0, 1, 2, 3
  1921 58BE C4				.by COLOR_GREEN+$4       ; P0, frog
  1922 58BF C2				.by COLOR_GREEN+$2       ; P1, frog, green iris
  1923 58C0 0E				.by COLOR_BLACK+$E       ; P2, frog mouth 
  1924 58C1 00				.by COLOR_BLACK          ; P3, (and M3) Left/Right Wall Masks 
  1925
  1926 58C2			SPLAT_PMCOLORS_TABLE ; 0, 1, 2, 3
  1927 58C2 44				.by COLOR_PINK+$4        ; P0, splat
  1928 58C3 42				.by COLOR_PINK+$2        ; P1, splat
  1929 58C4 46				.by COLOR_PINK+$6        ; P2, 
  1930 58C5 00				.by COLOR_BLACK          ; P3, (and M3) Left/Right Wall Masks 
  1931
  1932 				; Splash screens don't use the wall masks.
  1933
  1934 58C6			GRAVE_PMCOLORS_TABLE ; 0, 1, 2, 3
  1935 58C6 02				.by COLOR_BLACK+$2        ; P0, 
  1936 58C7 0E				.by COLOR_BLACK+$e        ; P1, 
  1937 58C8 00				.by COLOR_BLACK+$0        ; P2, 
  1938 58C9 00				.by COLOR_BLACK+$0        ; P3, 
  1939
  1940 				; Farbenwackerdoodle...  P/Ms provide the color text labels 
  1941 				; for Scores and Lives.  Why?  Well, originally for Version 02
  1942 				; artifact colors were used to make green labels on the score 
  1943 				; lines, because the entire display was ANTIC text mode 2.  
  1944 				; This treatment followed along to Version 03, because that's 
  1945 				; where the source started.  But, this effect is not looking so 
  1946 				; wonderful for playtesters using non-composite/non-CRT and 
  1947 				; PAL displays.
  1948 				;
  1949 				; So, the obvious change is using ANTIC Mode 4 for these labels.
  1950 				; While this is fine for the labels and even the numbers, this
  1951 				; impairs the custom character graphic used to count saved frogs.
  1952 				; There's just 4 color clocks in a ANTIC Mode 4 character and its
  1953 				; just not possible to render two eyes in a face. So, this still 
  1954 				; needs a high-res representation.  Then what to do about the text?
  1955 				;
  1956 				; We could go to using the custom character set defined for the 
  1957 				; title text.  But, then there's only one color available for 
  1958 				; these lines.  Boring.  Monotonous compared to everything else 
  1959 				; going on.
  1960 				;
  1961 				; We could just change the background color to make the Mode 2 
  1962 				; text look green, but that affects everything on the line.  I 
  1963 				; like the white score numbers (and the frog head counters), but 
  1964 				; want different label text on the same line.
  1965 				;
  1966 				; We could use Player/Missile graphics to hilight just the labels.
  1967 				; That would allow tinting them another color.  That's an OK idea,
  1968 				; But the hilights covering some text just looks weird to me and 
  1969 				; a bit out of place with the workings of everything else on the 
  1970 				; display. 
  1971 				;
  1972 				; Now that we're on the subject of Player/Missile graphics how 
  1973 				; about "writing" the labels on the lines using P/M graphics? 
  1974 				; Single line resolution, normal width players have pixels one
  1975 				; scan line tall, and one color clock wide -- exactly the same 
  1976 				; as pixels in ANTIC Mode 4 text.  We need four pixels 
  1977 				; horizontally per character, three for the character and one 
  1978 				; to provide a gap before the next character.  The four  
  1979 				; players and four missile provide a total of 40 pixels, so we 
  1980 				; could work 10 characters into this.  One player provides 8
  1981 				; pixels, so each player can support 2 characters.
  1982 				;
  1983 				; Since we're already dealing with multiple VBIs to make the 
  1984 				; text lines have different colors then we can just add the 
  1985 				; Players and Missiles to this, so they can be colored 
  1986 				; and positioned differently for each line. Also, IF the letters 
  1987 				; of a word can be isolated to the matching Players with their 
  1988 				; Missiles, then the labels can be individually colored which
  1989 				; allows effects such as glowing labels when values change.
  1990 				;
  1991 				; The text on the score line is easy -- "Score" and "Hi". 
  1992 				; "Score" requires three Players.  (Or two Players and two 
  1993 				; Missiles for "Score" which use fewer color registers.) 
  1994 				; "Hi" requires one Player.  
  1995 				; 
  1996 				; The next line has issues.  Per Version 02 design the labels 
  1997 				; are, "Frogs" for number of lives, and "Frogs Saved" for the 
  1998 				; count of rescued frogs. This is 15 characters -- more than the 
  1999 				; character budget that Player/Missiles will allow. "Frogs" is
  2000 				; five characters, so this needs two Players and two Missiles.
  2001 				; (Alternatively, this could be changed to "Lives" which has 
  2002 				; two letters, "Li", that can be rendered in fewer horizontal 
  2003 				; pixels.)  "Frogs Saved" is too big, 10 characters by itself.  
  2004 				; It must be truncated. "Saved" is 5 letters needing two Players
  2005 				; and two Missiles.  That is the budget for the line.
  2006 				; 
  2007 				; Now that the Players/Missiles are being re-used they need to 
  2008 				; be added to the DLIs to change color, size, horizontal 
  2009 				; position, and priority.   Also, the same characteristics must 
  2010 				; be reset for the game's main Player object.  Time for more 
  2011 				; lookup tables to position all the objects and set colors. This 
  2012 				; moves the game's Player object controls into regular memory 
  2013 				; (like shadow registers if you think about it), changing all 
  2014 				; the code for Player/Missile positions.  Oh, joy.   
  2015
  2016 58CA			P0TEXT_TABLE ; 15 bytes 
  2017 58CA E0 8E E8 28 28 EE + 	.by $E0 $8E $E8 $28 $28 $EE $00 $00 $00 $e0 $8e $c8 $88 $88 $88 
  2018 				; XX XX XX .. .. .. .. .. - $E0
  2019 				; XX .. .. .. XX XX XX .. - $8E 
  2020 				; XX XX XX .. XX .. .. .. - $E8 
  2021 				; .. .. XX .. XX .. .. .. - $28 
  2022 				; .. .. XX .. XX .. .. .. - $28 
  2023 				; XX XX XX .. XX XX XX .. - $EE 
  2024 				; .. .. .. .. .. .. .. .. - $00 
  2025 				; .. .. .. .. .. .. .. .. - $00 
  2026 				; XX XX XX .. .. .. .. .. - $e0 
  2027 				; XX .. .. .. XX XX XX .. - $8e 
  2028 				; XX XX .. .. XX .. .. .. - $c8 
  2029 				; XX .. .. .. XX .. .. .. - $88 
  2030 				; XX .. .. .. XX .. .. .. - $88 
  2031 				; XX .. .. .. XX .. .. .. - $88 
  2032
  2033 58D9			P1TEXT_TABLE ; 15 bytes 
  2034 58D9 00 EE A8 A8 A8 E8 + 	.by $00 $EE $A8 $A8 $A8 $E8 $00 $00 $00 $00 $EE $A8 $AA $AA $EE
  2035 				; .. .. .. .. .. .. .. .. - $00 
  2036 				; XX XX XX .. XX XX XX .. - $EE 
  2037 				; XX .. XX .. XX .. .. .. - $A8 
  2038 				; XX .. XX .. XX .. .. .. - $A8 
  2039 				; XX .. XX .. XX .. .. .. - $A8 
  2040 				; XX XX XX .. XX .. .. .. - $E8 
  2041 				; .. .. .. .. .. .. .. .. - $00 
  2042 				; .. .. .. .. .. .. .. .. - $00 
  2043 				; .. .. .. .. .. .. .. .. - $00 
  2044 				; XX XX XX .. XX XX XX .. - $EE 
  2045 				; XX .. XX .. XX .. .. .. - $A8 
  2046 				; XX .. XX .. XX .. XX .. - $AA 
  2047 				; XX .. XX .. XX .. XX .. - $AA 
  2048 				; XX XX XX .. XX XX XX .. - $EE 
  2049
  2050 58E8			P2TEXT_TABLE ; 15 bytes 
  2051 58E8 A0 A8 E8 A8 A8 A8 + 	.by $A0 $A8 $E8 $A8 $A8 $A8 $00 $00 $00 $E0 $8E $EA $2E $2A $EA
  2052 				; XX .. XX .. .. .. .. .. - $A0 
  2053 				; XX .. XX .. XX .. .. .. - $A8 
  2054 				; XX XX XX .. XX .. .. .. - $E8 
  2055 				; XX .. XX .. XX .. .. .. - $A8 
  2056 				; XX .. XX .. XX .. .. .. - $A8 
  2057 				; XX .. XX .. XX .. .. .. - $A8 
  2058 				; .. .. .. .. .. .. .. .. - $00 
  2059 				; .. .. .. .. .. .. .. .. - $00 
  2060 				; XX XX XX .. .. .. .. .. - $E0
  2061 				; XX .. .. .. XX XX XX .. - $8E 
  2062 				; XX XX XX .. XX .. XX .. - $EA 
  2063 				; .. .. XX .. XX XX XX .. - $2E 
  2064 				; .. .. XX .. XX .. XX .. - $2A 
  2065 				; XX XX XX .. XX .. XX .. - $EA
  2066
  2067 58F7			P3TEXT_TABLE ; 15 bytes 
  2068 58F7 00 00 00 00 00 00 + 	.by $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $AE $A8 $AC $A8 $4E
  2069 				; .. .. .. .. .. .. .. .. - $00 
  2070 				; .. .. .. .. .. .. .. .. - $00 
  2071 				; .. .. .. .. .. .. .. .. - $00 
  2072 				; .. .. .. .. .. .. .. .. - $00 
  2073 				; .. .. .. .. .. .. .. .. - $00 
  2074 				; .. .. .. .. .. .. .. .. - $00 
  2075 				; .. .. .. .. .. .. .. .. - $00 
  2076 				; .. .. .. .. .. .. .. .. - $00 
  2077 				; .. .. .. .. .. .. .. .. - $00 
  2078 				; XX .. XX .. XX XX XX .. - $AE 
  2079 				; XX .. XX .. XX .. .. .. - $A8 
  2080 				; XX .. XX .. XX XX .. .. - $AC 
  2081 				; XX .. XX .. XX .. .. .. - $A8 
  2082 				; .. XX .. .. XX XX XX .. - $4E
  2083
  2084 5906			MTEXT_TABLE ; 15 bytes (Each byte has 2 bits for m3 m2 m1 m0...)
  2085 5906 00 0E 08 0C 08 0E + 	.by $00 $0E $08 $0C $08 $0E $00 $00 $00 $00 $CE $A8 $AE $A2 $CE
  2086 				; .. .. .. .. .. .. .. .. - $00
  2087 				; .. .. .. .. XX XX XX .. - $0E 
  2088 				; .. .. .. .. XX .. .. .. - $08 
  2089 				; .. .. .. .. XX XX .. .. - $0C 
  2090 				; .. .. .. .. XX .. .. .. - $08 
  2091 				; .. .. .. .. XX XX XX .. - $0E 
  2092 				; .. .. .. .. .. .. .. .. - $00
  2093 				; .. .. .. .. .. .. .. .. - $00
  2094 				; .. .. .. .. .. .. .. .. - $00
  2095 				; XX XX .. .. XX XX XX .. - $CE 
  2096 				; XX .. XX .. XX .. .. .. - $A8 
  2097 				; XX .. XX .. XX XX XX .. - $AE 
  2098 				; XX .. XX .. .. .. XX .. - $A2 
  2099 				; XX XX .. .. XX XX XX .. - $CE 
  2100
   728
   729 				; --------------------------------------------------------------------------
   730
   731 				; ==========================================================================
   732 				; Inform DOS of the program's Auto-Run address...
   733 				; GameStart is in the "Game.asm' file.
   734 				; --------------------------------------------------------------------------
   735
   736 5915				mDiskDPoke DOS_RUN_ADDR, GameStart
Macro: MDISKDPOKE [Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/macros.asm]
     4 = 5915					DISKDPOKE_TEMP =*
     5 5915					ORG DOS_RUN_ADDR
     6 02E0-02E1> 1D 22				.word GAMESTART
     7 02E2					ORG DISKDPOKE_TEMP
Source: /home/kenjen/eclipse-workspace/ata-Pet-Frogger/PetFroggerV03/Frogger03.asm
   737
   738 					END
